From 326c131abf49abac5b279a0e04cd8ab9d463df2b Mon Sep 17 00:00:00 2001
From: Ashwin H <Ashwin.H@amd.com>
Date: Thu, 22 Jun 2023 01:56:03 +0530
Subject: [PATCH] Add amd-pensando elba soc support

---
 .../bindings/mfd/amd,pensando-elbasr.yaml          |   93 +
 Documentation/devicetree/bindings/mfd/syscon.yaml  |    1 +
 .../bindings/reset/amd,pensando-elbasr-reset.yaml  |   62 +
 arch/arm64/Kconfig.platforms                       |    5 +
 arch/arm64/boot/dts/Makefile                       |    1 +
 arch/arm64/boot/dts/pensando/Makefile              |    6 +
 arch/arm64/boot/dts/pensando/elba-16core-psci.dtsi |   57 +
 .../boot/dts/pensando/elba-16core-spin-table.dtsi  |   50 +
 arch/arm64/boot/dts/pensando/elba-16core.dtsi      |  170 ++
 arch/arm64/boot/dts/pensando/elba-asic-common.dtsi |  114 ++
 arch/arm64/boot/dts/pensando/elba-asic-memory.dtsi |   16 +
 arch/arm64/boot/dts/pensando/elba-asic-psci.dts    |   26 +
 arch/arm64/boot/dts/pensando/elba-asic.dts         |   26 +
 arch/arm64/boot/dts/pensando/elba-flash-parts.dtsi |  115 ++
 arch/arm64/boot/dts/pensando/elba-mdev.dtsi        |   71 +
 arch/arm64/boot/dts/pensando/elba.dtsi             |  354 ++++
 arch/arm64/configs/elba_defconfig                  |  300 +++
 arch/arm64/include/asm/traps.h                     |    1 +
 arch/arm64/kernel/traps.c                          |    8 +
 drivers/edac/Kconfig                               |    7 +
 drivers/edac/Makefile                              |    1 +
 drivers/edac/elba_edac.c                           |  548 ++++++
 drivers/hwmon/pmbus/ltc2978.c                      |   43 +-
 drivers/hwmon/pmbus/tps53679.c                     |    9 +-
 drivers/i2c/busses/Kconfig                         |   21 +
 drivers/i2c/busses/Makefile                        |    2 +
 drivers/i2c/busses/i2c-designware-common.c         |    5 +
 drivers/i2c/busses/i2c-designware-core.h           |   10 +
 drivers/i2c/busses/i2c-designware-master.c         |  160 +-
 drivers/i2c/busses/i2c-designware-mctp.c           | 1970 ++++++++++++++++++++
 drivers/i2c/busses/i2c-designware-mctp.h           |  209 +++
 drivers/i2c/busses/i2c-designware-platdrv.c        |    3 +
 drivers/i2c/busses/i2c-designware-slave.c          |   88 +-
 drivers/i2c/busses/i2c-rd1173.c                    |  838 +++++++++
 drivers/irqchip/Kconfig                            |   11 +
 drivers/irqchip/Makefile                           |    1 +
 drivers/irqchip/irq-pensando.c                     |  879 +++++++++
 drivers/mfd/Kconfig                                |   14 +
 drivers/mfd/Makefile                               |    1 +
 drivers/mfd/pensando-elbasr.c                      |  867 +++++++++
 drivers/mmc/host/Kconfig                           |    1 +
 drivers/mmc/host/sdhci-cadence.c                   |  183 +-
 drivers/reset/Kconfig                              |    9 +
 drivers/reset/Makefile                             |    1 +
 drivers/reset/reset-elbasr.c                       |  106 ++
 drivers/soc/Kconfig                                |    1 +
 drivers/soc/Makefile                               |    1 +
 drivers/soc/pensando/Kconfig                       |   89 +
 drivers/soc/pensando/Makefile                      |   16 +
 drivers/soc/pensando/bsm_dev.h                     |   24 +
 drivers/soc/pensando/cap_bsm.c                     |  159 ++
 drivers/soc/pensando/cap_crash.c                   |  154 ++
 drivers/soc/pensando/cap_mem.c                     |  484 +++++
 drivers/soc/pensando/cap_pcie.c                    |  445 +++++
 drivers/soc/pensando/cap_pcie_common.h             |   52 +
 drivers/soc/pensando/cap_pcie_elba.h               |   13 +
 drivers/soc/pensando/cap_reboot.c                  |  110 ++
 drivers/soc/pensando/cap_reboot.h                  |   12 +
 drivers/soc/pensando/cap_rstcause.c                |  218 +++
 drivers/soc/pensando/cap_rstcause.h                |   15 +
 drivers/soc/pensando/cap_soc.c                     |   31 +
 drivers/soc/pensando/cap_tracepoint.h              |  172 ++
 drivers/soc/pensando/capmem_dev.h                  |   34 +
 drivers/soc/pensando/kpci_constants.h              |   42 +
 drivers/soc/pensando/kpcimgr.c                     |  886 +++++++++
 drivers/soc/pensando/kpcimgr_api.h                 |  172 ++
 drivers/soc/pensando/kpcimgr_sysfs.c               |  277 +++
 drivers/soc/pensando/penfw.h                       |   35 +
 drivers/soc/pensando/penfw_drv.c                   |  145 ++
 drivers/soc/pensando/penfw_smc.c                   |   63 +
 drivers/soc/pensando/penfw_sysfs.c                 |  421 +++++
 drivers/soc/pensando/penfw_sysfs.h                 |   11 +
 drivers/soc/pensando/penpcie_dev.h                 |   26 +
 drivers/soc/pensando/sbus.c                        |  303 +++
 drivers/spi/spi-cadence-quadspi.c                  |   19 +
 drivers/spi/spi-dw-mmio.c                          |   90 +-
 drivers/spi/spidev.c                               |    1 +
 drivers/uio/Kconfig                                |   44 +
 drivers/uio/Makefile                               |    5 +
 drivers/uio/uio_linkmac.c                          |   30 +
 drivers/uio/uio_pciemac.c                          |   30 +
 drivers/uio/uio_pengic.c                           |  664 +++++++
 drivers/uio/uio_pengic.h                           |   18 +
 drivers/uio/uio_penmsi.c                           |  568 ++++++
 drivers/uio/uio_penmsi.h                           |   17 +
 drivers/uio/uio_penmsi1.c                          |   32 +
 .../dt-bindings/reset/amd,pensando-elba-reset.h    |   11 +
 include/linux/irqchip/irq-pensando.h               |   91 +
 include/linux/mfd/pensando-elbasr.h                |   41 +
 89 files changed, 13513 insertions(+), 22 deletions(-)
 create mode 100644 Documentation/devicetree/bindings/mfd/amd,pensando-elbasr.yaml
 create mode 100644 Documentation/devicetree/bindings/reset/amd,pensando-elbasr-reset.yaml
 create mode 100644 arch/arm64/boot/dts/pensando/Makefile
 create mode 100644 arch/arm64/boot/dts/pensando/elba-16core-psci.dtsi
 create mode 100644 arch/arm64/boot/dts/pensando/elba-16core-spin-table.dtsi
 create mode 100644 arch/arm64/boot/dts/pensando/elba-16core.dtsi
 create mode 100644 arch/arm64/boot/dts/pensando/elba-asic-common.dtsi
 create mode 100644 arch/arm64/boot/dts/pensando/elba-asic-memory.dtsi
 create mode 100644 arch/arm64/boot/dts/pensando/elba-asic-psci.dts
 create mode 100644 arch/arm64/boot/dts/pensando/elba-asic.dts
 create mode 100644 arch/arm64/boot/dts/pensando/elba-flash-parts.dtsi
 create mode 100644 arch/arm64/boot/dts/pensando/elba-mdev.dtsi
 create mode 100644 arch/arm64/boot/dts/pensando/elba.dtsi
 create mode 100644 arch/arm64/configs/elba_defconfig
 create mode 100644 drivers/edac/elba_edac.c
 create mode 100644 drivers/i2c/busses/i2c-designware-mctp.c
 create mode 100644 drivers/i2c/busses/i2c-designware-mctp.h
 create mode 100644 drivers/i2c/busses/i2c-rd1173.c
 create mode 100644 drivers/irqchip/irq-pensando.c
 create mode 100644 drivers/mfd/pensando-elbasr.c
 create mode 100644 drivers/reset/reset-elbasr.c
 create mode 100644 drivers/soc/pensando/Kconfig
 create mode 100644 drivers/soc/pensando/Makefile
 create mode 100644 drivers/soc/pensando/bsm_dev.h
 create mode 100644 drivers/soc/pensando/cap_bsm.c
 create mode 100644 drivers/soc/pensando/cap_crash.c
 create mode 100644 drivers/soc/pensando/cap_mem.c
 create mode 100644 drivers/soc/pensando/cap_pcie.c
 create mode 100644 drivers/soc/pensando/cap_pcie_common.h
 create mode 100644 drivers/soc/pensando/cap_pcie_elba.h
 create mode 100644 drivers/soc/pensando/cap_reboot.c
 create mode 100644 drivers/soc/pensando/cap_reboot.h
 create mode 100644 drivers/soc/pensando/cap_rstcause.c
 create mode 100644 drivers/soc/pensando/cap_rstcause.h
 create mode 100644 drivers/soc/pensando/cap_soc.c
 create mode 100644 drivers/soc/pensando/cap_tracepoint.h
 create mode 100644 drivers/soc/pensando/capmem_dev.h
 create mode 100644 drivers/soc/pensando/kpci_constants.h
 create mode 100644 drivers/soc/pensando/kpcimgr.c
 create mode 100644 drivers/soc/pensando/kpcimgr_api.h
 create mode 100644 drivers/soc/pensando/kpcimgr_sysfs.c
 create mode 100644 drivers/soc/pensando/penfw.h
 create mode 100644 drivers/soc/pensando/penfw_drv.c
 create mode 100644 drivers/soc/pensando/penfw_smc.c
 create mode 100644 drivers/soc/pensando/penfw_sysfs.c
 create mode 100644 drivers/soc/pensando/penfw_sysfs.h
 create mode 100644 drivers/soc/pensando/penpcie_dev.h
 create mode 100644 drivers/soc/pensando/sbus.c
 create mode 100644 drivers/uio/uio_linkmac.c
 create mode 100644 drivers/uio/uio_pciemac.c
 create mode 100644 drivers/uio/uio_pengic.c
 create mode 100644 drivers/uio/uio_pengic.h
 create mode 100644 drivers/uio/uio_penmsi.c
 create mode 100644 drivers/uio/uio_penmsi.h
 create mode 100644 drivers/uio/uio_penmsi1.c
 create mode 100644 include/dt-bindings/reset/amd,pensando-elba-reset.h
 create mode 100644 include/linux/irqchip/irq-pensando.h
 create mode 100644 include/linux/mfd/pensando-elbasr.h

diff --git a/Documentation/devicetree/bindings/mfd/amd,pensando-elbasr.yaml b/Documentation/devicetree/bindings/mfd/amd,pensando-elbasr.yaml
new file mode 100644
index 00000000..1335680
--- /dev/null
+++ b/Documentation/devicetree/bindings/mfd/amd,pensando-elbasr.yaml
@@ -0,0 +1,93 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/mfd/amd,pensando-elbasr.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: AMD Pensando Elba SoC Resource Controller bindings
+
+description: |
+  AMD Pensando Elba SoC Resource Controller bindings attached to a SPI bus.
+
+maintainers:
+  - Brad Larson <blarson@amd.com>
+
+properties:
+  compatible:
+    items:
+      - enum:
+          - amd,pensando-elbasr
+      - const: simple-mfd
+
+  spi-max-frequency:
+    description: Maximum SPI frequency of the device in Hz.
+
+  reg:
+    maxItems: 1
+
+  '#address-cells':
+    const: 1
+
+  '#size-cells':
+    const: 0
+
+  interrupts:
+    maxItems: 1
+
+required:
+  - compatible
+  - reg
+  - spi-max-frequency
+
+patternProperties:
+  '^reset-controller@[a-f0-9]+$':
+    $ref: ../reset/amd,pensando-elbasr-reset.yaml
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/reset/amd,pensando-elba-reset.h>
+    #include <dt-bindings/interrupt-controller/arm-gic.h>
+
+    spi0 {
+        #address-cells = <1>;
+        #size-cells = <0>;
+        num-cs = <4>;
+
+        spi@0 {
+          compatible = "amd,pensando-elbasr", "simple-mfd";
+          reg = <0>;
+          #address-cells = <1>;
+          #size-cells = <0>;
+          spi-max-frequency = <12000000>;
+
+          rstc: reset-controller@0 {
+            compatible = "amd,pensando-elbasr-reset";
+            reg = <0>;
+            #reset-cells = <1>;
+          };
+        };
+
+        spi@1 {
+          compatible = "amd,pensando-elbasr", "simple-mfd";
+          reg = <1>;
+          spi-max-frequency = <12000000>;
+        };
+
+        spi@2 {
+          compatible = "amd,pensando-elbasr", "simple-mfd";
+          reg = <2>;
+          spi-max-frequency = <12000000>;
+          interrupt-parent = <&porta>;
+          interrupts = <0 IRQ_TYPE_LEVEL_LOW>;
+        };
+
+        spi@3 {
+          compatible = "amd,pensando-elbasr", "simple-mfd";
+          reg = <3>;
+          spi-max-frequency = <12000000>;
+        };
+    };
+
+...
diff --git a/Documentation/devicetree/bindings/mfd/syscon.yaml b/Documentation/devicetree/bindings/mfd/syscon.yaml
index 8f4764a..1b08cba 100644
--- a/Documentation/devicetree/bindings/mfd/syscon.yaml
+++ b/Documentation/devicetree/bindings/mfd/syscon.yaml
@@ -38,6 +38,7 @@ properties:
               - allwinner,sun8i-h3-system-controller
               - allwinner,sun8i-v3s-system-controller
               - allwinner,sun50i-a64-system-controller
+              - amd,pensando-elba-syscon
               - hisilicon,dsa-subctrl
               - hisilicon,hi6220-sramctrl
               - hisilicon,pcie-sas-subctrl
diff --git a/Documentation/devicetree/bindings/reset/amd,pensando-elbasr-reset.yaml b/Documentation/devicetree/bindings/reset/amd,pensando-elbasr-reset.yaml
new file mode 100644
index 00000000..03bb86e
--- /dev/null
+++ b/Documentation/devicetree/bindings/reset/amd,pensando-elbasr-reset.yaml
@@ -0,0 +1,62 @@
+# SPDX-License-Identifier: (GPL-2.0 OR BSD-2-Clause)
+%YAML 1.2
+---
+$id: http://devicetree.org/schemas/reset/amd,pensando-elbasr-reset.yaml#
+$schema: http://devicetree.org/meta-schemas/core.yaml#
+
+title: AMD Pensando Elba SoC Reset Controller Device Tree Bindings
+
+maintainers:
+  - Brad Larson <blarson@amd.com>
+
+description: |
+  AMD Pensando Elba SoC reset controller driver which supports a resource
+  controller connected to the Elba SoC over a SPI bus.  The Elba reset
+  controller must be defined as a child node of the Elba SPI bus
+  chip-select 0 node.
+
+  See also:
+  - dt-bindings/reset/amd,pensando-elba-reset.h
+
+properties:
+  $nodename:
+    pattern: "^reset-controller@[0-9a-f]+$"
+
+  compatible:
+    const: amd,pensando-elbasr-reset
+
+  reg:
+    const: 0
+
+  '#reset-cells':
+    const: 1
+
+required:
+  - compatible
+  - reg
+  - '#reset-cells'
+
+additionalProperties: false
+
+examples:
+  - |
+    #include <dt-bindings/reset/amd,pensando-elba-reset.h>
+    spi0 {
+        #address-cells = <1>;
+        #size-cells = <0>;
+        num-cs = <4>;
+
+        spi@0 {
+          reg = <0>;
+          #address-cells = <1>;
+          #size-cells = <0>;
+
+          rstc: reset-controller@0 {
+            compatible = "amd,pensando-elbasr-reset";
+            reg = <0>;
+            #reset-cells = <1>;
+          };
+        };
+    };
+
+...
diff --git a/arch/arm64/Kconfig.platforms b/arch/arm64/Kconfig.platforms
index 889e78f..3fcd58b 100644
--- a/arch/arm64/Kconfig.platforms
+++ b/arch/arm64/Kconfig.platforms
@@ -199,6 +199,11 @@ config ARCH_MXC
 	  This enables support for the ARMv8 based SoCs in the
 	  NXP i.MX family.
 
+config ARCH_PENSANDO
+	bool "Pensando Platforms"
+	help
+	  This enables support for the ARMv8 based Pensando chipsets
+
 config ARCH_QCOM
 	bool "Qualcomm Platforms"
 	select GPIOLIB
diff --git a/arch/arm64/boot/dts/Makefile b/arch/arm64/boot/dts/Makefile
index 9b117065..c6fa0d2 100644
--- a/arch/arm64/boot/dts/Makefile
+++ b/arch/arm64/boot/dts/Makefile
@@ -19,6 +19,7 @@ subdir-y += marvell
 subdir-y += mediatek
 subdir-y += microchip
 subdir-y += nvidia
+subdir-y += pensando
 subdir-y += qcom
 subdir-y += realtek
 subdir-y += renesas
diff --git a/arch/arm64/boot/dts/pensando/Makefile b/arch/arm64/boot/dts/pensando/Makefile
new file mode 100644
index 00000000..a1ade7e
--- /dev/null
+++ b/arch/arm64/boot/dts/pensando/Makefile
@@ -0,0 +1,6 @@
+# SPDX-License-Identifier: GPL-2.0
+dtb-$(CONFIG_ARCH_PENSANDO_ELBA_SOC) += elba-asic-psci.dtb
+
+always-y	:= $(dtb-y)
+subdir-y	:= $(dts-dirs)
+clean-files	:= *.dtb
diff --git a/arch/arm64/boot/dts/pensando/elba-16core-psci.dtsi b/arch/arm64/boot/dts/pensando/elba-16core-psci.dtsi
new file mode 100644
index 00000000..099bfae
--- /dev/null
+++ b/arch/arm64/boot/dts/pensando/elba-16core-psci.dtsi
@@ -0,0 +1,57 @@
+// SPDX-License-Identifier: GPL-2.0
+
+&cpu0 {
+	enable-method = "psci";
+};
+&cpu1 {
+	enable-method = "psci";
+};
+&cpu2 {
+	enable-method = "psci";
+};
+&cpu3 {
+	enable-method = "psci";
+};
+&cpu4 {
+	enable-method = "psci";
+};
+&cpu5 {
+	enable-method = "psci";
+};
+&cpu6 {
+	enable-method = "psci";
+};
+&cpu7 {
+	enable-method = "psci";
+};
+&cpu8 {
+	enable-method = "psci";
+};
+&cpu9 {
+	enable-method = "psci";
+};
+&cpu10 {
+	enable-method = "psci";
+};
+&cpu11 {
+	enable-method = "psci";
+};
+&cpu12 {
+	enable-method = "psci";
+};
+&cpu13 {
+	enable-method = "psci";
+};
+&cpu14 {
+	enable-method = "psci";
+};
+&cpu15 {
+	enable-method = "psci";
+};
+
+/ {
+	psci {
+		compatible = "arm,psci-0.2";
+		method = "smc";
+	};
+};
diff --git a/arch/arm64/boot/dts/pensando/elba-16core-spin-table.dtsi b/arch/arm64/boot/dts/pensando/elba-16core-spin-table.dtsi
new file mode 100644
index 00000000..ef783fc
--- /dev/null
+++ b/arch/arm64/boot/dts/pensando/elba-16core-spin-table.dtsi
@@ -0,0 +1,50 @@
+// SPDX-License-Identifier: GPL-2.0
+
+&cpu0 {
+	enable-method = "spin-table";
+};
+&cpu1 {
+	enable-method = "spin-table";
+};
+&cpu2 {
+	enable-method = "spin-table";
+};
+&cpu3 {
+	enable-method = "spin-table";
+};
+&cpu4 {
+	enable-method = "spin-table";
+};
+&cpu5 {
+	enable-method = "spin-table";
+};
+&cpu6 {
+	enable-method = "spin-table";
+};
+&cpu7 {
+	enable-method = "spin-table";
+};
+&cpu8 {
+	enable-method = "spin-table";
+};
+&cpu9 {
+	enable-method = "spin-table";
+};
+&cpu10 {
+	enable-method = "spin-table";
+};
+&cpu11 {
+	enable-method = "spin-table";
+};
+&cpu12 {
+	enable-method = "spin-table";
+};
+&cpu13 {
+	enable-method = "spin-table";
+};
+&cpu14 {
+	enable-method = "spin-table";
+};
+&cpu15 {
+	enable-method = "spin-table";
+};
diff --git a/arch/arm64/boot/dts/pensando/elba-16core.dtsi b/arch/arm64/boot/dts/pensando/elba-16core.dtsi
new file mode 100644
index 00000000..bf5da7b
--- /dev/null
+++ b/arch/arm64/boot/dts/pensando/elba-16core.dtsi
@@ -0,0 +1,170 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/ {
+	cpus {
+		#address-cells = <2>;
+		#size-cells = <0>;
+
+		cpu-map {
+			cluster0 {
+				core0 { cpu = <&cpu0>; };
+				core1 { cpu = <&cpu1>; };
+				core2 { cpu = <&cpu2>; };
+				core3 { cpu = <&cpu3>; };
+			};
+
+			cluster1 {
+				core0 { cpu = <&cpu4>; };
+				core1 { cpu = <&cpu5>; };
+				core2 { cpu = <&cpu6>; };
+				core3 { cpu = <&cpu7>; };
+			};
+
+			cluster2 {
+				core0 { cpu = <&cpu8>; };
+				core1 { cpu = <&cpu9>; };
+				core2 { cpu = <&cpu10>; };
+				core3 { cpu = <&cpu11>; };
+			};
+
+			cluster3 {
+				core0 { cpu = <&cpu12>; };
+				core1 { cpu = <&cpu13>; };
+				core2 { cpu = <&cpu14>; };
+				core3 { cpu = <&cpu15>; };
+			};
+		};
+
+		/* CLUSTER 0 */
+		cpu0: cpu@0 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a72", "arm,armv8";
+			reg = <0 0x0>;
+			next-level-cache = <&l2_0>;
+		};
+
+		cpu1: cpu@1 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a72", "arm,armv8";
+			reg = <0 0x1>;
+			next-level-cache = <&l2_0>;
+		};
+
+		cpu2: cpu@2 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a72", "arm,armv8";
+			reg = <0 0x2>;
+			next-level-cache = <&l2_0>;
+		};
+
+		cpu3: cpu@3 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a72", "arm,armv8";
+			reg = <0 0x3>;
+			next-level-cache = <&l2_0>;
+		};
+
+		l2_0: l2-cache0 {
+			compatible = "cache";
+		};
+
+		/* CLUSTER 1 */
+		cpu4: cpu@100 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a72", "arm,armv8";
+			reg = <0 0x100>;
+			next-level-cache = <&l2_1>;
+		};
+
+		cpu5: cpu@101 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a72", "arm,armv8";
+			reg = <0 0x101>;
+			next-level-cache = <&l2_1>;
+		};
+
+		cpu6: cpu@102 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a72", "arm,armv8";
+			reg = <0 0x102>;
+			next-level-cache = <&l2_1>;
+		};
+
+		cpu7: cpu@103 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a72", "arm,armv8";
+			reg = <0 0x103>;
+			next-level-cache = <&l2_1>;
+		};
+
+		l2_1: l2-cache1 {
+			compatible = "cache";
+		};
+
+		/* CLUSTER 2 */
+		cpu8: cpu@200 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a72", "arm,armv8";
+			reg = <0 0x200>;
+			next-level-cache = <&l2_2>;
+		};
+
+		cpu9: cpu@201 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a72", "arm,armv8";
+			reg = <0 0x201>;
+			next-level-cache = <&l2_2>;
+		};
+
+		cpu10: cpu@202 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a72", "arm,armv8";
+			reg = <0 0x202>;
+			next-level-cache = <&l2_2>;
+		};
+
+		cpu11: cpu@203 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a72", "arm,armv8";
+			reg = <0 0x203>;
+			next-level-cache = <&l2_2>;
+		};
+
+		l2_2: l2-cache2 {
+			compatible = "cache";
+		};
+
+		/* CLUSTER 3 */
+		cpu12: cpu@300 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a72", "arm,armv8";
+			reg = <0 0x300>;
+			next-level-cache = <&l2_3>;
+		};
+
+		cpu13: cpu@301 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a72", "arm,armv8";
+			reg = <0 0x301>;
+			next-level-cache = <&l2_3>;
+		};
+
+		cpu14: cpu@302 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a72", "arm,armv8";
+			reg = <0 0x302>;
+			next-level-cache = <&l2_3>;
+		};
+
+		cpu15: cpu@303 {
+			device_type = "cpu";
+			compatible = "arm,cortex-a72", "arm,armv8";
+			reg = <0 0x303>;
+			next-level-cache = <&l2_3>;
+		};
+
+		l2_3: l2-cache3 {
+			compatible = "cache";
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/pensando/elba-asic-common.dtsi b/arch/arm64/boot/dts/pensando/elba-asic-common.dtsi
new file mode 100644
index 00000000..d8ab370
--- /dev/null
+++ b/arch/arm64/boot/dts/pensando/elba-asic-common.dtsi
@@ -0,0 +1,114 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <dt-bindings/reset/amd,pensando-elba-reset.h>
+
+&ahb_clk {
+	clock-frequency = <400000000>;
+};
+
+&emmc_clk {
+	clock-frequency = <200000000>;
+};
+
+&flash_clk {
+	clock-frequency = <400000000>;
+};
+
+&ref_clk {
+	clock-frequency = <156250000>;
+};
+
+&qspi {
+	status = "okay";
+	flash0: flash@0 {
+		compatible = "jedec,spi-nor";
+		reg = <0>;
+		spi-max-frequency = <40000000>;
+		spi-rx-bus-width = <2>;
+		m25p,fast-read;
+		cdns,read-delay = <0>;
+		cdns,tshsl-ns = <0>;
+		cdns,tsd2d-ns = <0>;
+		cdns,tchsh-ns = <0>;
+		cdns,tslch-ns = <0>;
+	};
+};
+
+&gpio0 {
+	status = "ok";
+};
+
+&emmc {
+	bus-width = <8>;
+	cap-mmc-hw-reset;
+	reset-names = "hw";
+	resets = <&rstc EMMC_HW_RESET>;
+	status = "ok";
+};
+
+&edac {
+	status = "okay";
+};
+
+&wdt0 {
+	status = "okay";
+};
+
+&i2c0 {
+	clock-frequency = <100000>;
+	status = "okay";
+	temp-sensor@4c {
+		compatible = "ti,tmp451";
+		reg = <0x4c>;
+	};
+
+	rtc@51 {
+		compatible = "nxp,pcf85263";
+		reg = <0x51>;
+	};
+
+	regulator@62 {
+		compatible = "ti,tps53659";
+		reg = <0x62>;
+	};
+};
+
+&spi0 {
+	num-cs = <4>;
+	cs-gpios = <0>, <0>,
+		<&porta 1 GPIO_ACTIVE_LOW>, <&porta 7 GPIO_ACTIVE_LOW>;
+	status = "okay";
+	spi@0 {
+		compatible = "amd,pensando-elbasr", "simple-mfd";
+		reg = <0>;
+		#address-cells = <1>;
+		#size-cells = <0>;
+		spi-max-frequency = <12000000>;
+
+		rstc: reset-controller@0 {
+			compatible = "amd,pensando-elbasr-reset";
+			reg = <0>;
+			#reset-cells = <1>;
+		};
+	};
+
+	spi@1 {
+		compatible = "amd,pensando-elbasr", "simple-mfd";
+		reg = <1>;
+		spi-max-frequency = <12000000>;
+	};
+
+	spi@2 {
+		compatible = "pensando,cpld-rd1173";
+		reg = <2>;
+		spi-max-frequency = <12000000>;
+		interrupt-parent = <&porta>;
+		interrupts = <0 IRQ_TYPE_LEVEL_LOW>;
+	};
+
+	spi@3 {
+		compatible = "amd,pensando-elbasr", "simple-mfd";
+		reg = <3>;
+		spi-max-frequency = <12000000>;
+	};
+};
diff --git a/arch/arm64/boot/dts/pensando/elba-asic-memory.dtsi b/arch/arm64/boot/dts/pensando/elba-asic-memory.dtsi
new file mode 100644
index 00000000..6652b42
--- /dev/null
+++ b/arch/arm64/boot/dts/pensando/elba-asic-memory.dtsi
@@ -0,0 +1,16 @@
+
+/ {
+	reserved-memory {
+		#address-cells = <2>;
+		#size-cells = <2>;
+
+		ranges;
+
+		mnet_reserved: mnet_dma_region {
+			compatible = "shared-dma-pool";
+			no-map;
+			size = <0x0 0x6000000>;
+			alignment = <0x0 0x1000>;
+		};
+	};
+};
diff --git a/arch/arm64/boot/dts/pensando/elba-asic-psci.dts b/arch/arm64/boot/dts/pensando/elba-asic-psci.dts
new file mode 100644
index 00000000..dfa6dea
--- /dev/null
+++ b/arch/arm64/boot/dts/pensando/elba-asic-psci.dts
@@ -0,0 +1,26 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/dts-v1/;
+
+/ {
+	model = "Elba ASIC Board";
+	compatible = "pensando,elba";
+
+	aliases {
+		serial0 = &uart0;
+		spi0 = &spi0;
+		spi1 = &qspi;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+};
+
+#include "elba.dtsi"
+#include "elba-16core.dtsi"
+#include "elba-16core-psci.dtsi"
+#include "elba-asic-common.dtsi"
+#include "elba-flash-parts.dtsi"
+#include "elba-asic-memory.dtsi"
+#include "elba-mdev.dtsi"
diff --git a/arch/arm64/boot/dts/pensando/elba-asic.dts b/arch/arm64/boot/dts/pensando/elba-asic.dts
new file mode 100644
index 00000000..70d0dbd
--- /dev/null
+++ b/arch/arm64/boot/dts/pensando/elba-asic.dts
@@ -0,0 +1,26 @@
+// SPDX-License-Identifier: GPL-2.0
+
+/dts-v1/;
+
+/ {
+	model = "Elba ASIC Board";
+	compatible = "pensando,elba";
+
+	aliases {
+		serial0 = &uart0;
+		spi0 = &spi0;
+		spi1 = &qspi;
+	};
+
+	chosen {
+		stdout-path = "serial0:115200n8";
+	};
+};
+
+#include "elba.dtsi"
+#include "elba-16core.dtsi"
+#include "elba-16core-spin-table.dtsi"
+#include "elba-asic-common.dtsi"
+#include "elba-flash-parts.dtsi"
+#include "elba-asic-memory.dtsi"
+#include "elba-mdev.dtsi"
diff --git a/arch/arm64/boot/dts/pensando/elba-flash-parts.dtsi b/arch/arm64/boot/dts/pensando/elba-flash-parts.dtsi
new file mode 100644
index 00000000..4ce9340
--- /dev/null
+++ b/arch/arm64/boot/dts/pensando/elba-flash-parts.dtsi
@@ -0,0 +1,115 @@
+// SPDX-License-Identifier: GPL-2.0
+
+&flash0 {
+	partitions {
+		compatible = "fixed-partitions";
+		#address-cells = <1>;
+		#size-cells = <1>;
+		partition@0 {
+			label = "flash";
+			reg = <0x10000 0xfff0000>;
+		};
+
+		partition@f0000 {
+			label = "golduenv";
+			reg = <0xf0000 0x10000>;
+		};
+
+		partition@100000 {
+			label = "boot0";
+			reg = <0x100000 0x80000>;
+		};
+
+		partition@180000 {
+			label = "golduboot";
+			reg = <0x180000 0x200000>;
+		};
+
+		partition@380000 {
+			label = "brdcfg0";
+			reg = <0x380000 0x10000>;
+		};
+
+		partition@390000 {
+			label = "brdcfg1";
+			reg = <0x390000 0x10000>;
+		};
+
+		partition@400000 {
+			label = "goldfw";
+			reg = <0x400000 0x3c00000>;
+		};
+
+		partition@4010000 {
+			label = "fwmap";
+			reg = <0x4010000 0x20000>;
+		};
+
+		partition@4030000 {
+			label = "fwsel";
+			reg = <0x4030000 0x20000>;
+		};
+
+		partition@4090000 {
+			label = "bootlog";
+			reg = <0x4090000 0x20000>;
+		};
+
+		partition@40b0000 {
+			label = "panicbuf";
+			reg = <0x40b0000 0x20000>;
+		};
+
+		partition@40d0000 {
+			label = "uservars";
+			reg = <0x40d0000 0x20000>;
+		};
+
+		partition@4200000 {
+			label = "uboota";
+			reg = <0x4200000 0x400000>;
+		};
+
+		partition@4600000 {
+			label = "ubootb";
+			reg = <0x4600000 0x400000>;
+		};
+
+		partition@4a00000 {
+			label = "mainfwa";
+			reg = <0x4a00000 0x1000000>;
+		};
+
+		partition@5a00000 {
+			label = "mainfwb";
+			reg = <0x5a00000 0x1000000>;
+		};
+
+		partition@6a00000 {
+			label = "diaguboot";
+			reg = <0x6a00000 0x400000>;
+		};
+
+		partition@6e00000 {
+			label = "flashobfl";
+			reg = <0x6e00000 0x1200000>;
+		};
+
+		partition@8000000 {
+			label = "diagfw";
+			reg = <0x8000000 0x7fe0000>;
+		};
+
+		partition@ffe0000 {
+			label = "ubootenv";
+			reg = <0xffe0000 0x10000>;
+		};
+	};
+};
+
+&soc {
+	panicdump@740b0000 {
+		compatible = "pensando,capri-crash";
+		reg = <0x0 0x740b0000 0x0 0x20000>;
+	};
+};
diff --git a/arch/arm64/boot/dts/pensando/elba-mdev.dtsi b/arch/arm64/boot/dts/pensando/elba-mdev.dtsi
new file mode 100644
index 00000000..a728a76
--- /dev/null
+++ b/arch/arm64/boot/dts/pensando/elba-mdev.dtsi
@@ -0,0 +1,71 @@
+/ {
+	dma-coherent;
+
+	mnet0: mnet0 {
+		compatible = "pensando,mnet";
+		msi-parent = <&its 0x0>;
+		memory-region = <&mnet_reserved>;
+	};
+	mnet1: mnet1 {
+		compatible = "pensando,mnet";
+		msi-parent = <&its 0x1>;
+		memory-region = <&mnet_reserved>;
+	};
+	mnet2: mnet2 {
+		compatible = "pensando,mnet";
+		msi-parent = <&its 0x2>;
+		memory-region = <&mnet_reserved>;
+	};
+	mnet3: mnet3 {
+		compatible = "pensando,mnet";
+		msi-parent = <&its 0x3>;
+		memory-region = <&mnet_reserved>;
+	};
+	mnet4: mnet4 {
+		compatible = "pensando,mnet";
+		msi-parent = <&its 0x4>;
+		memory-region = <&mnet_reserved>;
+	};
+	mnet5: mnet5 {
+		compatible = "pensando,mnet";
+		msi-parent = <&its 0x5>;
+		memory-region = <&mnet_reserved>;
+	};
+	mnet6: mnet6 {
+		compatible = "pensando,mnet";
+		msi-parent = <&its 0x6>;
+		memory-region = <&mnet_reserved>;
+	};
+	mnet7: mnet7 {
+		compatible = "pensando,mnet";
+		msi-parent = <&its 0x7>;
+		memory-region = <&mnet_reserved>;
+	};
+	mnet8: mnet8 {
+		compatible = "pensando,mnet";
+		msi-parent = <&its 0x8>;
+		memory-region = <&mnet_reserved>;
+	};
+	mnet9: mnet9 {
+		compatible = "pensando,mnet";
+		msi-parent = <&its 0x9>;
+		memory-region = <&mnet_reserved>;
+	};
+
+	mcrypt0: mcrypt0 {
+		compatible = "pensando,mcrypt";
+		msi-parent = <&its 0xb>;
+	};
+	mcrypt1: mcrypt1 {
+		compatible = "pensando,mcrypt";
+		msi-parent = <&its 0xc>;
+	};
+	mcrypt2: mcrypt2 {
+		compatible = "pensando,mcrypt";
+		msi-parent = <&its 0xd>;
+	};
+	mcrypt3: mcrypt3 {
+		compatible = "pensando,mcrypt";
+		msi-parent = <&its 0xe>;
+	};
+};
diff --git a/arch/arm64/boot/dts/pensando/elba.dtsi b/arch/arm64/boot/dts/pensando/elba.dtsi
new file mode 100644
index 00000000..2bf4208
--- /dev/null
+++ b/arch/arm64/boot/dts/pensando/elba.dtsi
@@ -0,0 +1,354 @@
+// SPDX-License-Identifier: GPL-2.0
+/* Copyright (c) 2019-2021, Pensando Systems Inc. */
+
+#include <dt-bindings/gpio/gpio.h>
+#include "dt-bindings/interrupt-controller/arm-gic.h"
+
+/ {
+	interrupt-parent = <&gic>;
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	dma-coherent;
+
+	ahb_clk: oscillator0 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+	};
+
+	emmc_clk: oscillator2 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+	};
+
+	flash_clk: oscillator3 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+	};
+
+	ref_clk: oscillator4 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+	};
+
+	gmac_clk: oscillator5 {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+	};
+
+	timer {
+		compatible = "arm,armv8-timer";
+		interrupts = <GIC_PPI 13 (GIC_CPU_MASK_SIMPLE(1) |
+					IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 14 (GIC_CPU_MASK_SIMPLE(1) |
+					IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 11 (GIC_CPU_MASK_SIMPLE(1) |
+					IRQ_TYPE_LEVEL_LOW)>,
+			     <GIC_PPI 10 (GIC_CPU_MASK_SIMPLE(1) |
+					IRQ_TYPE_LEVEL_LOW)>;
+	};
+
+	pmu {
+		compatible = "arm,cortex-a72-pmu";
+		interrupts = <GIC_PPI 7 (GIC_CPU_MASK_SIMPLE(1) |
+				IRQ_TYPE_LEVEL_LOW)>;
+	};
+
+	/* Common UIO device for MSI drivers */
+	uio_penmsi {
+		compatible = "pensando,uio_penmsi";
+		name = "uio_penmsi";
+	};
+
+	rstcause {
+		compatible = "pensando,rstcause";
+		pensando,causeregs = <&mssoc 0x2084>;
+	};
+
+	capmem {
+		compatible = "pensando,capmem";
+	};
+
+	soc: soc {
+		compatible = "simple-bus";
+		#address-cells = <2>;
+		#size-cells = <2>;
+		ranges;
+
+		i2c0: i2c@400 {
+			compatible = "snps,designware-i2c";
+			reg = <0x0 0x400 0x0 0x100>;
+			clocks = <&ahb_clk>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			i2c-sda-hold-time-ns = <480>;
+			snps,sda-timeout-ms = <750>;
+			interrupts = <GIC_SPI 4 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		wdt0: watchdog@1400 {
+			compatible = "snps,dw-wdt";
+			reg = <0x0 0x1400 0x0 0x100>;
+			clocks = <&ahb_clk>;
+			interrupts = <GIC_SPI 10 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		wdt1: watchdog@1800 {
+			compatible = "snps,dw-wdt";
+			reg = <0x0 0x1800 0x0 0x100>;
+			clocks = <&ahb_clk>;
+			interrupts = <GIC_SPI 11 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		wdt2: watchdog@1c00 {
+			compatible = "snps,dw-wdt";
+			reg = <0x0 0x1c00 0x0 0x100>;
+			clocks = <&ahb_clk>;
+			interrupts = <GIC_SPI 12 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		wdt3: watchdog@2000 {
+			compatible = "snps,dw-wdt";
+			reg = <0x0 0x2000 0x0 0x100>;
+			clocks = <&ahb_clk>;
+			interrupts = <GIC_SPI 13 IRQ_TYPE_LEVEL_HIGH>;
+			status = "disabled";
+		};
+
+		qspi: spi@2400 {
+			compatible = "pensando,elba-qspi";
+			#address-cells = <1>;
+			#size-cells = <0>;
+			reg = <0x0 0x2400 0x0 0x400>,
+			      <0x0 0x7fff0000 0x0 0x1000>;
+			interrupts = <GIC_SPI 0 IRQ_TYPE_LEVEL_HIGH>;
+			clocks = <&flash_clk>;
+			cdns,fifo-depth = <1024>;
+			cdns,fifo-width = <4>;
+			cdns,trigger-address = <0x7fff0000>;
+			status = "disabled";
+		};
+
+		spi0: spi@2800 {
+			compatible = "pensando,elba-spi";
+			reg = <0x0 0x2800 0x0 0x100>;
+			pensando,spics = <&mssoc 0x2468 0>;
+			clocks = <&ahb_clk>;
+			interrupts = <GIC_SPI 9 IRQ_TYPE_LEVEL_HIGH>;
+			#address-cells = <1>;
+			#size-cells = <0>;
+			num-cs = <2>;
+			status = "disabled";
+		};
+
+		gpio0: gpio@4000 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "snps,dw-apb-gpio";
+			reg = <0x0 0x4000 0x0 0x78>;
+			status = "disabled";
+
+			porta: gpio-port@0 {
+				compatible = "snps,dw-apb-gpio-port";
+				reg = <0>;
+				gpio-controller;
+				#gpio-cells = <2>;
+				ngpios = <8>;
+				interrupts = <GIC_SPI 1 IRQ_TYPE_LEVEL_HIGH>;
+				interrupt-controller;
+				interrupt-parent = <&gic>;
+				#interrupt-cells = <2>;
+			};
+
+			portb: gpio-port@1 {
+				compatible = "snps,dw-apb-gpio-port";
+				reg = <1>;
+				gpio-controller;
+				#gpio-cells = <2>;
+				ngpios = <8>;
+			};
+		};
+
+		uart0: serial@4800 {
+			compatible = "ns16550a";
+			reg = <0x0 0x4800 0x0 0x100>;
+			clocks = <&ref_clk>;
+			interrupts = <GIC_SPI 2 IRQ_TYPE_LEVEL_HIGH>;
+			reg-shift = <2>;
+			reg-io-width = <4>;
+		};
+
+		/* MSI UIO device 1 */
+		uio_penmsi1@520000 {
+			compatible = "pensando,uio_penmsi1";
+			reg = <0x0 0x520000 0x0 0x10000>;
+			msi-parent = <&its 0xa>;
+			num-interrupts = <16>;  /* # MSI interrupts to get */
+		};
+
+		gic: interrupt-controller@800000 {
+			compatible = "arm,gic-v3";
+			#interrupt-cells = <3>;
+			#address-cells = <2>;
+			#size-cells = <2>;
+			ranges;
+			interrupt-controller;
+			reg = <0x0 0x800000 0x0 0x200000>,	/* GICD */
+			      <0x0 0xa00000 0x0 0x200000>;	/* GICR */
+			interrupts = <GIC_PPI 9 IRQ_TYPE_LEVEL_HIGH>;
+
+			its: interrupt-controller@820000 {
+				compatible = "arm,gic-v3-its";
+				msi-controller;
+				#msi-cells = <1>;
+				reg = <0x0 0x820000 0x0 0x10000>;
+				socionext,synquacer-pre-its =
+							<0xc00000 0x1000000>;
+			};
+		};
+
+		/*
+		 * Until we  know the interrupt domain following this, we
+		 * are forced to use this is the place where interrupts from
+		 * PCI converge. In the ideal case, we use one domain higher,
+		 * where the PCI-ness has been shed.
+		 */
+		pxc0_intr: interrupt-controller@20102200 {
+			compatible = "pensando,soc-ictlr-csrintr";
+			interrupt-controller;
+			reg = <0x0 0x20102200 0x0 0x4>;
+			#interrupt-cells = <3>;
+			interrupt-parent = <&gic>;
+			interrupts = <GIC_SPI 17 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "pxc0_intr";
+		};
+
+		/* UIO device using interrupt line PCIEMAC */
+		pciemac@20102200 {
+			#address-cells = <2>;
+			#size-cells = <2>;
+			#interrupt-cells = <3>;
+
+			compatible = "pensando,uio_pciemac";
+			register-type = "csr-interrupt";
+			interrupt-parent = <&pxc0_intr>;
+			interrupts = <GIC_SPI 0 IRQ_TYPE_LEVEL_HIGH>;
+			reg = <0x0 0x20102200 0x0 0x10>; /* pxc0_intr */
+
+			enable_csr_paddr = <0x0 0x20102200 0x0 0x10>;
+			enable_mask = <(1 << 0)>;
+		};
+
+		edac: edac@30500000 {
+			compatible = "pensando,elba-edac-mc";
+			reg = <0x0 0x30500000 0x0 0x100000>;
+			status = "disabled"; /* not available on HAPS */
+		};
+
+		stmmac_axi_setup: stmmac-axi-config {
+			snps,wr_osr_lmt = <0xf>;
+			snps,rd_osr_lmt = <0xf>;
+			snps,blen = <256 128 64 32 0 0 0>;
+		};
+
+		gmac0: ethernet@6f21a000 {
+			compatible = "snps,dwmac-3.70a", "snps,dwmac";
+			reg = <0x0 0x6f21a000 0x0 0x8000>;
+			clocks = <&gmac_clk>;
+			clock-names = "stmmaceth";
+			interrupts = <GIC_SPI 29 IRQ_TYPE_LEVEL_HIGH>;
+			interrupt-names = "macirq";
+			mac-address = [00 00 00 00 00 00];/* Filled in by U-Boot */
+			max-frame-size = <3800>;
+			snps,multicast-filter-bins = <256>;
+			snps,perfect-filter-entries = <128>;
+			rx-fifo-depth = <16384>;
+			tx-fifo-depth = <16384>;
+			snps,axi-config = <&stmmac_axi_setup>;
+			snps,pbl = <2>;
+			fixed-link {
+				speed = <100>;
+				full-duplex;
+			};
+		};
+
+		emmc: mmc@30440000 {
+			compatible = "pensando,elba-emmc", "cdns,sd4hc";
+			clocks = <&emmc_clk>;
+			interrupts = <GIC_SPI 26 IRQ_TYPE_LEVEL_HIGH>;
+			reg = <0x0 0x30440000 0x0 0x10000
+			       0x0 0x30480044 0x0 0x4>;
+			cdns,phy-input-delay-sd-highspeed = <0x4>;
+			cdns,phy-input-delay-legacy = <0x4>;
+			cdns,phy-input-delay-sd-uhs-sdr50 = <0x6>;
+			cdns,phy-input-delay-sd-uhs-ddr50 = <0x16>;
+			cdns,phy-dll-delay-sdclk = <0>;
+			cdns,phy-dll-delay-sdclk-hsmmc = <0>;
+			cdns,mmc-ddr-1_8v;
+			status = "disabled";
+		};
+
+		mssoc: mssoc@307c0000 {
+			compatible = "pensando,mssoc", "syscon";
+			reg = <0x0 0x307c0000 0x0 0x3000>;
+		};
+
+		bsm@307c2080 {
+			compatible = "pensando,bsm";
+			reg = <0x0 0x307c2080 0x0 0x4>;
+		};
+
+		pcie@307c2480 {
+			compatible = "pensando,pcie";
+			reg = <0x0 0x307c2480 0x0 0x4		/* MS CFG_WDT */
+			       0x0 0x1400 0x0 0x10		/* WDT0 */
+			       0x0 0x20000000 0x0 0x380000>;	/* PXB Base */
+		};
+
+		kpcimgr@20000000 {
+			compatible = "pensando,kpcimgr";
+			msi-parent = <&its 0xf>;
+			shmem-index = <3>;
+			hwmem-index = <2>;
+			reg =  <0x0 0x20000000 0x0 0x00380000   /* PXB Base */
+				0x0 0x61800000 0x0 0x00101000   /* Interrupts */
+				0x0 0xc4000000 0x0 0x01000000   /* HWMEM */
+				0x0 0x0        0x0 0x00F00000>; /* SHMEM */
+		};
+
+		/*
+		 * panic: panicdump@0 {
+		 *	compatible = "pensando,capri-crash";
+		 *	status = "disabled";
+		 * };
+		 */
+
+		sbus@307c24a8 {
+			compatible = "pensando,sbus";
+			sbus-ring-num = <0>;
+			reg = <0x0 0x307c24a8 0x0 0x8>;		/* SBUS0 REG */
+		};
+
+		sbus@307c24b8 {
+			compatible = "pensando,sbus";
+			sbus-ring-num = <1>;
+			reg = <0x0 0x307c24b8 0x0 0x8>;		/* SBUS1 REG */
+		};
+
+		sbus@307c24c8 {
+			compatible = "pensando,sbus";
+			sbus-ring-num = <2>;
+			reg = <0x0 0x307c24c8 0x0 0x8>;		/* SBUS2 REG */
+		};
+
+		sbus@6f242134 {
+			compatible = "pensando,sbus";
+			sbus-ring-num = <3>;
+			reg = <0x0 0x6f242134 0x0 0x8>;		/* SBUS3 REG */
+		};
+	};
+};
diff --git a/arch/arm64/configs/elba_defconfig b/arch/arm64/configs/elba_defconfig
new file mode 100644
index 00000000..cff0633
--- /dev/null
+++ b/arch/arm64/configs/elba_defconfig
@@ -0,0 +1,300 @@
+CONFIG_DEFAULT_HOSTNAME="elba"
+# CONFIG_SWAP is not set
+CONFIG_SYSVIPC=y
+CONFIG_POSIX_MQUEUE=y
+CONFIG_AUDIT=y
+CONFIG_GENERIC_IRQ_DEBUGFS=y
+CONFIG_NO_HZ_FULL=y
+CONFIG_HIGH_RES_TIMERS=y
+CONFIG_PREEMPT_VOLUNTARY=y
+CONFIG_LOG_BUF_SHIFT=14
+CONFIG_MEMCG=y
+CONFIG_BLK_CGROUP=y
+CONFIG_CGROUP_PIDS=y
+CONFIG_CGROUP_HUGETLB=y
+CONFIG_CPUSETS=y
+CONFIG_CGROUP_DEVICE=y
+CONFIG_CGROUP_CPUACCT=y
+CONFIG_CGROUP_PERF=y
+CONFIG_NAMESPACES=y
+CONFIG_USER_NS=y
+CONFIG_SCHED_AUTOGROUP=y
+CONFIG_KALLSYMS_ALL=y
+CONFIG_BPF_SYSCALL=y
+CONFIG_EMBEDDED=y
+# CONFIG_COMPAT_BRK is not set
+CONFIG_PROFILING=y
+CONFIG_ARCH_PENSANDO=y
+# CONFIG_ARM64_ERRATUM_826319 is not set
+# CONFIG_ARM64_ERRATUM_827319 is not set
+# CONFIG_ARM64_ERRATUM_824069 is not set
+# CONFIG_ARM64_ERRATUM_819472 is not set
+# CONFIG_ARM64_ERRATUM_832075 is not set
+# CONFIG_ARM64_ERRATUM_845719 is not set
+# CONFIG_ARM64_ERRATUM_843419 is not set
+# CONFIG_ARM64_ERRATUM_1024718 is not set
+# CONFIG_ARM64_ERRATUM_1418040 is not set
+# CONFIG_ARM64_ERRATUM_1165522 is not set
+# CONFIG_ARM64_ERRATUM_1530923 is not set
+# CONFIG_ARM64_ERRATUM_1286807 is not set
+# CONFIG_ARM64_ERRATUM_1463225 is not set
+# CONFIG_ARM64_ERRATUM_1542419 is not set
+# CONFIG_ARM64_ERRATUM_1508412 is not set
+# CONFIG_CAVIUM_ERRATUM_22375 is not set
+# CONFIG_CAVIUM_ERRATUM_23154 is not set
+# CONFIG_CAVIUM_ERRATUM_27456 is not set
+# CONFIG_CAVIUM_ERRATUM_30115 is not set
+# CONFIG_CAVIUM_TX2_ERRATUM_219 is not set
+# CONFIG_FUJITSU_ERRATUM_010001 is not set
+# CONFIG_HISILICON_ERRATUM_161600802 is not set
+# CONFIG_QCOM_FALKOR_ERRATUM_1003 is not set
+# CONFIG_QCOM_FALKOR_ERRATUM_1009 is not set
+# CONFIG_QCOM_QDF2400_ERRATUM_0065 is not set
+# CONFIG_QCOM_FALKOR_ERRATUM_E1041 is not set
+CONFIG_SCHED_MC=y
+CONFIG_HOTPLUG_CPU=y
+CONFIG_CRASH_DUMP=y
+CONFIG_COMPAT=y
+# CONFIG_ARM64_HW_AFDBM is not set
+# CONFIG_ARM64_PAN is not set
+# CONFIG_ARM64_USE_LSE_ATOMICS is not set
+# CONFIG_ARM64_VHE is not set
+# CONFIG_ARM64_UAO is not set
+# CONFIG_ARM64_RAS_EXTN is not set
+# CONFIG_ARM64_CNP is not set
+# CONFIG_ARM64_AMU_EXTN is not set
+# CONFIG_ARM64_BTI is not set
+# CONFIG_ARM64_E0PD is not set
+# CONFIG_ARCH_RANDOM is not set
+# CONFIG_ARM64_SVE is not set
+CONFIG_RANDOMIZE_BASE=y
+# CONFIG_EFI is not set
+# CONFIG_SUSPEND is not set
+CONFIG_CPU_IDLE=y
+CONFIG_ARM64_CRYPTO=y
+CONFIG_CRYPTO_SHA512_ARM64=y
+CONFIG_CRYPTO_SHA1_ARM64_CE=y
+CONFIG_CRYPTO_SHA2_ARM64_CE=y
+CONFIG_CRYPTO_GHASH_ARM64_CE=y
+CONFIG_CRYPTO_AES_ARM64_CE_CCM=y
+CONFIG_CRYPTO_AES_ARM64_CE_BLK=y
+CONFIG_CRYPTO_CHACHA20_NEON=y
+CONFIG_CRYPTO_AES_ARM64_BS=y
+CONFIG_JUMP_LABEL=y
+CONFIG_MODULES=y
+CONFIG_MODULE_UNLOAD=y
+CONFIG_BLK_DEV_BSGLIB=y
+CONFIG_BLK_DEV_INTEGRITY=y
+# CONFIG_BOUNCE is not set
+CONFIG_KSM=y
+CONFIG_NET=y
+CONFIG_PACKET=y
+CONFIG_UNIX=y
+CONFIG_XFRM_USER=y
+CONFIG_NET_KEY=y
+CONFIG_INET=y
+CONFIG_IP_MULTICAST=y
+CONFIG_IP_ADVANCED_ROUTER=y
+CONFIG_IP_MULTIPLE_TABLES=y
+CONFIG_IP_ROUTE_MULTIPATH=y
+CONFIG_IP_PNP=y
+CONFIG_IP_PNP_DHCP=y
+CONFIG_IP_PNP_BOOTP=y
+CONFIG_SYN_COOKIES=y
+CONFIG_INET_AH=y
+CONFIG_INET_ESP=y
+CONFIG_INET_IPCOMP=y
+CONFIG_TCP_MD5SIG=y
+CONFIG_NETFILTER=y
+CONFIG_NETFILTER_XT_TARGET_DSCP=y
+CONFIG_NETFILTER_XT_MATCH_DSCP=y
+CONFIG_NETFILTER_XT_MATCH_POLICY=y
+CONFIG_NETFILTER_XT_MATCH_PKTTYPE=y
+CONFIG_IP_NF_IPTABLES=y
+CONFIG_IP_NF_MATCH_AH=y
+CONFIG_IP_NF_MATCH_ECN=y
+CONFIG_IP_NF_MATCH_TTL=y
+CONFIG_IP_NF_FILTER=y
+CONFIG_IP_NF_TARGET_REJECT=y
+CONFIG_IP_NF_MANGLE=y
+CONFIG_IP_NF_TARGET_ECN=y
+CONFIG_IP_NF_TARGET_TTL=y
+CONFIG_VLAN_8021Q=y
+CONFIG_BPF_JIT=y
+CONFIG_NET_PKTGEN=y
+# CONFIG_WIRELESS is not set
+CONFIG_PCI=y
+CONFIG_DEVTMPFS=y
+CONFIG_DEVTMPFS_MOUNT=y
+# CONFIG_PREVENT_FIRMWARE_BUILD is not set
+CONFIG_MTD=y
+CONFIG_MTD_SPI_NOR=y
+# CONFIG_MTD_SPI_NOR_USE_4K_SECTORS is not set
+CONFIG_BLK_DEV_LOOP=y
+CONFIG_EEPROM_AT24=y
+CONFIG_EEPROM_AT25=y
+CONFIG_MD=y
+CONFIG_BLK_DEV_DM=y
+CONFIG_DM_VERITY=y
+CONFIG_NETDEVICES=y
+CONFIG_BONDING=y
+CONFIG_TUN=y
+# CONFIG_NET_VENDOR_3COM is not set
+# CONFIG_NET_VENDOR_ADAPTEC is not set
+# CONFIG_NET_VENDOR_AGERE is not set
+# CONFIG_NET_VENDOR_ALACRITECH is not set
+# CONFIG_NET_VENDOR_ALTEON is not set
+# CONFIG_NET_VENDOR_AMAZON is not set
+# CONFIG_NET_VENDOR_AMD is not set
+# CONFIG_NET_VENDOR_AQUANTIA is not set
+# CONFIG_NET_VENDOR_ARC is not set
+# CONFIG_NET_VENDOR_ATHEROS is not set
+# CONFIG_NET_VENDOR_AURORA is not set
+# CONFIG_NET_VENDOR_BROADCOM is not set
+# CONFIG_NET_VENDOR_BROCADE is not set
+# CONFIG_NET_VENDOR_CADENCE is not set
+# CONFIG_NET_VENDOR_CAVIUM is not set
+# CONFIG_NET_VENDOR_CHELSIO is not set
+# CONFIG_NET_VENDOR_CISCO is not set
+# CONFIG_NET_VENDOR_CORTINA is not set
+# CONFIG_NET_VENDOR_DEC is not set
+# CONFIG_NET_VENDOR_DLINK is not set
+# CONFIG_NET_VENDOR_EMULEX is not set
+# CONFIG_NET_VENDOR_EZCHIP is not set
+# CONFIG_NET_VENDOR_GOOGLE is not set
+# CONFIG_NET_VENDOR_HISILICON is not set
+# CONFIG_NET_VENDOR_HUAWEI is not set
+# CONFIG_NET_VENDOR_INTEL is not set
+# CONFIG_NET_VENDOR_MARVELL is not set
+# CONFIG_NET_VENDOR_MELLANOX is not set
+# CONFIG_NET_VENDOR_MICREL is not set
+# CONFIG_NET_VENDOR_MICROCHIP is not set
+# CONFIG_NET_VENDOR_MICROSEMI is not set
+# CONFIG_NET_VENDOR_MYRI is not set
+# CONFIG_NET_VENDOR_NATSEMI is not set
+# CONFIG_NET_VENDOR_NETERION is not set
+# CONFIG_NET_VENDOR_NETRONOME is not set
+# CONFIG_NET_VENDOR_NI is not set
+# CONFIG_NET_VENDOR_NVIDIA is not set
+# CONFIG_NET_VENDOR_OKI is not set
+# CONFIG_NET_VENDOR_PACKET_ENGINES is not set
+# CONFIG_NET_VENDOR_QLOGIC is not set
+# CONFIG_NET_VENDOR_QUALCOMM is not set
+# CONFIG_NET_VENDOR_RDC is not set
+# CONFIG_NET_VENDOR_REALTEK is not set
+# CONFIG_NET_VENDOR_RENESAS is not set
+# CONFIG_NET_VENDOR_ROCKER is not set
+# CONFIG_NET_VENDOR_SAMSUNG is not set
+# CONFIG_NET_VENDOR_SEEQ is not set
+# CONFIG_NET_VENDOR_SOLARFLARE is not set
+# CONFIG_NET_VENDOR_SILAN is not set
+# CONFIG_NET_VENDOR_SIS is not set
+# CONFIG_NET_VENDOR_SMSC is not set
+# CONFIG_NET_VENDOR_SOCIONEXT is not set
+CONFIG_STMMAC_ETH=m
+# CONFIG_NET_VENDOR_SUN is not set
+# CONFIG_NET_VENDOR_SYNOPSYS is not set
+# CONFIG_NET_VENDOR_TEHUTI is not set
+# CONFIG_NET_VENDOR_TI is not set
+# CONFIG_NET_VENDOR_VIA is not set
+# CONFIG_NET_VENDOR_WIZNET is not set
+# CONFIG_NET_VENDOR_XILINX is not set
+CONFIG_MDIO_DEVICE=y
+# CONFIG_WLAN is not set
+# CONFIG_INPUT_KEYBOARD is not set
+# CONFIG_INPUT_MOUSE is not set
+# CONFIG_SERIO is not set
+CONFIG_VT_HW_CONSOLE_BINDING=y
+CONFIG_LEGACY_PTY_COUNT=16
+CONFIG_SERIAL_8250=y
+CONFIG_SERIAL_8250_CONSOLE=y
+# CONFIG_SERIAL_8250_PCI is not set
+CONFIG_SERIAL_OF_PLATFORM=y
+# CONFIG_HW_RANDOM is not set
+# CONFIG_DEVPORT is not set
+CONFIG_I2C=y
+CONFIG_I2C_CHARDEV=y
+CONFIG_I2C_DESIGNWARE_PLATFORM=y
+CONFIG_I2C_RD1173=y
+CONFIG_SPI=y
+CONFIG_SPI_CADENCE_QUADSPI=y
+CONFIG_SPI_DESIGNWARE=y
+CONFIG_SPI_DW_MMIO=y
+CONFIG_SPI_SPIDEV=y
+CONFIG_PTP_1588_CLOCK=y
+CONFIG_GPIOLIB=y
+CONFIG_GPIO_DWAPB=y
+CONFIG_SENSORS_LM90=y
+CONFIG_PMBUS=y
+CONFIG_SENSORS_LTC2978=y
+CONFIG_SENSORS_TPS53679=y
+CONFIG_THERMAL=y
+# CONFIG_THERMAL_OF is not set
+CONFIG_WATCHDOG=y
+CONFIG_SOFT_WATCHDOG=y
+CONFIG_DW_WATCHDOG=y
+CONFIG_MFD_PENSANDO_ELBASR=y
+# CONFIG_VGA_ARB is not set
+# CONFIG_HID is not set
+# CONFIG_USB_SUPPORT is not set
+CONFIG_MMC=y
+CONFIG_MMC_DEBUG=y
+CONFIG_MMC_SDHCI=y
+CONFIG_MMC_SDHCI_PLTFM=y
+CONFIG_MMC_SDHCI_CADENCE=y
+CONFIG_EDAC=y
+CONFIG_EDAC_ELBA=y
+CONFIG_RTC_CLASS=y
+CONFIG_RTC_DRV_PCF85363=y
+CONFIG_SYNC_FILE=y
+CONFIG_UIO=y
+CONFIG_CHROME_PLATFORMS=y
+CONFIG_COMMON_CLK_CS2000_CP=y
+CONFIG_CLK_QORIQ=y
+# CONFIG_FSL_ERRATUM_A008585 is not set
+# CONFIG_HISILICON_ERRATUM_161010101 is not set
+# CONFIG_ARM64_ERRATUM_858921 is not set
+# CONFIG_IOMMU_SUPPORT is not set
+CONFIG_PENSANDO_SOC_CAPMEM_HUGEPAGE=y
+CONFIG_PENSANDO_SOC_BSM_ENABLE=y
+CONFIG_PENSANDO_SOC_PENFW=y
+CONFIG_EXTCON=y
+CONFIG_RESET_ELBASR=y
+CONFIG_GENERIC_PHY=y
+CONFIG_RAS=y
+CONFIG_EXT3_FS=y
+CONFIG_EXT4_FS_POSIX_ACL=y
+CONFIG_FANOTIFY=y
+CONFIG_FANOTIFY_ACCESS_PERMISSIONS=y
+CONFIG_OVERLAY_FS=y
+CONFIG_VFAT_FS=y
+CONFIG_PROC_XMAPS=y
+CONFIG_TMPFS=y
+CONFIG_HUGETLBFS=y
+CONFIG_CONFIGFS_FS=y
+CONFIG_SQUASHFS=y
+CONFIG_SQUASHFS_DECOMP_MULTI=y
+# CONFIG_NETWORK_FILESYSTEMS is not set
+CONFIG_NLS_CODEPAGE_437=y
+CONFIG_NLS_ISO8859_1=y
+CONFIG_KEYS=y
+CONFIG_SECURITY=y
+CONFIG_CRYPTO_LZO=y
+CONFIG_CRYPTO_ANSI_CPRNG=y
+# CONFIG_CRYPTO_HW is not set
+CONFIG_CRC_ITU_T=y
+CONFIG_CRC7=y
+CONFIG_LIBCRC32C=y
+CONFIG_PRINTK_TIME=y
+CONFIG_CONSOLE_LOGLEVEL_DEFAULT=4
+CONFIG_DYNAMIC_DEBUG=y
+CONFIG_DEBUG_INFO=y
+# CONFIG_SCHED_DEBUG is not set
+CONFIG_SCHEDSTATS=y
+# CONFIG_RCU_TRACE is not set
+CONFIG_FUNCTION_TRACER=y
+CONFIG_IRQSOFF_TRACER=y
+CONFIG_SCHED_TRACER=y
+CONFIG_FTRACE_SYSCALLS=y
+CONFIG_BLK_DEV_IO_TRACE=y
+CONFIG_MEMTEST=y
diff --git a/arch/arm64/include/asm/traps.h b/arch/arm64/include/asm/traps.h
index d96dc2c..dc929a6 100644
--- a/arch/arm64/include/asm/traps.h
+++ b/arch/arm64/include/asm/traps.h
@@ -29,6 +29,7 @@ struct undef_hook {
 void arm64_force_sig_fault(int signo, int code, void __user *addr, const char *str);
 void arm64_force_sig_mceerr(int code, void __user *addr, short lsb, const char *str);
 void arm64_force_sig_ptrace_errno_trap(int errno, void __user *addr, const char *str);
+int platform_serror(struct pt_regs *regs, unsigned int esr);
 
 /*
  * Move regs->pc to next instruction and do necessary setup before it
diff --git a/arch/arm64/kernel/traps.c b/arch/arm64/kernel/traps.c
index 2059d8f..d60c306 100644
--- a/arch/arm64/kernel/traps.c
+++ b/arch/arm64/kernel/traps.c
@@ -870,8 +870,16 @@ bool arm64_is_fatal_ras_serror(struct pt_regs *regs, unsigned int esr)
 	}
 }
 
+int __weak platform_serror(struct pt_regs *regs, unsigned int esr)
+{
+	return 0;
+}
+
 asmlinkage void noinstr do_serror(struct pt_regs *regs, unsigned int esr)
 {
+	if (platform_serror(regs, esr))
+		return;
+
 	arm64_enter_nmi(regs);
 
 	/* non-RAS errors are not containable */
diff --git a/drivers/edac/Kconfig b/drivers/edac/Kconfig
index 7a47680..c9363b5 100644
--- a/drivers/edac/Kconfig
+++ b/drivers/edac/Kconfig
@@ -537,4 +537,11 @@ config EDAC_DMC520
 	  Support for error detection and correction on the
 	  SoCs with ARM DMC-520 DRAM controller.
 
+config EDAC_ELBA
+	tristate "Pensando Elba Memory ECC"
+	depends on ARCH_PENSANDO_ELBA_SOC || ARCH_PENSANDO_GIGLIO_SOC
+	help
+	  Support for error detection and correction on the
+	  Pensando Elba SoC.
+
 endif # EDAC
diff --git a/drivers/edac/Makefile b/drivers/edac/Makefile
index 3a84916..47c411b 100644
--- a/drivers/edac/Makefile
+++ b/drivers/edac/Makefile
@@ -89,3 +89,4 @@ obj-$(CONFIG_EDAC_QCOM)			+= qcom_edac.o
 obj-$(CONFIG_EDAC_ASPEED)		+= aspeed_edac.o
 obj-$(CONFIG_EDAC_BLUEFIELD)		+= bluefield_edac.o
 obj-$(CONFIG_EDAC_DMC520)		+= dmc520_edac.o
+obj-$(CONFIG_EDAC_ELBA)			+= elba_edac.o
diff --git a/drivers/edac/elba_edac.c b/drivers/edac/elba_edac.c
new file mode 100644
index 00000000..7afb50d
--- /dev/null
+++ b/drivers/edac/elba_edac.c
@@ -0,0 +1,548 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * AMD Pensando Elba/Giglio Memory Controller EDAC Driver
+ *
+ * Copyright (c) 2022, Advanced Micro Devices Inc.
+ */
+
+#include <linux/edac.h>
+#include <linux/platform_device.h>
+#include <linux/notifier.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include "edac_module.h"
+
+#define ELB_MC_CHAN_STRIDE		0x80000
+#define ELB_MC_SUBCHAN_STRIDE		0x20000
+#define ELB_MC_NCHANS			2
+#define ELB_MC_NSUBCHANS_DDR4		1
+#define ELB_MC_NSUBCHANS_DDR5		2
+
+#define ELB_MC_CONV_MASK_0		0x3010
+#define ELB_MC_CONV_MASK_1		0x3020
+#define ELB_MC_MCTL			0x30000
+
+#define ELB_MCTL_ECC_ADDR(a, s)		((a) | ((u64)((s) & 0x3f) << 32))
+#define ELB_MCTL_ECC_SYND(s)		(((s) >> 8) & 0xff)
+#define ELB_MCTL_ECC_U_ID(n)		((n) & 0x3fff)
+#define ELB_MCTL_ECC_C_ID(n)		(((n) >> 16) & 0x3fff)
+
+#define ELB_MCTL_INT_MULTI_U_ECC	BIT(3)
+#define ELB_MCTL_INT_U_ECC		BIT(2)
+#define ELB_MCTL_INT_MULTI_C_ECC	BIT(1)
+#define ELB_MCTL_INT_C_ECC		BIT(0)
+
+#define ELB_MCTL_INT_ACK_MASK		0xf
+
+struct mc_edac_regs {
+	int ecc_u_addr;
+	int ecc_u_synd;
+	int ecc_c_addr;
+	int ecc_c_synd;
+	int ecc_id;
+	int int_stat_ecc;
+	int int_ack_ecc;
+};
+
+struct ddr_map_func {
+	u64 chan_hash;			// bus addr to ddr channel hash
+	u64 subchan_hash;		// bus addr to ddr subchannel hash
+	u64 conv_mask[2];		// bus addr to ddr addr conversion masks
+};
+
+struct elba_mcdata {
+	void __iomem *base;		// memory controller registers
+	const struct mc_edac_regs *edac_regs;	// EDAC registers
+	struct ddr_map_func llc_map;	// ddr to bus address map for LLC
+	struct ddr_map_func ddrb_map; 	// ddr to bus address map for bypass
+	u64 byp_start;			// bypass region start
+	u64 byp_size;			// bypass region size
+	u32 chanmask;			// channel mask (b01, b10, or b11)
+	int map_valid;			// ddr to bus map is valid
+	int nsubchans;			// number of subchannels
+	int is_ddr5;			// is DDR5
+};
+
+static struct elba_mcdata *g_mcp;
+
+struct elba_mcpoll_res {
+	u64 ddr_addr;			// ecc address reported by the mc
+	u64 bus_addr;			// system bus address (or 0 if no map)
+	u16 cnt;			// ecc count (1=single, 2=multiple)
+	u16 id;				// axi source id info
+	u8 synd;			// ecc syndrome
+	char msg[128];			// informational message
+};
+
+static const struct mc_edac_regs elba_mc_edac_regs = {
+	.ecc_u_addr = 277,
+	.ecc_u_synd = 278,
+	.ecc_c_addr = 281,
+	.ecc_c_synd = 282,
+	.ecc_id = 285,
+	.int_stat_ecc = 377,
+	.int_ack_ecc = 384,
+};
+
+static const struct mc_edac_regs giglio_mc_edac_regs = {
+	.ecc_u_addr = 282,
+	.ecc_u_synd = 283,
+	.ecc_c_addr = 286,
+	.ecc_c_synd = 287,
+	.ecc_id = 290,
+	.int_stat_ecc = 399,
+	.int_ack_ecc = 408,
+};
+
+static inline u32 elba_mc_read(struct elba_mcdata *mcp, int chan, int subchan,
+				int offs)
+{
+	return readl(mcp->base + ELB_MC_CHAN_STRIDE * chan +
+		ELB_MC_SUBCHAN_STRIDE * subchan + offs);
+}
+
+static inline u32 elba_mctl_read(struct elba_mcdata *mcp, int chan, int subchan,
+				int reg)
+{
+	return elba_mc_read(mcp, chan, subchan, ELB_MC_MCTL + 4 * reg);
+}
+
+static inline void elba_mc_write(struct elba_mcdata *mcp,
+		int chan, int subchan, int offs, u32 data)
+{
+	return writel(data, mcp->base + ELB_MC_CHAN_STRIDE * chan +
+		ELB_MC_SUBCHAN_STRIDE * subchan + offs);
+}
+
+static inline void elba_mctl_write(struct elba_mcdata *mcp,
+		int chan, int subchan, int reg, u32 data)
+{
+	elba_mc_write(mcp, chan, subchan, ELB_MC_MCTL + 4 * reg, data);
+}
+
+/*
+ * Expand a DDR reported address back to a system bus address.
+ * In a 2-channel system, each ddr channel takes 1/2 of the bus address
+ * space, so one bit is dropped from the original address.
+ * In a 2-channel, 2-subchannel (4 channels effectively) system, each ddr
+ * channel takes 1/4 of the bus address, so two bits are dropped from the
+ * original bus address.
+ * This function reverses this, and provides two prospecitve addresses;
+ * one with the missing bit clear and the other with the missinog bit set.
+ * The channel-selection hash function will be applied with each address
+ * to determine the correct one.
+ * Only used for multi-channel configurations.
+ */
+static void elba_ddr_addr_expand(u64 addr, u64 *mask, u64 *res)
+{
+	u64 addr_o;
+	addr_o = ((addr & mask[1]) << 2) |
+		 ((addr & mask[0]) << 1) |
+		 (addr & ~(mask[0] | mask[1]));
+	res[0] = addr_o;
+	res[1] = addr_o | ((~(mask[0] | mask[1]) + 1) & 0xfffffffffULL);
+	res[2] = addr_o | (((~(mask[0] | mask[1]) + 1) << 1) & 0xfffffffffULL);
+	res[3] = addr_o | (((~(mask[0] | mask[1]) + 1) << 1) & 0xfffffffffULL)
+			| ((~(mask[0] | mask[1]) + 1) & 0xfffffffffULL);
+}
+
+/*
+ * Hash system address to select a ddr channel.
+ * The hash_func parameter indicates the bits from the address that
+ * should be XORed together to select the target ddr channel.
+ * Only used for 2-channel configurations.
+ */
+static int elba_ddr_hash_func(u64 addr, u64 hash_func)
+{
+	u64 hash_val;
+	int res;
+
+	hash_val = addr & hash_func;
+
+	// reduction XOR
+	res = 0;
+	while (hash_val) {
+		res ^= 1;
+		hash_val &= hash_val - 1;
+	}
+	return res;
+}
+
+/*
+ * Map a ddr reported ecc address back to an original system bus address.
+ * For a 1-channel system, the ddr controller address is the true linear
+ * address.
+ * For a 2-channel system we first determine the two possible linear address
+ * that might map to this channel, then we apply the appropriate hash function
+ * to find the final linear address.
+ * The llc and bypass regions use different hash and convert functions,
+ * so first expand the address using the llc function and then check to see
+ * if the linear address is in the bypass range.  If so, switch to the
+ * bypass conversion function and hash.
+ * Finally, linear addresses outside of 2GB..8GB range must have bit 36 set
+ * to recover the original system bus address.
+ */
+static u64 elba_ddr_addr_to_bus(struct elba_mcdata *mcp, int chan, int subchan,
+				u64 ddr_addr)
+{
+	struct ddr_map_func *map = &mcp->llc_map;
+	u64 bus_addr = (u64)-1;
+	u64 addr_e[4];
+	int i;
+
+	if (!mcp->map_valid)
+		return 0;
+
+	if (mcp->chanmask == 0x3) {
+		elba_ddr_addr_expand(ddr_addr, map->conv_mask, addr_e);
+		if (addr_e[0] >= mcp->byp_start &&
+		    addr_e[0] < (mcp->byp_start + mcp->byp_size)) {
+			map = &mcp->ddrb_map;
+			elba_ddr_addr_expand(ddr_addr, map->conv_mask, addr_e);
+		}
+
+		for (i = 0; i < ELB_MC_NCHANS * mcp->nsubchans; i++) {
+			if ((elba_ddr_hash_func(addr_e[i], map->chan_hash) == chan) &&
+				(elba_ddr_hash_func(addr_e[i], map->subchan_hash) == subchan)) {
+				bus_addr = addr_e[i];
+				break;
+			}
+		}
+	} else {
+		bus_addr = ddr_addr;
+	}
+
+	if (bus_addr < 0x80000000 || bus_addr >= 0x200000000ULL)
+		bus_addr |= 0x1000000000ULL;
+
+	return (bus_addr == (u64)-1) ? 0 : bus_addr;
+}
+
+static int elba_edac_mc_c_poll(struct elba_mcdata *mcp, int chan, int subchan,
+			u32 int_stat, struct elba_mcpoll_res *res)
+{
+	u32 addr, synd, id;
+
+	if (!(int_stat & ELB_MCTL_INT_C_ECC))
+		return 0;
+
+	res->cnt = (int_stat & ELB_MCTL_INT_MULTI_C_ECC) ? 2 : 1;
+	addr = elba_mctl_read(mcp, chan, subchan, mcp->edac_regs->ecc_c_addr);
+	synd = elba_mctl_read(mcp, chan, subchan, mcp->edac_regs->ecc_c_synd);
+	id   = elba_mctl_read(mcp, chan, subchan, mcp->edac_regs->ecc_id);
+	res->ddr_addr = ELB_MCTL_ECC_ADDR(addr, synd);
+	res->bus_addr = elba_ddr_addr_to_bus(mcp, chan, subchan, res->ddr_addr);
+	res->synd = ELB_MCTL_ECC_SYND(synd);
+	res->id   = ELB_MCTL_ECC_C_ID(id);
+	snprintf(res->msg, sizeof(res->msg), "ddr_addr 0x%llx, id 0x%04x",
+			res->ddr_addr, res->id);
+	return 1;
+}
+
+static int elba_edac_mc_u_poll(struct elba_mcdata *mcp, int chan, int subchan,
+			u32 int_stat, struct elba_mcpoll_res *res)
+{
+	u32 addr, synd, id;
+
+	if (!(int_stat & ELB_MCTL_INT_U_ECC))
+		return 0;
+
+	res->cnt = (int_stat & ELB_MCTL_INT_MULTI_U_ECC) ? 2 : 1;
+	addr = elba_mctl_read(mcp, chan, subchan, mcp->edac_regs->ecc_u_addr);
+	synd = elba_mctl_read(mcp, chan, subchan, mcp->edac_regs->ecc_u_synd);
+	id   = elba_mctl_read(mcp, chan, subchan, mcp->edac_regs->ecc_id);
+	res->ddr_addr = ELB_MCTL_ECC_ADDR(addr, synd);
+	res->bus_addr = elba_ddr_addr_to_bus(mcp, chan, subchan, res->ddr_addr);
+	res->synd = ELB_MCTL_ECC_SYND(synd);
+	res->id   = ELB_MCTL_ECC_U_ID(id);
+	snprintf(res->msg, sizeof(res->msg), "ddr_addr 0x%llx, id 0x%04x",
+			res->ddr_addr, res->id);
+	return 1;
+}
+
+static void elba_edac_mc_poll_chan(struct mem_ctl_info *mci, int chan, int subchan)
+{
+	struct elba_mcdata *mcp = mci->pvt_info;
+	struct elba_mcpoll_res res;
+	u32 int_stat, int_ack;
+	int slot = -1;
+
+	if (!(mcp->chanmask & (1 << chan)))
+		return;
+	if (mcp->is_ddr5)
+		slot = subchan;
+
+	int_stat = elba_mctl_read(mcp, chan, subchan, mcp->edac_regs->int_stat_ecc);
+	if (elba_edac_mc_c_poll(mcp, chan, subchan, int_stat, &res)) {
+		edac_mc_handle_error(HW_EVENT_ERR_CORRECTED, mci, res.cnt,
+			res.bus_addr >> PAGE_SHIFT, res.bus_addr & ~PAGE_MASK,
+			res.synd, chan, slot, -1, res.msg, "");
+	}
+
+	if (elba_edac_mc_u_poll(mcp, chan, subchan, int_stat, &res)) {
+		edac_mc_handle_error(HW_EVENT_ERR_UNCORRECTED, mci, res.cnt,
+			res.bus_addr >> PAGE_SHIFT, res.bus_addr & ~PAGE_MASK,
+			res.synd, chan, slot, -1, res.msg, "");
+	}
+
+	int_ack = int_stat & ELB_MCTL_INT_ACK_MASK;
+	if (int_ack)
+		elba_mctl_write(mcp, chan, subchan, mcp->edac_regs->int_ack_ecc, int_ack);
+}
+
+static void elba_edac_mc_poll(struct mem_ctl_info *mci)
+{
+	int chan, subchan;
+	struct elba_mcdata *mcp = mci->pvt_info;
+
+	for (chan = 0; chan < ELB_MC_NCHANS; chan++)
+		for (subchan = 0; subchan < mcp->nsubchans; subchan++)
+			elba_edac_mc_poll_chan(mci, chan, subchan);
+}
+
+/*
+ * A read error (SError) that causes a kernel panic won't have been
+ * polled yet, so one final check for uncorrectable errors on the way down.
+ */
+static int elba_edac_mc_panic_notifier(struct notifier_block *nb,
+				       unsigned long event, void *ptr)
+{
+	struct elba_mcdata *mcp = g_mcp;
+	struct elba_mcpoll_res res;
+	u32 int_stat;
+	int chan, subchan;
+
+	for (chan = 0; chan < ELB_MC_NCHANS; chan++) {
+		if (!(mcp->chanmask & (1 << chan)))
+			continue;
+		for (subchan = 0; subchan < mcp->nsubchans; subchan++) {
+			int_stat = elba_mctl_read(mcp, chan, subchan,
+					mcp->edac_regs->int_stat_ecc);
+			if (elba_edac_mc_u_poll(mcp, chan, subchan, int_stat,
+						&res)) {
+				if (mcp->is_ddr5)
+					printk(KERN_CRIT "EDAC MC0: %u UE %s "
+						"on unknown memory (channel:%u "
+						"slot:%u page:0x%llx "
+						"offset:0x%llx "
+						"grain:8 syndrome:0x%02x)\n",
+						res.cnt, res.msg,
+						chan, subchan,
+						res.bus_addr >> PAGE_SHIFT,
+						res.bus_addr & ~PAGE_MASK,
+						res.synd);
+				else
+					printk(KERN_CRIT "EDAC MC0: %u UE %s "
+						"on unknown memory (channel:%u "
+						"page:0x%llx "
+						"offset:0x%llx "
+						"grain:8 syndrome:0x%02x)\n",
+						res.cnt, res.msg, chan,
+						res.bus_addr >> PAGE_SHIFT,
+						res.bus_addr & ~PAGE_MASK,
+						res.synd);
+			}
+		}
+	}
+	return 0;
+}
+
+static struct notifier_block panic_block = {
+	.notifier_call = elba_edac_mc_panic_notifier
+};
+
+static void elba_mc_conv_mask_read(struct elba_mcdata *mcp,
+		int chan, int offs, u64 *mask)
+{
+	u32 w[3];
+	int i;
+
+	for (i = 0; i < 3; i++)
+		w[i] = elba_mc_read(mcp, chan, 0, offs + 4 * i);
+
+	/* pull the two 36-bit masks from the 3 words */
+	mask[0] = ((u64)(w[2] & 0xff) << 28) | (w[1] >> 4);
+	mask[1] = ((u64)(w[1] & 0xf) << 32) | w[0];
+}
+
+static void elba_init_ddr_map(struct platform_device *pdev,
+		struct elba_mcdata *mcp)
+{
+	struct device_node *np = pdev->dev.of_node;
+	u64 val[2];
+	int r = 0;
+	int chan;
+
+	if (np == NULL)
+		return;
+
+	r += of_property_read_u32(np, "pensando,ddrchanmask", &mcp->chanmask);
+	r += of_property_read_u64(np, "pensando,llchash", &mcp->llc_map.chan_hash);
+	if (mcp->is_ddr5)
+		r += of_property_read_u64(np, "pensando,ddrchash", &mcp->llc_map.subchan_hash);
+
+	chan = (mcp->chanmask & 0x1) ? 0 : 1;
+	elba_mc_conv_mask_read(mcp, chan, ELB_MC_CONV_MASK_1,
+				mcp->llc_map.conv_mask);
+
+	if (of_property_read_variable_u64_array(np,
+				"pensando,bypass", val, 2, 0) == 2) {
+		mcp->byp_start = val[0];
+		mcp->byp_size = val[1];
+		r += of_property_read_u64(np, "pensando,ddrbhash",
+				&mcp->ddrb_map.chan_hash);
+		if (mcp->is_ddr5)
+			r += of_property_read_u64(np, "pensando,ddrbhash0",
+						&mcp->ddrb_map.subchan_hash);
+		elba_mc_conv_mask_read(mcp, chan, ELB_MC_CONV_MASK_0,
+					mcp->ddrb_map.conv_mask);
+	}
+
+	if (r) {
+		dev_warn(&pdev->dev, "ddr map hashes not found\n");
+		return;
+	}
+
+	edac_dbg(0, "llc_map = { 0x%llx, [0x%llx, 0x%llx] }\n",
+		mcp->llc_map.chan_hash,
+		mcp->llc_map.conv_mask[0],
+		mcp->llc_map.conv_mask[1]);
+	edac_dbg(0, "ddrb_map = { 0x%llx, [0x%llx, 0x%llx] }\n",
+		mcp->ddrb_map.chan_hash,
+		mcp->ddrb_map.conv_mask[0],
+		mcp->ddrb_map.conv_mask[1]);
+	edac_dbg(0, "bypass = { 0x%llx, 0x%llx }\n",
+		mcp->byp_start, mcp->byp_size);
+	edac_dbg(0, "ddr_chanmask = 0x%x\n", mcp->chanmask);
+
+	mcp->map_valid = 1;
+}
+
+static void elba_init_dimms(struct mem_ctl_info *mci)
+{
+	struct elba_mcdata *mcp = mci->pvt_info;
+	struct dimm_info *dimm;
+	int chan, subchan, dimmidx;
+
+	for (chan = 0; chan < ELB_MC_NCHANS; chan++) {
+		if (!(mcp->chanmask & (1 << chan)))
+			continue;
+		dimmidx = chan * mcp->nsubchans;
+		for (subchan = 0; subchan < mcp->nsubchans; subchan++) {
+			dimm = mci->dimms[dimmidx + subchan];
+			dimm->grain = 8;
+			dimm->mtype = MEM_DDR4;
+			dimm->dtype = DEV_X8;
+			dimm->edac_mode = EDAC_SECDED;
+			dimm->nr_pages = 1; /* not empty */
+		}
+	}
+}
+
+static int elba_edac_mc_probe(struct platform_device *pdev)
+{
+	struct device_node *np = pdev->dev.of_node;
+	struct edac_mc_layer layers[2];
+	struct mem_ctl_info *mci;
+	struct elba_mcdata *mcp;
+	struct resource *r;
+	void __iomem *base;
+	static int mc_idx;
+	int nlayers = 1;
+	int is_ddr5;
+
+	r = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (!r) {
+		dev_err(&pdev->dev, "Unable to get mem resource\n");
+		return -ENODEV;
+	}
+	base = devm_ioremap_resource(&pdev->dev, r);
+	if (IS_ERR(base)) {
+		dev_err(&pdev->dev, "Unable to map regs\n");
+		return PTR_ERR(base);
+	}
+
+	layers[0].type = EDAC_MC_LAYER_CHANNEL;
+	layers[0].size = ELB_MC_NCHANS;
+	layers[0].is_virt_csrow = false;
+
+	is_ddr5 = of_property_read_bool(np, "pensando,ddr5");
+
+	if (is_ddr5) {
+		layers[1].type = EDAC_MC_LAYER_SLOT;
+		layers[1].size = ELB_MC_NSUBCHANS_DDR5;
+		layers[1].is_virt_csrow = false;
+		nlayers += 1;
+	}
+
+	mci = edac_mc_alloc(mc_idx, nlayers,
+			layers, sizeof(struct elba_mcdata));
+	if (!mci)
+		return -ENXIO;
+
+	mcp = mci->pvt_info;
+	mcp->is_ddr5 = is_ddr5;
+	mcp->nsubchans = is_ddr5 ? ELB_MC_NSUBCHANS_DDR5 :
+				   ELB_MC_NSUBCHANS_DDR4;
+	mcp->base = base;
+	mcp->edac_regs = of_device_get_match_data(&pdev->dev);
+
+	elba_init_ddr_map(pdev, mcp);
+	elba_init_dimms(mci);
+
+	mci->pdev = &pdev->dev;
+	mci->dev_name = dev_name(&pdev->dev);
+
+	mci->mod_name = "elba-mc";
+	mci->ctl_name = "elba-mc-err";
+	mci->edac_check = elba_edac_mc_poll;
+	mci->edac_cap = EDAC_FLAG_SECDED;
+
+	if (edac_mc_add_mc(mci)) {
+		dev_err(&pdev->dev, "edac_mc_add_mc() failed\n");
+		edac_mc_free(mci);
+		return -ENXIO;
+	}
+
+	platform_set_drvdata(pdev, mci);
+
+	/* hook panic() so we can check for uncorrectable errors */
+	g_mcp = mcp;
+	atomic_notifier_chain_register(&panic_notifier_list, &panic_block);
+
+	/* set polling mode */
+	opstate_init();
+
+	return 0;
+}
+
+static int elba_edac_mc_remove(struct platform_device *pdev)
+{
+	struct mem_ctl_info *mci = platform_get_drvdata(pdev);
+
+	edac_mc_del_mc(&pdev->dev);
+	atomic_notifier_chain_unregister(&panic_notifier_list, &panic_block);
+
+	edac_mc_free(mci);
+	return 0;
+}
+
+static const struct of_device_id elba_edac_mc_of_match[] = {
+	{ .compatible = "pensando,elba-edac-mc", .data = &elba_mc_edac_regs },
+	{ .compatible = "pensando,giglio-edac-mc", .data = &giglio_mc_edac_regs },
+	{ },
+};
+
+static struct platform_driver elba_edac_mc_driver = {
+	.probe = elba_edac_mc_probe,
+	.remove = elba_edac_mc_remove,
+	.driver = {
+		.name = "elba_edac_mc",
+		.of_match_table = of_match_ptr(elba_edac_mc_of_match),
+	}
+};
+module_platform_driver(elba_edac_mc_driver);
+
+MODULE_DESCRIPTION("AMD Pensando Elba/Giglio platform EDAC memory controller driver");
+MODULE_AUTHOR("Advanced Micro Devices, Inc.");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/hwmon/pmbus/ltc2978.c b/drivers/hwmon/pmbus/ltc2978.c
index 9a024cf..34129f0 100644
--- a/drivers/hwmon/pmbus/ltc2978.c
+++ b/drivers/hwmon/pmbus/ltc2978.c
@@ -23,7 +23,8 @@ enum chips {
 	/* Managers */
 	ltc2972, ltc2974, ltc2975, ltc2977, ltc2978, ltc2979, ltc2980,
 	/* Controllers */
-	ltc3880, ltc3882, ltc3883, ltc3884, ltc3886, ltc3887, ltc3889, ltc7880,
+	ltc3880, ltc3882, ltc3883, ltc3884, ltc3886, ltc3887, ltc3888, ltc3889,
+	ltc7880,
 	/* Modules */
 	ltm2987, ltm4664, ltm4675, ltm4676, ltm4677, ltm4678, ltm4680, ltm4686,
 	ltm4700,
@@ -53,6 +54,8 @@ enum chips {
 /* LTC3883, LTC3884, LTC3886, LTC3889 and LTC7880 only */
 #define LTC3883_MFR_IIN_PEAK		0xe1
 
+/* LTC3888 only */
+#define LTC3888_MFR_TOTAL_IOUT		0xe1
 
 /* LTC2975 only */
 #define LTC2975_MFR_IIN_PEAK		0xc4
@@ -79,6 +82,8 @@ enum chips {
 #define LTC3884_ID			0x4C00
 #define LTC3886_ID			0x4600
 #define LTC3887_ID			0x4700
+#define LTC3888_ID			0x4800
+#define LTC3888_ID_D1			0x4880	/* Dash 1 */
 #define LTM2987_ID_A			0x8010	/* A/B for two die IDs */
 #define LTM2987_ID_B			0x8020
 #define LTC3889_ID			0x4900
@@ -456,6 +461,26 @@ static int ltc3883_read_word_data(struct i2c_client *client, int page,
 	return ret;
 }
 
+static int ltc3888_read_word_data(struct i2c_client *client, int page,
+				  int phase, int reg)
+{
+	const struct pmbus_driver_info *info = pmbus_get_driver_info(client);
+	struct ltc2978_data *data = to_ltc2978_data(info);
+	int ret;
+
+	switch (reg) {
+	case PMBUS_VIRT_READ_IOUT_AVG:
+		ret = ltc_read_word_data(client, page, 0xff,
+					 LTC3888_MFR_TOTAL_IOUT);
+		data->iout_max[page] = lin11_to_val(ret);
+		break;
+	default:
+		ret = ltc3880_read_word_data(client, page, phase, reg);
+		break;
+	}
+	return ret;
+}
+
 static int ltc2978_clear_peaks(struct ltc2978_data *data,
 			       struct i2c_client *client, int page)
 {
@@ -535,6 +560,7 @@ static int ltc2978_write_word_data(struct i2c_client *client, int page,
 	{"ltc3884", ltc3884},
 	{"ltc3886", ltc3886},
 	{"ltc3887", ltc3887},
+	{"ltc3888", ltc3888},
 	{"ltc3889", ltc3889},
 	{"ltc7880", ltc7880},
 	{"ltm2987", ltm2987},
@@ -621,6 +647,8 @@ static int ltc2978_get_id(struct i2c_client *client)
 		return ltc3886;
 	else if (chip_id == LTC3887_ID)
 		return ltc3887;
+	else if (chip_id == LTC3888_ID || chip_id == LTC3888_ID_D1)
+		return ltc3888;
 	else if (chip_id == LTC3889_ID)
 		return ltc3889;
 	else if (chip_id == LTC7880_ID)
@@ -821,6 +849,18 @@ static int ltc2978_probe(struct i2c_client *client)
 		  | PMBUS_HAVE_POUT
 		  | PMBUS_HAVE_TEMP | PMBUS_HAVE_STATUS_TEMP;
 		break;
+	case ltc3888:
+		data->features |= FEAT_CLEAR_PEAKS | FEAT_NEEDS_POLLING;
+		info->read_word_data = ltc3888_read_word_data;
+		info->pages = LTC3880_NUM_PAGES;
+		info->func[0] = PMBUS_HAVE_STATUS_VOUT | PMBUS_HAVE_STATUS_IOUT
+		  | PMBUS_HAVE_STATUS_INPUT | PMBUS_HAVE_STATUS_TEMP
+		  | PMBUS_HAVE_VIN | PMBUS_HAVE_VOUT | PMBUS_HAVE_IOUT
+		  | PMBUS_HAVE_TEMP | PMBUS_HAVE_TEMP2;
+		info->func[1] = PMBUS_HAVE_STATUS_VOUT | PMBUS_HAVE_STATUS_IOUT
+		  | PMBUS_HAVE_STATUS_TEMP | PMBUS_HAVE_VOUT | PMBUS_HAVE_IOUT
+		  | PMBUS_HAVE_TEMP;
+		break;
 	default:
 		return -ENODEV;
 	}
@@ -853,6 +893,7 @@ static int ltc2978_probe(struct i2c_client *client)
 	{ .compatible = "lltc,ltc3884" },
 	{ .compatible = "lltc,ltc3886" },
 	{ .compatible = "lltc,ltc3887" },
+	{ .compatible = "lltc,ltc3888" },
 	{ .compatible = "lltc,ltc3889" },
 	{ .compatible = "lltc,ltc7880" },
 	{ .compatible = "lltc,ltm2987" },
diff --git a/drivers/hwmon/pmbus/tps53679.c b/drivers/hwmon/pmbus/tps53679.c
index db2bdf2..126388d 100644
--- a/drivers/hwmon/pmbus/tps53679.c
+++ b/drivers/hwmon/pmbus/tps53679.c
@@ -16,7 +16,7 @@
 #include "pmbus.h"
 
 enum chips {
-	tps53647, tps53667, tps53679, tps53681, tps53688
+	tps53647, tps53659, tps53667, tps53679, tps53681, tps53688
 };
 
 #define TPS53647_PAGE_NUM		1
@@ -206,6 +206,11 @@ static int tps53679_probe(struct i2c_client *client)
 		info->pages = TPS53647_PAGE_NUM;
 		info->identify = tps53679_identify;
 		break;
+	case tps53659:
+		info->pages = TPS53679_PAGE_NUM;
+		info->identify = tps53679_identify;
+		info->func[0] |= PMBUS_HAVE_PIN;
+		break;
 	case tps53679:
 	case tps53688:
 		info->pages = TPS53679_PAGE_NUM;
@@ -227,6 +232,7 @@ static int tps53679_probe(struct i2c_client *client)
 static const struct i2c_device_id tps53679_id[] = {
 	{"tps53647", tps53647},
 	{"tps53667", tps53667},
+	{"tps53659", tps53659},
 	{"tps53679", tps53679},
 	{"tps53681", tps53681},
 	{"tps53688", tps53688},
@@ -238,6 +244,7 @@ static int tps53679_probe(struct i2c_client *client)
 static const struct of_device_id __maybe_unused tps53679_of_match[] = {
 	{.compatible = "ti,tps53647", .data = (void *)tps53647},
 	{.compatible = "ti,tps53667", .data = (void *)tps53667},
+	{.compatible = "ti,tps53659", .data = (void *)tps53659},
 	{.compatible = "ti,tps53679", .data = (void *)tps53679},
 	{.compatible = "ti,tps53681", .data = (void *)tps53681},
 	{.compatible = "ti,tps53688", .data = (void *)tps53688},
diff --git a/drivers/i2c/busses/Kconfig b/drivers/i2c/busses/Kconfig
index ea474b1..b9ab37b 100644
--- a/drivers/i2c/busses/Kconfig
+++ b/drivers/i2c/busses/Kconfig
@@ -566,6 +566,17 @@ config I2C_DESIGNWARE_BAYTRAIL
 	  the platform firmware controlling it. You should say Y if running on
 	  a BayTrail system using the AXP288.
 
+config I2C_DESIGNWARE_MCTP
+	bool "Synopsys DesignWare MCTP"
+	select I2C_SLAVE
+	depends on I2C_DESIGNWARE_PLATFORM
+	help
+	  If you say yes to this option, support will be included for the
+	  Synopsys DesignWare I2C in master/slave mode for MCTP.
+
+	  This is not a standalone module, this module compiles together with
+	  i2c-designware-core.
+
 config I2C_DESIGNWARE_PCI
 	tristate "Synopsys DesignWare PCI"
 	depends on PCI
@@ -934,6 +945,16 @@ config I2C_QUP
 	  This driver can also be built as a module.  If so, the module
 	  will be called i2c-qup.
 
+config I2C_RD1173
+	tristate "External SPI to Lattice I2C adapter device"
+	depends on SPI && REGMAP
+	help
+	  If you say yes to this option, support will be included for the
+	  SPI to Lattice I2C-bus adapter device.
+
+	  This driver can also be built as a module. If so, the module
+	  will be called i2c-rd1173.
+
 config I2C_RIIC
 	tristate "Renesas RIIC adapter"
 	depends on ARCH_RENESAS || COMPILE_TEST
diff --git a/drivers/i2c/busses/Makefile b/drivers/i2c/busses/Makefile
index 683c49fa..781369b 100644
--- a/drivers/i2c/busses/Makefile
+++ b/drivers/i2c/busses/Makefile
@@ -52,6 +52,7 @@ obj-$(CONFIG_I2C_DESIGNWARE_CORE)			+= i2c-designware-core.o
 i2c-designware-core-y					:= i2c-designware-common.o
 i2c-designware-core-y					+= i2c-designware-master.o
 i2c-designware-core-$(CONFIG_I2C_DESIGNWARE_SLAVE) 	+= i2c-designware-slave.o
+i2c-designware-core-$(CONFIG_I2C_DESIGNWARE_MCTP)	+= i2c-designware-mctp.o
 obj-$(CONFIG_I2C_DESIGNWARE_PLATFORM)			+= i2c-designware-platform.o
 i2c-designware-platform-y 				:= i2c-designware-platdrv.o
 i2c-designware-platform-$(CONFIG_I2C_DESIGNWARE_BAYTRAIL) += i2c-designware-baytrail.o
@@ -93,6 +94,7 @@ obj-$(CONFIG_I2C_PXA_PCI)	+= i2c-pxa-pci.o
 obj-$(CONFIG_I2C_QCOM_CCI)	+= i2c-qcom-cci.o
 obj-$(CONFIG_I2C_QCOM_GENI)	+= i2c-qcom-geni.o
 obj-$(CONFIG_I2C_QUP)		+= i2c-qup.o
+obj-$(CONFIG_I2C_RD1173)	+= i2c-rd1173.o
 obj-$(CONFIG_I2C_RIIC)		+= i2c-riic.o
 obj-$(CONFIG_I2C_RK3X)		+= i2c-rk3x.o
 obj-$(CONFIG_I2C_S3C2410)	+= i2c-s3c2410.o
diff --git a/drivers/i2c/busses/i2c-designware-common.c b/drivers/i2c/busses/i2c-designware-common.c
index 9468c6c..e99e2c0 100644
--- a/drivers/i2c/busses/i2c-designware-common.c
+++ b/drivers/i2c/busses/i2c-designware-common.c
@@ -8,6 +8,9 @@
  * Copyright (C) 2007 MontaVista Software Inc.
  * Copyright (C) 2009 Provigent Ltd.
  */
+#ifdef CONFIG_ARCH_PENSANDO_CAPRI_SOC
+#include <asm/cap_apb_io.h>
+#endif
 #include <linux/acpi.h>
 #include <linux/clk.h>
 #include <linux/delay.h>
@@ -56,6 +59,8 @@
 		"slave lost the bus while transmitting data to a remote master",
 	[ABRT_SLAVE_RD_INTX] =
 		"incorrect slave-transmitter mode configuration",
+	[ABRT_SDA_STUCK_AT_LOW] =
+		"sda line stuck low",
 };
 
 static int dw_reg_read(void *context, unsigned int reg, unsigned int *val)
diff --git a/drivers/i2c/busses/i2c-designware-core.h b/drivers/i2c/busses/i2c-designware-core.h
index eb5ef4d..f0be70e 100644
--- a/drivers/i2c/busses/i2c-designware-core.h
+++ b/drivers/i2c/busses/i2c-designware-core.h
@@ -37,6 +37,7 @@
 #define DW_IC_CON_STOP_DET_IFADDRESSED		0x80
 #define DW_IC_CON_TX_EMPTY_CTRL		0x100
 #define DW_IC_CON_RX_FIFO_FULL_HLD_CTRL		0x200
+#define DW_IC_CON_BUS_CLEAR_FEATURE_CTL	0x800
 
 /*
  * Registers offset
@@ -75,6 +76,8 @@
 #define DW_IC_TX_ABRT_SOURCE	0x80
 #define DW_IC_ENABLE_STATUS	0x9c
 #define DW_IC_CLR_RESTART_DET	0xa8
+#define DW_IC_SCL_STUCK_AT_LOW	0xac
+#define DW_IC_SDA_STUCK_AT_LOW	0xb0
 #define DW_IC_COMP_PARAM_1	0xf4
 #define DW_IC_COMP_VERSION	0xf8
 #define DW_IC_SDA_HOLD_MIN_VERS	0x3131312A
@@ -94,6 +97,7 @@
 #define DW_IC_INTR_START_DET	0x400
 #define DW_IC_INTR_GEN_CALL	0x800
 #define DW_IC_INTR_RESTART_DET	0x1000
+#define DW_IC_INTR_SCL_STUCK_AT_LOW 0x4000
 
 #define DW_IC_INTR_DEFAULT_MASK		(DW_IC_INTR_RX_FULL | \
 					 DW_IC_INTR_TX_ABRT | \
@@ -105,10 +109,13 @@
 					 DW_IC_INTR_RX_UNDER | \
 					 DW_IC_INTR_RD_REQ)
 
+#define DW_IC_SDA_STUCK_RECOVERY_ENABLE	0x8
+
 #define DW_IC_STATUS_ACTIVITY		0x1
 #define DW_IC_STATUS_TFE		BIT(2)
 #define DW_IC_STATUS_MASTER_ACTIVITY	BIT(5)
 #define DW_IC_STATUS_SLAVE_ACTIVITY	BIT(6)
+#define DW_IC_STATUS_SDA_STUCK_NOT_RECOVERED	BIT(11)
 
 #define DW_IC_SDA_HOLD_RX_SHIFT		16
 #define DW_IC_SDA_HOLD_RX_MASK		GENMASK(23, DW_IC_SDA_HOLD_RX_SHIFT)
@@ -153,6 +160,7 @@
 #define ABRT_SLAVE_FLUSH_TXFIFO	13
 #define ABRT_SLAVE_ARBLOST	14
 #define ABRT_SLAVE_RD_INTX	15
+#define ABRT_SDA_STUCK_AT_LOW	17
 
 #define DW_IC_TX_ABRT_7B_ADDR_NOACK	(1UL << ABRT_7B_ADDR_NOACK)
 #define DW_IC_TX_ABRT_10ADDR1_NOACK	(1UL << ABRT_10ADDR1_NOACK)
@@ -165,6 +173,7 @@
 #define DW_IC_TX_ABRT_10B_RD_NORSTRT	(1UL << ABRT_10B_RD_NORSTRT)
 #define DW_IC_TX_ABRT_MASTER_DIS	(1UL << ABRT_MASTER_DIS)
 #define DW_IC_TX_ARB_LOST		(1UL << ARB_LOST)
+#define DW_IC_TX_ABRT_SDA_STUCK_AT_LOW	(1UL << ABRT_SDA_STUCK_AT_LOW)
 #define DW_IC_RX_ABRT_SLAVE_RD_INTX	(1UL << ABRT_SLAVE_RD_INTX)
 #define DW_IC_RX_ABRT_SLAVE_ARBLOST	(1UL << ABRT_SLAVE_ARBLOST)
 #define DW_IC_RX_ABRT_SLAVE_FLUSH_TXFIFO	(1UL << ABRT_SLAVE_FLUSH_TXFIFO)
@@ -268,6 +277,7 @@ struct dw_i2c_dev {
 	int			rx_outstanding;
 	struct i2c_timings	timings;
 	u32			sda_hold_time;
+	u32			sda_timeout_ms;
 	u16			ss_hcnt;
 	u16			ss_lcnt;
 	u16			fs_hcnt;
diff --git a/drivers/i2c/busses/i2c-designware-master.c b/drivers/i2c/busses/i2c-designware-master.c
index 2871cf2..0484c30 100644
--- a/drivers/i2c/busses/i2c-designware-master.c
+++ b/drivers/i2c/busses/i2c-designware-master.c
@@ -22,6 +22,7 @@
 #include <linux/reset.h>
 
 #include "i2c-designware-core.h"
+#include "i2c-designware-mctp.h"
 
 static void i2c_dw_configure_fifo_master(struct dw_i2c_dev *dev)
 {
@@ -33,6 +34,45 @@ static void i2c_dw_configure_fifo_master(struct dw_i2c_dev *dev)
 	regmap_write(dev->map, DW_IC_CON, dev->master_cfg);
 }
 
+static int i2c_dw_issue_bus_clear(struct dw_i2c_dev *dev)
+{
+	u32 ic_status, ic_enable;
+	unsigned long timeout;
+
+	dev_info(dev->dev, "sda stuck; trying to recover\n");
+	regmap_write(dev->map, DW_IC_INTR_MASK, 0);
+	regmap_read(dev->map, DW_IC_ENABLE, &ic_enable);
+	regmap_write(dev->map, DW_IC_ENABLE,
+			ic_enable | DW_IC_SDA_STUCK_RECOVERY_ENABLE);
+
+	/*
+	 * Poll, waiting for recovery to be done. This may take up to 9 SCL
+	 * clocks and a STOP bit, though presumably the device will signal
+	 * completion in less time if it recovers sooner. There are apparently
+	 * cases where the recovery doesn't finish, so we have a timeout
+	 * in the loop.
+	 */
+	timeout = jiffies + msecs_to_jiffies(50);
+	while (!time_after(jiffies, timeout)) {
+		regmap_read(dev->map, DW_IC_ENABLE, &ic_enable);
+		if (!(ic_enable & DW_IC_SDA_STUCK_RECOVERY_ENABLE))
+			break;
+		usleep_range(1000, 2000);
+	}
+	regmap_read(dev->map, DW_IC_ENABLE, &ic_enable);
+	if (ic_enable & DW_IC_SDA_STUCK_RECOVERY_ENABLE) {
+		dev_err(dev->dev, "sda stuck recovery timed out\n");
+		return -EIO;
+	}
+	regmap_read(dev->map, DW_IC_STATUS, &ic_status);
+	if ((ic_status & DW_IC_STATUS_SDA_STUCK_NOT_RECOVERED) != 0) {
+		dev_err(dev->dev, "sda stuck recovery failed\n");
+		return -EIO;
+	}
+	dev_info(dev->dev, "sda stuck recovery successful\n");
+	return -EAGAIN;		/* -EAGAIN to auto-retry */
+}
+
 static int i2c_dw_set_timings_master(struct dw_i2c_dev *dev)
 {
 	const char *mode_str, *fp_str = "";
@@ -500,6 +540,14 @@ static void i2c_dw_xfer_init(struct dw_i2c_dev *dev)
 		goto done;
 	}
 
+	/* Look for a stuck bus */
+	if (dev->cmd_err == DW_IC_ERR_TX_ABRT &&
+		(dev->abort_source & DW_IC_TX_ABRT_SDA_STUCK_AT_LOW)) {
+		ret = i2c_dw_issue_bus_clear(dev);
+		i2c_dw_init_master(dev);
+		goto done;
+	}
+
 	/*
 	 * We must disable the adapter before returning and signaling the end
 	 * of the current transfer. Otherwise the hardware might continue
@@ -669,6 +717,78 @@ static irqreturn_t i2c_dw_isr(int this_irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
+/*
+ * MCTP enable I2C master mode
+ *   - Disable I2C interrupts
+ *   - Disable I2C device
+ *   - Free slave mode IRQ
+ *   - Configure and initialize master mode
+ *   - Request master mode IRQ
+ */
+#ifdef CONFIG_I2C_DESIGNWARE_MCTP
+int dw_enable_master(void)
+{
+	struct i2c_adapter *i2c_mctp_adap = get_i2c_mctp_adap();
+	struct dw_i2c_dev *dev = i2c_get_adapdata(i2c_mctp_adap);
+	struct i2c_client *client = get_i2c_dw_mctp();
+	struct i2c_adapter *adap = &dev->adapter;
+	unsigned long irq_flags;
+	int ret = 0;
+
+	i2c_dw_wait_bus_not_busy(dev);
+
+	dev->init = i2c_dw_init_master;
+	dev->disable = i2c_dw_disable;
+	dev->disable_int = i2c_dw_disable_int;
+
+	if (client) {
+		/* Does disable_int(dev), disable(dev), client = NULL */
+		i2c_dw_unreg_slave(client);
+		if (ret)
+			dev_info(dev->dev, "i2c slave unreg error (%d)\n", ret);
+		if (dev->irq)
+			devm_free_irq(dev->dev, dev->irq, dev);
+	}
+
+	/* Configure in master mode */
+	i2c_dw_configure_master(dev);
+
+	ret = i2c_dw_init_regmap(dev);
+	if (ret)
+		return ret;
+
+	ret = i2c_dw_set_timings_master(dev);
+	if (ret)
+		return ret;
+
+	ret = i2c_dw_set_fifo_size(dev);
+	if (ret)
+		return ret;
+
+	ret = dev->init(dev);
+	if (ret)
+		return ret;
+
+	snprintf(adap->name, sizeof(adap->name),
+		 "Synopsys DesignWare I2C adapter");
+	adap->retries = 3;
+	adap->algo = &i2c_dw_algo;
+	adap->dev.parent = dev->dev;
+	i2c_set_adapdata(adap, dev);
+
+	irq_flags = IRQF_SHARED | IRQF_COND_SUSPEND;
+	ret = devm_request_irq(dev->dev, dev->irq, i2c_dw_isr, irq_flags,
+	dev_name(dev->dev), dev);
+	if (ret) {
+		dev_info(dev->dev, "failure requesting irq %i: %d\n",
+			 dev->irq, ret);
+		return ret;
+	}
+
+	return ret;
+}
+#endif
+
 void i2c_dw_configure_master(struct dw_i2c_dev *dev)
 {
 	struct i2c_timings *t = &dev->timings;
@@ -711,6 +831,39 @@ static void i2c_dw_unprepare_recovery(struct i2c_adapter *adap)
 	i2c_dw_init_master(dev);
 }
 
+static int i2c_dw_probe_bus_clear_feature(struct dw_i2c_dev *dev)
+{
+	u32 con, timeout;
+	int ret;
+
+	/* only use controller bus_clear if the sda timeout is specified */
+	if (!dev->sda_timeout_ms)
+		return 0;
+
+	ret = i2c_dw_acquire_lock(dev);
+	if (ret)
+		return ret;
+
+	/*
+	 * Probe the availability of the BUS_CLEAR_FEATURE by setting the
+	 * bit in IC_CON.  If the bit reads back set, then the feature is
+	 * available, otherwise it is not.
+	 */
+	regmap_write(dev->map, DW_IC_CON, DW_IC_CON_BUS_CLEAR_FEATURE_CTL);
+	regmap_read(dev->map, DW_IC_CON, &con);
+	if (!(con & DW_IC_CON_BUS_CLEAR_FEATURE_CTL))
+		goto out;
+	dev_info(dev->dev, "running with controller bus clear recovery mode!");
+	timeout = i2c_dw_clk_rate(dev) * dev->sda_timeout_ms; /* clk in kHz */
+	regmap_write(dev->map, DW_IC_SDA_STUCK_AT_LOW, timeout);
+	dev->master_cfg |= DW_IC_CON_BUS_CLEAR_FEATURE_CTL;
+out:
+	regmap_write(dev->map, DW_IC_CON, dev->master_cfg);
+	i2c_dw_release_lock(dev);
+
+	return 0;
+}
+
 static int i2c_dw_init_recovery_info(struct dw_i2c_dev *dev)
 {
 	struct i2c_bus_recovery_info *rinfo = &dev->rinfo;
@@ -718,8 +871,11 @@ static int i2c_dw_init_recovery_info(struct dw_i2c_dev *dev)
 	struct gpio_desc *gpio;
 
 	gpio = devm_gpiod_get_optional(dev->dev, "scl", GPIOD_OUT_HIGH);
-	if (IS_ERR_OR_NULL(gpio))
-		return PTR_ERR_OR_ZERO(gpio);
+	if (IS_ERR_OR_NULL(gpio)) {
+		if (IS_ERR(gpio))
+			return PTR_ERR(gpio);
+		return i2c_dw_probe_bus_clear_feature(dev);
+	}
 
 	rinfo->scl_gpiod = gpio;
 
diff --git a/drivers/i2c/busses/i2c-designware-mctp.c b/drivers/i2c/busses/i2c-designware-mctp.c
new file mode 100644
index 00000000..e956e6f
--- /dev/null
+++ b/drivers/i2c/busses/i2c-designware-mctp.c
@@ -0,0 +1,1970 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020, Pensando Systems Inc.
+ *
+ * Pensando MCTP driver for Synopsys DesignWare I2C adapter.
+ *
+ */
+
+#include <linux/i2c.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/sysfs.h>
+#include <linux/timer.h>
+#include <linux/interrupt.h>
+#include <linux/miscdevice.h>
+#include <linux/workqueue.h>
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <linux/poll.h>
+#include <linux/ioctl.h>
+#include <linux/kfifo.h>
+#include <linux/ktime.h>
+#include <linux/delay.h>
+
+#include "i2c-designware-core.h"
+#include "i2c-designware-mctp.h"
+
+#define MCTP_FIFO_DEPTH    256
+#define USEC_TO_NSEC       1000
+#define LOG_SQUELCH_LIMIT  20
+
+/* i2c-designware-master.c */
+int dw_enable_master(void);
+
+/* i2c-designware-slave.c */
+void *get_i2c_dw_mctp(void);
+int dw_enable_slave(void);
+void dw_update_slave_addr(void);
+
+static void rx_packet(struct work_struct *work);
+static void tx_packet(int count);
+static void update_addr(struct work_struct *work);
+static void arp_reset(struct work_struct *work);
+static void reset(struct work_struct *work);
+
+static uint32_t mctp_rx_msg_size;
+static uint32_t mctp_tx_msg_size;
+static bool ctrl_msg_active;		/* mctp message is in progress */
+static bool ncsi_msg_active;		/* ncsi message is in progress */
+static bool pldm_msg_active;		/* pldm message is in progress */
+static bool in_progress;		/* rx packet is in progress */
+static bool dw_master;			/* response in progress */
+
+struct i2c_adapter *i2c_mctp_adap;
+
+struct i2c_adapter *get_i2c_mctp_adap(void)
+{
+	return i2c_mctp_adap;
+}
+
+/*
+ * Byte offsets into the mctp buffer.  The first byte in the smbus block write
+ * is the destination slave address which is not included in the work_struct
+ * buffer provided to rx_packet when a complete mctp packet is received.
+ */
+#define BUF_CMD_CODE       0    /* MCTP = 0x0f */
+#define BUF_BYTE_CNT       1
+#define BUF_I2C_SRCADDR    2
+#define BUF_MCTP_HDR       3
+#define BUF_DEST_EID       4
+#define BUF_SRC_EID        5
+#define BUF_MCTP_FLAGS     6
+#define BUF_MSG_TYPE       7
+
+/* Debug control */
+#define MCTP_MSG_DUMP      0x01
+#define MCTP_MSG_DECODE    0x02
+
+//static int mctp_debug = MCTP_MSG_DUMP | MCTP_MSG_DECODE;
+static int mctp_debug;
+
+/* packet dump flag, response has completion code before data/pec */
+enum pkt_dump_type {
+	MCTP_CMD_PKT  = 0,
+	MCTP_RESP_PKT = 1,
+};
+
+/*
+ * The mctp data buffer is rounded up to 96 bytes
+ * - i2c header:       4 bytes
+ * - mctp header:      4 bytes
+ * - msg body header:  4 bytes
+ * - msg body data:   64 bytes
+ * - i2c pec:          1 byte
+ *             total: 77 bytes
+ */
+#define MCTP_BUF_SIZE    96
+#define MAX_IDX          (MCTP_BUF_SIZE - 1)
+#define MCTP_HDR_SIZE    (I2C_HDR_LEN + MCTP_HDR_LEN)
+
+/*
+ * Address resolved flag
+ * A flag bit or state internal to a device that indicates whether or
+ * not the device's slave address has been resolved by the ARP Master.
+ *
+ * Address valid flag
+ * A flag bit or state internal to a device that indicates whether or not
+ * the device's slave address is valid. This bit must be non-volatile for
+ * devices that support the Persistent Slave Address.
+ */
+static struct mctp_data {
+	u8 slave_addr;                   /* naples 8-bit slave address */
+	bool arp_complete;               /* arp complete, addr 0xc2 => 0x92 */
+	bool mctp_discovery_started;     /* mctp pkts received after arp */
+	bool smbus_address_valid;        /* naples slave address valid */
+	bool smbus_address_resolved;     /* naples slave address is resolved */
+	u8 smbus_arp_state;              /* smbus arp state variable */
+	bool first_write;                /* start of a smbus block write */
+	u8 assigned_eid;                 /* bus owner assigned eid */
+	u8 eid;                          /* naples eid */
+	u16 pcie_vendorid;               /* from catalog.pcie_vendorid() */
+	u16 pcie_deviceid;               /* naples pcie device id */
+	u16 pcie_subvendorid;            /* from catalog.pcie_subvendorid() */
+	u16 pcie_subdeviceid;            /* from catalog.pcie_subdeviceid() */
+	struct work_struct rx_packet;    /* fn called from irq context */
+	struct work_struct update_addr;  /* fn called from irq context */
+	struct work_struct arp_reset;    /* fn can be called from irq context */
+	struct work_struct reset;        /* fn can be called from irq context */
+	u8 buf_idx;                      /* mctp message buffer index */
+	u8 buf[MCTP_BUF_SIZE];           /* mctp message buffer */
+} mctp_data;
+
+/*
+ * struct mctp_device
+ * @dev: parent device
+ * @dev_lock: read/write operations lock
+ * @rx_fifo: mctp control message request fifo
+ * @rx_fifo_spinlock: lock protected add data to mctp rx fifo
+ * @fifo_proc_list: wait queue that handles blocking reads of events
+ * @open_count: device open count, tx fifo reset on first open
+ */
+static struct mctp_device {
+	struct device *dev;
+	struct mutex dev_lock;
+	struct mutex tx_lock;
+	struct kfifo rx_fifo;
+	spinlock_t rx_fifo_spinlock;
+	wait_queue_head_t fifo_proc_list;
+	int open_count;
+} mctp_device;
+
+/*
+ * struct ncsi_device
+ * @dev: parent device
+ * @dev_lock: read/write operations lock
+ * @rx_fifo: ncsi control message request fifo
+ * @rx_fifo_spinlock: lock protected add data to ncsi rx fifo
+ * @fifo_proc_list: wait queue that handles blocking reads of events
+ * @open_count: device open count, tx fifo reset on first open
+ */
+static struct ncsi_device {
+	struct device *dev;
+	struct mutex dev_lock;
+	struct kfifo rx_fifo;
+	spinlock_t rx_fifo_spinlock;
+	wait_queue_head_t fifo_proc_list;
+	int open_count;
+} ncsi_device;
+
+/*
+ * struct pldm_device
+ * @dev: parent device
+ * @dev_lock: read/write operations lock
+ * @rx_fifo: pldm control message request fifo
+ * @rx_fifo_spinlock: lock protected add data to pldm rx fifo
+ * @fifo_proc_list: wait queue that handles blocking reads of events
+ * @open_count: device open count, tx fifo reset on first open
+ */
+static struct pldm_device {
+	struct device *dev;
+	struct mutex dev_lock;
+	struct kfifo rx_fifo;
+	spinlock_t rx_fifo_spinlock;
+	wait_queue_head_t fifo_proc_list;
+	int open_count;
+} pldm_device;
+
+static struct mctp_statistics {
+	/* message types */
+	uint32_t mctp_ctrl_msg;
+	uint32_t mctp_pldm_msg;
+	uint32_t mctp_ncsi_msg;
+	uint32_t mctp_ethernet_msg;
+	uint32_t mctp_vendor_pci_msg;
+	uint32_t mctp_vendor_iana_msg;
+
+	/* mctp rx */
+	uint32_t mctp_rx_pkts;
+	uint32_t mctp_rx_bytes;
+	uint32_t mctp_rx_msg_64b;
+	uint32_t mctp_rx_msg_65b_128b;
+	uint32_t mctp_rx_msg_129b_192b;
+	uint32_t mctp_rx_msg_193b_256b;
+	uint32_t mctp_rx_msg_257b_512b;
+	uint32_t mctp_rx_msg_over_512b;
+
+	/* mctp tx */
+	uint32_t mctp_tx_pkts;
+	uint32_t mctp_tx_bytes;
+	uint32_t mctp_tx_msg_64b;
+	uint32_t mctp_tx_msg_65b_128b;
+	uint32_t mctp_tx_msg_129b_192b;
+	uint32_t mctp_tx_msg_193b_256b;
+	uint32_t mctp_tx_msg_257b_512b;
+	uint32_t mctp_tx_msg_over_512b;
+	uint32_t mctp_txfifo_max_bytes;
+	uint32_t mctp_txfifo_full_reset;
+	uint32_t mctp_txfifo_error_reset;
+
+	/* mctp control message */
+	uint32_t ctrl_rx_bytes;
+	uint32_t ctrl_tx_bytes;
+	uint32_t ctrl_msg_not_read;
+	uint32_t ctrl_msg_resp_late;
+	uint32_t ctrl_avg_latency_usec;
+	uint32_t ctrl_max_latency_usec;
+	uint32_t ctrl_rxfifo_max_bytes;
+	uint32_t ctrl_rxfifo_full_reset;
+	uint32_t ctrl_rxfifo_error_reset;
+
+	/* ncsi message */
+	uint32_t ncsi_rx_bytes;
+	uint32_t ncsi_tx_bytes;
+	uint32_t ncsi_msg_not_read;
+	uint32_t ncsi_msg_resp_late;
+	uint32_t ncsi_avg_latency_usec;
+	uint32_t ncsi_max_latency_usec;
+	uint32_t ncsi_rxfifo_max_bytes;
+	uint32_t ncsi_rxfifo_full_reset;
+	uint32_t ncsi_rxfifo_error_reset;
+
+	/* pldm message */
+	uint32_t pldm_rx_bytes;
+	uint32_t pldm_tx_bytes;
+	uint32_t pldm_msg_not_read;
+	uint32_t pldm_msg_resp_late;
+	uint32_t pldm_max_latency_usec;
+	uint32_t pldm_avg_latency_usec;
+	uint32_t pldm_rxfifo_max_bytes;
+	uint32_t pldm_rxfifo_full_reset;
+	uint32_t pldm_rxfifo_error_reset;
+
+	/* ioctl and error recovery */
+	uint32_t arp_reset;
+	uint32_t slave_reset;
+	uint32_t reset_all_fifos;
+
+	/* i2c layer */
+	uint32_t i2c_transfer_success;
+	uint32_t i2c_transfer_error;
+} stats;
+
+/*
+ * reset_all_fifos
+ *
+ * Used for error recovery and accessible via mctputil system call
+ */
+static void reset_all_fifos(void)
+{
+	kfifo_reset(&mctp_device.rx_fifo);
+	kfifo_reset(&ncsi_device.rx_fifo);
+	kfifo_reset(&pldm_device.rx_fifo);
+
+	stats.reset_all_fifos++;
+}
+
+static void reset_to_slave(void)
+{
+	struct i2c_client *client = get_i2c_dw_mctp();
+	int rc;
+
+	rc = dw_enable_master();
+	if (rc)
+		dev_info(&client->dev, "dw_enable_master %d\n", rc);
+	rc = dw_enable_slave();
+	if (rc)
+		dev_info(&client->dev, "dw_enable_slave %d\n", rc);
+	dw_master = false;
+	stats.slave_reset++;
+}
+
+/* Reset to slave mode from ISR context */
+static void reset(struct work_struct *work)
+{
+	reset_to_slave();
+}
+
+static void arp_reset(struct work_struct *work)
+{
+	struct mctp_data *mctp_data =
+		container_of(work, struct mctp_data, arp_reset);
+	struct i2c_client *client = get_i2c_dw_mctp();
+
+	dev_info(&client->dev, "arp reset\n");
+	dev_info(&client->dev, "smbus av/ar flags cleared\n");
+	mctp_data->arp_complete = false;
+	mctp_data->mctp_discovery_started = false;
+	mctp_data->smbus_address_valid = false;
+	mctp_data->smbus_address_resolved = false;
+
+	dev_info(&client->dev, "smbus slave address 0xc2\n");
+	mctp_data->slave_addr = SMBUS_DEFAULT_ADDR;
+	client->addr = (SMBUS_DEFAULT_ADDR >> 1);
+
+	/* Disruptive action, reset */
+	reset_all_fifos();
+	reset_to_slave();
+	stats.arp_reset++;
+}
+
+/* Default address if no MCTP packet soon after ARP completion */
+static struct timer_list arp_timer;
+
+static void arp_timer_expired(struct timer_list *t)
+{
+	struct i2c_client *client = get_i2c_dw_mctp();
+	struct mctp_data *mctp_data = i2c_get_clientdata(client);
+
+	if (mctp_data->mctp_discovery_started) {
+		dev_info(&client->dev, "arp timer expired, mctp pkts received\n");
+		return;
+	}
+
+	dev_info(&client->dev, "arp complete and no mctp discovery pkts\n");
+	schedule_work(&mctp_data->arp_reset);
+}
+
+static void arp_timer_start(void)
+{
+	struct i2c_client *client = get_i2c_dw_mctp();
+
+	arp_timer.expires = jiffies + msecs_to_jiffies(5000);
+	mod_timer(&arp_timer, arp_timer.expires);
+	dev_info(&client->dev, "arp timer started\n");
+}
+
+/*
+ * Timers to measure response latency and remove a message in the kfifo
+ * that has not been read within the driver timeout.  When the bmc resends
+ * a message the ID changes.
+ */
+static struct timer_list ctrl_timer;
+static struct timer_list ncsi_timer;
+static struct timer_list pldm_timer;
+
+static ktime_t ctrl_start;
+static ktime_t ncsi_start;
+static ktime_t pldm_start;
+
+/* For a simple average response latency */
+static u64 ctrl_dt_usec_sum;
+static u64 ncsi_dt_usec_sum;
+static u64 pldm_dt_usec_sum;
+
+static int ctrl_timer_count;
+static int ncsi_timer_count;
+static int pldm_timer_count;
+
+static bool squelch_ctrl_not_read_log;
+static bool squelch_ncsi_not_read_log;
+static bool squelch_pldm_not_read_log;
+
+/*
+ * Userspace responder (mctpd, ncsid, pldmd) rx fifo should not have data when
+ * the read timer expires.  The client may not be running or is stuck.  Either
+ * way delete the data and increment the message not read counter.  The timer
+ * is deleted when the responder does a write.  If the fifo was read and the
+ * responder doesn't send a response for any reason the response late counter
+ * is incremented.
+ */
+static void ctrl_timer_expired(struct timer_list *t)
+{
+	struct i2c_client *client = get_i2c_dw_mctp();
+	struct mctp_data *mctp_data = i2c_get_clientdata(client);
+
+	/*
+	 * Limit logging should the userspace client not read messages to
+	 * be 10 in a row then squelch until a successful read.
+	 */
+	if (++ctrl_timer_count > LOG_SQUELCH_LIMIT)
+		squelch_ctrl_not_read_log = true;
+
+	if (!squelch_ctrl_not_read_log) {
+		dev_info(&client->dev, "ctrl timer expired (%d)\n",
+			 ctrl_timer_count);
+	}
+
+	/* No timing on unread/dropped request */
+	ctrl_msg_active = false;
+
+	/* Reset to slave mode if response has started */
+	if (dw_master) {
+		dev_info(&client->dev, "reset to slave mode\n");
+		schedule_work(&mctp_data->reset);
+	}
+
+	if (kfifo_avail(&mctp_device.rx_fifo)) {
+		kfifo_reset(&mctp_device.rx_fifo);
+		stats.ctrl_msg_not_read++;
+	} else {
+		stats.ctrl_msg_resp_late++;
+	}
+}
+
+static void ncsi_timer_expired(struct timer_list *t)
+{
+	struct i2c_client *client = get_i2c_dw_mctp();
+	struct mctp_data *mctp_data = i2c_get_clientdata(client);
+
+	/*
+	 * Limit logging should the userspace client not read messages to
+	 * be 10 in a row then squelch until a successful read.
+	 */
+	if (++ncsi_timer_count > LOG_SQUELCH_LIMIT)
+		squelch_ncsi_not_read_log = true;
+
+	if (!squelch_ncsi_not_read_log) {
+		dev_info(&client->dev, "ncsi timer expired (%d)\n",
+			 ncsi_timer_count);
+	}
+
+	/* No timing on unread/dropped request */
+	ncsi_msg_active = false;
+
+	/* Reset to slave mode if response has started */
+	if (dw_master) {
+		dev_info(&client->dev, "reset to slave mode\n");
+		schedule_work(&mctp_data->reset);
+	}
+
+	if (kfifo_avail(&ncsi_device.rx_fifo)) {
+		kfifo_reset(&ncsi_device.rx_fifo);
+		stats.ncsi_msg_not_read++;
+	} else {
+		stats.ncsi_msg_resp_late++;
+	}
+}
+
+static void pldm_timer_expired(struct timer_list *t)
+{
+	struct i2c_client *client = get_i2c_dw_mctp();
+	struct mctp_data *mctp_data = i2c_get_clientdata(client);
+
+	/*
+	 * Limit logging should the userspace client not read messages to
+	 * be 10 in a row then squelch until a successful read.
+	 */
+	if (++pldm_timer_count > LOG_SQUELCH_LIMIT)
+		squelch_pldm_not_read_log = true;
+
+	if (!squelch_pldm_not_read_log) {
+		dev_info(&client->dev, "pldm timer expired (%d)\n",
+			 pldm_timer_count);
+	}
+
+	/* No timing on unread/dropped request */
+	pldm_msg_active = false;
+
+	/* Reset to slave mode if response has started */
+	if (dw_master) {
+		dev_info(&client->dev, "reset to slave mode\n");
+		schedule_work(&mctp_data->reset);
+	}
+
+	if (kfifo_avail(&pldm_device.rx_fifo)) {
+		kfifo_reset(&pldm_device.rx_fifo);
+		stats.pldm_msg_not_read++;
+	} else {
+		stats.pldm_msg_resp_late++;
+	}
+}
+
+static void ctrl_timer_start(void)
+{
+	ctrl_start = ktime_get();
+	ctrl_timer.expires = jiffies + msecs_to_jiffies(KFIFO_READ_TIMEOUT);
+	mod_timer(&ctrl_timer, ctrl_timer.expires);
+}
+
+static void ncsi_timer_start(void)
+{
+	ncsi_start = ktime_get();
+	ncsi_timer.expires = jiffies + msecs_to_jiffies(KFIFO_READ_TIMEOUT);
+	mod_timer(&ncsi_timer, ncsi_timer.expires);
+}
+
+static void pldm_timer_start(void)
+{
+	pldm_start = ktime_get();
+	pldm_timer.expires = jiffies + msecs_to_jiffies(KFIFO_READ_TIMEOUT);
+	mod_timer(&pldm_timer, pldm_timer.expires);
+}
+
+#define POLY    (0x1070U << 3)
+static u8 crc8(u16 data)
+{
+	int i;
+
+	for (i = 0; i < 8; i++) {
+		if (data & 0x8000)
+			data = data ^ POLY;
+		data = data << 1;
+	}
+	return (u8)(data >> 8);
+}
+
+/* Incremental CRC8 over count bytes in the array pointed to by p */
+static u8 i2c_smbus_pec(u8 crc, u8 *p, size_t count)
+{
+	int i;
+
+	for (i = 0; i < count; i++)
+		crc = crc8((crc ^ p[i]) << 8);
+
+	return crc;
+}
+
+/* Assume a 7-bit address, which is reasonable for SMBus */
+static u8 i2c_smbus_msg_pec(u8 pec, struct i2c_msg *msg)
+{
+	/* The address will be sent first */
+	u8 addr = i2c_8bit_addr_from_msg(msg);
+
+	pec = i2c_smbus_pec(pec, &addr, 1);
+
+	/* The data buffer follows */
+	return i2c_smbus_pec(pec, msg->buf, msg->len);
+}
+
+/* Used for write only transactions */
+static inline void i2c_smbus_add_pec(struct i2c_msg *msg)
+{
+	msg->buf[msg->len] = i2c_smbus_msg_pec(0, msg);
+	msg->len++;
+}
+
+static void get_udid_data(uint8_t *buf)
+{
+	struct smbus_udid udid;
+	uint8_t pec;
+
+	/*
+	 * SMBus ARP Device capabilities.  All devices are responding to
+	 * Get UDID and a zero wins which results in fixed address devices
+	 * identified first and random number devices last.
+	 */
+
+	// pec supported is bit 0
+	// bits 7:6 are address type
+	// 0x01 = 0000.0001b  fixed
+	// 0x41 = 0100.0001b  dynamic and persistent
+	// 0x81 = 1000.0001b  dynamic and volatile
+	// 0xc1 = 1100.0001b  random number
+
+	udid.device_capabilities = 0x01;  /* Fixed addr */
+	//udid.device_capabilities = 0x41;  /* Dynamic and persistent addr */
+	//udid.device_capabilities = 0x81;  /* Dynamic and volatile addr */
+	//udid.device_capabilities = 0xc1;  /* Random number addr */
+
+	/* UDID version 1, silicon version 0 */
+	udid.version = 0x08;
+
+	/* Byte Count, UDID bytes not including PEC */
+	buf[0] = 17;
+
+	/* Device capabilities */
+	buf[1] = udid.device_capabilities;    /* Data 1 (UDID byte 15) */
+
+	/* Version */
+	buf[2] = udid.version;
+
+	/* Vendor ID */
+	udid.vendor_id = mctp_data.pcie_vendorid;
+	buf[3] = udid.vendor_id >> 8;
+	buf[4] = udid.vendor_id & 0xff;
+
+	/* Device ID */
+	udid.device_id = mctp_data.pcie_deviceid;
+	buf[5] = udid.device_id >> 8;
+	buf[6] = udid.device_id & 0xff;
+
+	/* Interface */
+	/* ASF=1 (additional interface capabilities), SMBus version 2.0 */
+	udid.interface = 0x0024;
+	buf[7] = udid.interface >> 8;
+	buf[8] = udid.interface;
+
+	/* Subsystem vendor ID */
+	udid.subsystem_vendor_id = mctp_data.pcie_subvendorid;
+	buf[9] = udid.subsystem_vendor_id >> 8;
+	buf[10] = udid.subsystem_vendor_id & 0xff;
+
+	/* Subsystem device ID */
+	udid.subsystem_device_id = mctp_data.pcie_subdeviceid;
+	buf[11] = udid.subsystem_device_id >> 8;
+	buf[12] = udid.subsystem_device_id;
+
+	/* Vendor specific ID */
+	udid.vendor_specific_id = 0;
+	buf[13] = udid.vendor_specific_id >> 24;
+	buf[14] = udid.vendor_specific_id >> 16;
+	buf[15] = udid.vendor_specific_id >> 8;
+	buf[16] = udid.vendor_specific_id;          /* Data 16 (UDID byte 0) */
+
+	// Bit 0 (LSB) in the Data17 field must be returned as 1b.
+	// If a device has its AV flag clear then it must return 1111 111b for
+	// the remaining bits in the Data17 field.
+	buf[17] = MCTP_DEFAULT_FIXED_ADDR | 0x1;    /* Device slave address */
+
+	pec = i2c_smbus_pec(0, buf, 18);
+	buf[18] = pec;     /* PEC */
+}
+
+static void log_msg(uint8_t data[], int len, const char *label, u8 type)
+{
+	char msg[1024];
+	char *msgp = msg;
+	int byte_count = data[1];
+	int msg_data_len;
+	int i;
+
+	/* The first four bytes of smbus block write protocol
+	 *   - destination slave address
+	 *   - command code (mctp=0xf)
+	 *   - byte count - bytes that follow the Byte Count field up
+	 *     to, but not including, the PEC byte.
+	 *   - source slave address with bit 0
+	 *
+	 * The mctp data buffer starts with the command code
+	 */
+	if (mctp_debug & MCTP_MSG_DUMP) {
+		for (i = 0; i < len; i++)
+			msgp += sprintf(msgp, "%02x ", data[i]);
+		pr_info("%s: len %d, %s\n", label, len, msg);
+	}
+
+	if (mctp_debug & MCTP_MSG_DECODE) {
+		msgp = msg;
+		msgp += sprintf(msgp, "id %02d ", data[8] & 0x1f);
+		msgp += sprintf(msgp, "len %02d ", data[BUF_BYTE_CNT]);
+		msgp += sprintf(msgp, "i2c_src 0x%02x ", data[BUF_I2C_SRCADDR]);
+		msgp += sprintf(msgp, "dest_eid 0x%02x ", data[BUF_DEST_EID]);
+		msgp += sprintf(msgp, "src_eid 0x%02x ", data[BUF_SRC_EID]);
+		msgp += sprintf(msgp, "mctp_flags 0x%02x ", data[BUF_MCTP_FLAGS]);
+		msgp += sprintf(msgp, "msg_type 0x%02x ", data[BUF_MSG_TYPE]);
+		msgp += sprintf(msgp, "msg_flags 0x%02x ", data[8]);
+		msgp += sprintf(msgp, "msg_cmd 0x%02x ", data[9]);
+
+		if (type == MCTP_CMD_PKT) {
+			msg_data_len = byte_count - 5;
+			pr_info("CMD: msg data cnt %d\n", msg_data_len);
+
+			if (msg_data_len) {
+				msgp += sprintf(msgp, "data ");
+				for (i = 0; i < msg_data_len; i++)
+					msgp += sprintf(msgp, "0x%02x ",
+					data[i]);
+			}
+			/* pec byte */
+			msgp += sprintf(msgp, "pec 0x%02x",
+			data[len - 1]);
+		}
+
+		if (type == MCTP_RESP_PKT) {
+			msg_data_len = byte_count - 6;
+			msgp += sprintf(msgp, "rc %d ", data[10]);
+
+			if (msg_data_len) {
+				msgp += sprintf(msgp, "data ");
+				for (i = 0; i < msg_data_len; i++)
+					msgp += sprintf(msgp, "0x%02x ",
+							data[i]);
+			}
+			/* pec byte */
+			msgp += sprintf(msgp, "pec 0x%02x",
+					data[len - 1]);
+		}
+		pr_info("%s: %s\n", label, msg);
+	}
+}
+
+static int mctp_cmd_not_supported(struct mctp_data *mctp_data)
+{
+	struct i2c_client *client = get_i2c_dw_mctp();
+	uint8_t msg_type = mctp_data->buf[BUF_MSG_TYPE];
+	struct mctp_response resp;
+	struct i2c_msg msgs[1];
+	int rc;
+
+	dev_dbg(&client->dev, "mctp msg type %d not supported\n", msg_type);
+
+	/* i2c header */
+	resp.i2c_hdr.cmd = 0x0f;
+	resp.i2c_hdr.len = I2C_HDR_LEN + MCTP_HDR_LEN + 1;
+	resp.i2c_hdr.src = mctp_data->slave_addr;
+
+	/* mctp header */
+	resp.mctp_hdr.ver = mctp_data->buf[BUF_MCTP_HDR];
+	resp.mctp_hdr.dest = mctp_data->buf[BUF_SRC_EID];
+	resp.mctp_hdr.src = mctp_data->buf[BUF_DEST_EID];
+	resp.mctp_hdr.hdr_flags =
+		mctp_data->buf[BUF_MCTP_FLAGS] & ~MCTP_HDR_FLAG_TO;
+
+	/* response data */
+	resp.data[0] = MCTP_CTRL_UNSUPPORTED_CMD;
+
+	msgs[0].addr = (mctp_data->buf[BUF_I2C_SRCADDR] >> 1);    // 7-bit
+	msgs[0].len = 11;
+	msgs[0].flags = 0;
+	msgs[0].buf = (uint8_t *) &resp.i2c_hdr.cmd;
+
+	i2c_smbus_add_pec(&msgs[0]);   // increments len
+
+	rc = dw_enable_master();
+	if (rc) {
+		reset_all_fifos();
+		dev_info(&client->dev, "cmd dw_enable_master - %d\n", rc);
+		dw_enable_slave();
+		return rc;
+	}
+
+	rc = i2c_transfer(i2c_mctp_adap, msgs, 1);
+	if (rc == 1) {
+		stats.i2c_transfer_success++;
+	} else {
+		stats.i2c_transfer_error++;
+		dev_info(&client->dev, "i2c transfer error - %d\n", rc);
+	}
+
+	rc = dw_enable_slave();
+	if (rc) {
+		reset_all_fifos();
+		dev_info(&client->dev, "cmd dw_enable_slave - %d\n", rc);
+	}
+
+	return rc;
+}
+
+/*
+ * Packet statistics are for Message Header/Data bytes.  For example, a
+ * MCTP message that is larger than 64 bytes will be sent in multiple
+ * packets where the first packet is a 64 byte message with 8 byte header
+ * for an I2C transfer of 72 bytes.
+ */
+static void update_rx_stats(uint32_t bytes)
+{
+	uint32_t pktsize = MCTP_BTU + MCTP_HEADER_SIZE;
+
+	if (bytes <= pktsize)
+		stats.mctp_rx_msg_64b++;
+	else if ((bytes > pktsize) && (bytes <= 2 * pktsize))
+		stats.mctp_rx_msg_65b_128b++;
+	else if ((bytes > 2 * pktsize) && (bytes <= 3 * pktsize))
+		stats.mctp_rx_msg_129b_192b++;
+	else if ((bytes > 3 * pktsize) && (bytes <= 4 * pktsize))
+		stats.mctp_rx_msg_193b_256b++;
+	else if ((bytes > 4 * pktsize) && (bytes <= 8 * pktsize))
+		stats.mctp_rx_msg_257b_512b++;
+	else
+		stats.mctp_rx_msg_over_512b++;
+}
+
+static void update_tx_stats(uint32_t bytes)
+{
+	uint32_t pktsize = MCTP_BTU + MCTP_HEADER_SIZE;
+
+	if (bytes <= pktsize)
+		stats.mctp_tx_msg_64b++;
+	else if ((bytes > pktsize) && (bytes <= 2 * pktsize))
+		stats.mctp_tx_msg_65b_128b++;
+	else if ((bytes > 2 * pktsize) && (bytes <= 3 * pktsize))
+		stats.mctp_tx_msg_129b_192b++;
+	else if ((bytes > 3 * pktsize) && (bytes <= 4 * pktsize))
+		stats.mctp_tx_msg_193b_256b++;
+	else if ((bytes > 4 * pktsize) && (bytes <= 8 * pktsize))
+		stats.mctp_tx_msg_257b_512b++;
+	else
+		stats.mctp_tx_msg_over_512b++;
+}
+
+static int add_to_mctp_rx_fifo(struct mctp_data *mctp_data)
+{
+	struct i2c_client *client = get_i2c_dw_mctp();
+	uint32_t bytes;
+	uint32_t added;
+	int ret = 0;
+
+	/*
+	 *  Total bytes to add is hdr byte count and these bytes
+	 *   - First byte (mctp message type 0xf)
+	 *   - Byte count
+	 *   - PEC byte
+	 */
+	bytes = mctp_data->buf[BUF_BYTE_CNT] + 3;
+	stats.mctp_rx_bytes += bytes;
+	mctp_rx_msg_size += bytes;
+
+	if (kfifo_avail(&mctp_device.rx_fifo) < bytes) {
+		kfifo_reset(&mctp_device.rx_fifo);
+		stats.ctrl_rxfifo_full_reset++;
+	}
+
+	added = kfifo_in_spinlocked(&mctp_device.rx_fifo,
+				    mctp_data->buf,
+				    bytes,
+				    &mctp_device.rx_fifo_spinlock);
+
+	if (added != bytes) {
+		kfifo_reset(&mctp_device.rx_fifo);
+		stats.ctrl_rxfifo_error_reset++;
+		dev_info(&client->dev, "error adding data to mctp rx_fifo\n");
+		added = 0;
+		ret = -1;
+	}
+	if (kfifo_len(&mctp_device.rx_fifo) > stats.ctrl_rxfifo_max_bytes)
+		stats.ctrl_rxfifo_max_bytes = kfifo_len(&mctp_device.rx_fifo);
+	dev_dbg(&client->dev, "added %d bytes to mctp rx fifo\n", added);
+
+	if (added)
+		wake_up_poll(&mctp_device.fifo_proc_list, POLLIN);
+
+	return ret;
+}
+
+static int add_to_ncsi_rx_fifo(struct mctp_data *mctp_data)
+{
+	struct i2c_client *client = get_i2c_dw_mctp();
+	uint32_t bytes;
+	uint32_t added;
+	int ret = 0;
+
+	/*
+	 * Total bytes to add is hdr byte count and these bytes
+	 *   - First byte (mctp message type 0xf)
+	 *   - Byte count
+	 *   - PEC byte
+	 */
+	bytes = mctp_data->buf[BUF_BYTE_CNT] + 3;
+	stats.mctp_rx_bytes += bytes;
+	mctp_rx_msg_size += bytes;
+
+	if (kfifo_avail(&ncsi_device.rx_fifo) < bytes) {
+		kfifo_reset(&ncsi_device.rx_fifo);
+		stats.ncsi_rxfifo_full_reset++;
+	}
+
+	added = kfifo_in_spinlocked(&ncsi_device.rx_fifo,
+				    mctp_data->buf,
+				    bytes,
+				    &ncsi_device.rx_fifo_spinlock);
+
+	if (added != bytes) {
+		kfifo_reset(&ncsi_device.rx_fifo);
+		stats.ncsi_rxfifo_error_reset++;
+		dev_info(&client->dev, "error adding data to ncsi rx_fifo\n");
+		added = 0;
+		ret = -1;
+	}
+	if (kfifo_len(&ncsi_device.rx_fifo) > stats.ncsi_rxfifo_max_bytes)
+		stats.ncsi_rxfifo_max_bytes = kfifo_len(&ncsi_device.rx_fifo);
+	dev_dbg(&client->dev, "added %d bytes to ncsi rx fifo\n", added);
+
+	if (added)
+		wake_up_poll(&ncsi_device.fifo_proc_list, POLLIN);
+
+	return ret;
+}
+
+static int add_to_pldm_rx_fifo(struct mctp_data *mctp_data)
+{
+	struct i2c_client *client = get_i2c_dw_mctp();
+	uint32_t bytes;
+	uint32_t added;
+	int ret = 0;
+
+	/*
+	 * Total bytes to add is hdr byte count and these bytes
+	 *   - First byte (mctp message type 0xf)
+	 *   - Byte count
+	 *   - PEC byte
+	 */
+	bytes = mctp_data->buf[BUF_BYTE_CNT] + 3;
+	stats.mctp_rx_bytes += bytes;
+	mctp_rx_msg_size += bytes;
+
+	if (kfifo_avail(&pldm_device.rx_fifo) < bytes) {
+		kfifo_reset(&pldm_device.rx_fifo);
+		stats.pldm_rxfifo_full_reset++;
+	}
+
+	added = kfifo_in_spinlocked(&pldm_device.rx_fifo,
+				    mctp_data->buf,
+				    bytes,
+				    &pldm_device.rx_fifo_spinlock);
+
+	if (added != bytes) {
+		kfifo_reset(&pldm_device.rx_fifo);
+		stats.pldm_rxfifo_error_reset++;
+		dev_info(&client->dev, "error adding data to pldm rx_fifo\n");
+		added = 0;
+		ret = -1;
+	}
+	if (kfifo_len(&pldm_device.rx_fifo) > stats.pldm_rxfifo_max_bytes)
+		stats.pldm_rxfifo_max_bytes = kfifo_len(&pldm_device.rx_fifo);
+	dev_dbg(&client->dev, "added %d bytes to pldm rx fifo\n", added);
+
+	if (added)
+		wake_up_poll(&pldm_device.fifo_proc_list, POLLIN);
+
+	return ret;
+}
+
+static void update_addr(struct work_struct *work)
+{
+	struct mctp_data *mctp_data =
+		container_of(work, struct mctp_data, update_addr);
+	struct i2c_client *client = get_i2c_dw_mctp();
+
+	/* Apply new slave address */
+	dev_info(&client->dev, "apply slave addr 0x%02x\n",
+		 mctp_data->slave_addr);
+
+	/*
+	 * User processes should only respond to bus owner requests.  Even so,
+	 * taking the device locks when updating the slave address.  The bus
+	 * owner will not do general or directed reset while waiting for
+	 * an outstanding response.  This code path will only be taken when
+	 * Naples is in slave mode and receives a smbus arp command.
+	 */
+	mutex_lock(&mctp_device.tx_lock);
+	mutex_lock(&mctp_device.dev_lock);
+	mutex_lock(&ncsi_device.dev_lock);
+	mutex_lock(&pldm_device.dev_lock);
+	dw_update_slave_addr();
+	mutex_unlock(&mctp_device.tx_lock);
+	mutex_unlock(&mctp_device.dev_lock);
+	mutex_unlock(&ncsi_device.dev_lock);
+	mutex_unlock(&pldm_device.dev_lock);
+
+	mctp_data->arp_complete = true;
+	mctp_data->mctp_discovery_started = false;
+	mctp_data->smbus_address_resolved = true;
+	mctp_data->smbus_address_valid = true;
+
+	dev_info(&client->dev, "smbus addr 0x%02x valid\n",
+		 mctp_data->slave_addr);
+	dev_info(&client->dev, "smbus addr 0x%02x resolved\n",
+		 mctp_data->slave_addr);
+}
+
+/* Receive work for each MCTP packet */
+static void rx_packet(struct work_struct *work)
+{
+	struct mctp_data *mctp_data =
+		container_of(work, struct mctp_data, rx_packet);
+	struct i2c_client *client = get_i2c_dw_mctp();
+	uint8_t hdr_flags = mctp_data->buf[BUF_MCTP_FLAGS];
+	uint8_t msg_type = mctp_data->buf[BUF_MSG_TYPE];
+	int ret = 0;
+
+	/*
+	 * Message type is set in the message header of the first packet
+	 * for a multi-packet mctp message.  The message active flag
+	 * is used to put packets without SOM set into the correct fifo.
+	 */
+	in_progress = true;
+	if (hdr_flags & MCTP_HDR_FLAG_SOM) {
+		mctp_rx_msg_size = 0;
+
+		switch (msg_type) {
+		case MSG_TYPE_MCTP_CONTROL_MSG:
+			mctp_data->mctp_discovery_started = true;
+			ctrl_msg_active = true;
+			stats.mctp_ctrl_msg++;
+			ctrl_timer_start();
+			ret = add_to_mctp_rx_fifo(mctp_data);
+			break;
+
+		case MSG_TYPE_PLDM_MSG:
+			pldm_msg_active = true;
+			stats.mctp_pldm_msg++;
+			pldm_timer_start();
+			ret = add_to_pldm_rx_fifo(mctp_data);
+			break;
+
+		case MSG_TYPE_NCSI_OVER_MCTP_MSG:
+			ncsi_msg_active = true;
+			stats.mctp_ncsi_msg++;
+			ncsi_timer_start();
+			ret = add_to_ncsi_rx_fifo(mctp_data);
+			break;
+
+		case MSG_TYPE_ETH_OVER_MCTP_MSG:
+			stats.mctp_ethernet_msg++;
+			ret = mctp_cmd_not_supported(mctp_data);
+			break;
+
+		case MSG_TYPE_VENDOR_PCI_MSG:
+			stats.mctp_vendor_pci_msg++;
+			ret = mctp_cmd_not_supported(mctp_data);
+			break;
+
+		case MSG_TYPE_VENDOR_IANA_MSG:
+			stats.mctp_vendor_iana_msg++;
+			ret = mctp_cmd_not_supported(mctp_data);
+			break;
+
+		default:
+			ret = mctp_cmd_not_supported(mctp_data);
+		}
+	} else {
+		/* Control messages are single packet with SOM set */
+		if (pldm_msg_active)
+			ret = add_to_pldm_rx_fifo(mctp_data);
+
+		if (ncsi_msg_active)
+			ret = add_to_ncsi_rx_fifo(mctp_data);
+	}
+
+	if (ret)
+		pr_err("mctp cmd %d failed (%d)\n", msg_type, ret);
+	else
+		stats.mctp_rx_pkts++;
+
+	if ((ret == 0) && hdr_flags & MCTP_HDR_FLAG_EOM)
+		update_rx_stats(mctp_rx_msg_size);
+	else
+		dev_info(&client->dev, "rx pkt EOM not set\n");
+	in_progress = false;
+}
+
+#define mctp_show_simple(field, name, format_string, cast)                 \
+static ssize_t                                                             \
+show_##name(struct device *dev, struct device_attribute *attr, char *buf)  \
+{                                                                          \
+	struct i2c_client *client = to_i2c_client(dev);                    \
+	struct mctp_data *mctp_data = i2c_get_clientdata(client);          \
+									   \
+	return snprintf(buf, 20, format_string, cast mctp_data->field);    \
+}
+
+#define mctp_store_simple(field, name, base)                         \
+static ssize_t                                                       \
+store_##name(struct device *dev, struct device_attribute *attr,      \
+	     const char *buf, size_t count)                          \
+{                                                                    \
+	struct i2c_client *client = to_i2c_client(dev);              \
+	struct mctp_data *mctp_data = i2c_get_clientdata(client);    \
+	int ret;                                                     \
+								     \
+	ret = kstrtou16(buf, 0, &mctp_data->field);                  \
+	return ret ? ret : count;                                    \
+}
+
+#define mctp_attr_show(field, name, format_string, type)         \
+	mctp_show_simple(field, name, format_string, (type))     \
+static DEVICE_ATTR(name, 0444, show_##name, NULL)
+
+#define mctp_attr_rw(field, name, format_string, type)           \
+	mctp_show_simple(field, name, format_string, (type))     \
+	mctp_store_simple(field, name, 10)                       \
+static DEVICE_ATTR(name, 0644, show_##name, store_##name)
+
+mctp_attr_show(assigned_eid, assigned_eid, "0x%x\n", u8);
+mctp_attr_show(slave_addr, slave_addr, "0x%x\n", u8);
+
+mctp_attr_rw(pcie_vendorid, pcie_vendorid, "0x%x\n", u16);
+mctp_attr_rw(pcie_deviceid, pcie_deviceid, "0x%x\n", u16);
+mctp_attr_rw(pcie_subvendorid, pcie_subvendorid, "0x%x\n", u16);
+mctp_attr_rw(pcie_subdeviceid, pcie_subdeviceid, "0x%x\n", u16);
+
+static struct attribute *mctp_attrs[] = {
+	&dev_attr_assigned_eid.attr,
+	&dev_attr_slave_addr.attr,
+	&dev_attr_pcie_vendorid.attr,
+	&dev_attr_pcie_deviceid.attr,
+	&dev_attr_pcie_subvendorid.attr,
+	&dev_attr_pcie_subdeviceid.attr,
+	NULL,
+};
+
+static const struct attribute_group mctp_attr_group = {
+	.attrs = mctp_attrs,
+};
+
+
+static void smbus_arp(struct mctp_data *mctp_data)
+{
+	uint8_t smbus_cmd = mctp_data->buf[0];
+	struct i2c_client *client = get_i2c_dw_mctp();
+
+	switch (smbus_cmd) {
+	case ARP_PREPARE:
+		// - Clear AR flag
+		// - Cancel pending Notify ARP Master commands
+		// - Retries are recommended
+		dev_info(&client->dev, "ARP: PREPARE TO ARP, cleared AR\n");
+		mctp_data->smbus_arp_state = ARP_PREPARE;
+		mctp_data->smbus_address_resolved = false;
+		break;
+
+	case ARP_RESET_DEV:
+		// - Clear AR and AV flag
+		// - DSA devices must assume default slave address and clear
+		//   AR flag
+		// - ARP capable device with random number as part of UDID must
+		//   regenerate the random number
+		// - What about PEC byte, not seeing it?
+		dev_info(&client->dev, "ARP: RESET DEVICE, cleared AR/AV\n");
+		mctp_data->smbus_arp_state = ARP_RESET_DEV;
+		mctp_data->smbus_address_resolved = false;
+		mctp_data->smbus_address_valid = false;
+		break;
+
+	case ARP_GET_UDID_GENERAL:
+		// - ARP capable devices return slave address and UDID
+		dev_info(&client->dev, "ARP: Get UDID General\n");
+		mctp_data->smbus_arp_state = ARP_GET_UDID_GENERAL;
+		break;
+
+	case ARP_ASSIGN_ADDR:
+		// - If UDID match process
+		// - Once a UDID bit/byte mismatch NACK
+		// - Slave that matches entire UDID immedietly adopt the new
+		//   slave address.  Bit 0 of assigned address field ignored.
+		dev_info(&client->dev, "ARP: Assign Address\n");
+		mctp_data->smbus_arp_state = ARP_ASSIGN_ADDR;
+		break;
+	}
+}
+
+static int i2c_dw_mctp_slave_cb(struct i2c_client *client,
+	enum i2c_slave_event event, u8 *val)
+{
+	struct mctp_data *mctp_data = i2c_get_clientdata(client);
+	static uint8_t udid[19];  // count + 16 byte udid + addr + pec
+	static uint8_t udid_idx;
+	static bool update_slaveaddr;
+
+	switch (event) {
+	case I2C_SLAVE_WRITE_RECEIVED:
+		//dev_info(&client->dev,"write: 0x%02x\n", *val);
+		if (mctp_data->first_write) {
+			mctp_data->buf_idx = 0;
+			mctp_data->first_write = false;
+			if (mctp_data->buf_idx < MAX_IDX)
+				mctp_data->buf[mctp_data->buf_idx++] = *val;
+			else
+				dev_info(&client->dev, "buf_idx %d val 0x%x\n",
+					 mctp_data->buf_idx, *val);
+			udid_idx = 0;
+
+			if (!mctp_data->smbus_address_resolved) {
+				dev_info(&client->dev,
+					 "smbus addr not resolved\n");
+				get_udid_data(udid);
+				smbus_arp(mctp_data);
+			}
+		} else {
+			if (mctp_data->buf_idx < MAX_IDX) {
+				mctp_data->buf[mctp_data->buf_idx++] = *val;
+			} else {
+				// Missed stop
+				mctp_data->buf[BUF_CMD_CODE] = 0;
+				dev_info(&client->dev, "buf_idx %d val 0x%x\n",
+					 mctp_data->buf_idx, *val);
+			}
+		}
+
+		/* Send complete mctp message to the workqueue */
+		if (mctp_data->buf[BUF_CMD_CODE] == MCTP_CMD &&
+		    mctp_data->buf_idx == mctp_data->buf[BUF_BYTE_CNT] + 3 &&
+		    mctp_data->buf_idx > MCTP_HDR_SIZE) {
+			if (in_progress)
+				dev_info(&client->dev, "rx in progress\n");
+			else
+				schedule_work(&mctp_data->rx_packet);
+		}
+		break;
+
+	case I2C_SLAVE_READ_PROCESSED:
+		/* The previous byte made it to the bus, get next one */
+		if (mctp_data->buf_idx < MAX_IDX)
+			mctp_data->buf_idx++;
+		else
+			dev_info(&client->dev, "read buf_idx %d\n",
+				 mctp_data->buf_idx);
+		fallthrough;
+	case I2C_SLAVE_READ_REQUESTED:
+		if (mctp_data->smbus_arp_state == ARP_GET_UDID_GENERAL) {
+			*val = udid[udid_idx];
+			dev_info(&client->dev, "read udid[%d] = 0x%02x\n",
+				 udid_idx, udid[udid_idx]);
+
+			if (udid_idx == 18) {
+				mctp_data->slave_addr = MCTP_DEFAULT_FIXED_ADDR;
+				update_slaveaddr = true;
+				arp_timer_start();
+			}
+			if (udid_idx < sizeof(struct smbus_udid))
+				udid_idx++;
+			else
+				dev_info(&client->dev, "udid_idx %d\n",
+					 udid_idx);
+		}
+		/*
+		 * Do not increment buf_idx here, because we don't know if
+		 * this byte will be actually used. Read Linux I2C slave docs
+		 * for details.
+		 */
+		break;
+
+	case I2C_SLAVE_STOP:
+	case I2C_SLAVE_WRITE_REQUESTED:
+		mctp_data->first_write = true;
+		if (update_slaveaddr) {
+			update_slaveaddr = false;
+
+			/* 7-bit addr applied by the dw slave config */
+			client->addr = (mctp_data->slave_addr >> 1);
+
+			/* Slave addr update takes effect in update_addr() */
+			schedule_work(&mctp_data->update_addr);
+		}
+		break;
+
+	default:
+		dev_dbg(&client->dev, "slave cb default\n");
+		break;
+	}
+
+	return 0;
+}
+
+static int mctp_open(struct inode *inode, struct file *filp)
+{
+	mutex_lock(&mctp_device.dev_lock);
+	mctp_device.open_count++;
+	mutex_unlock(&mctp_device.dev_lock);
+
+	return 0;
+}
+
+static int ncsi_open(struct inode *inode, struct file *filp)
+{
+	mutex_lock(&ncsi_device.dev_lock);
+	ncsi_device.open_count++;
+	mutex_unlock(&ncsi_device.dev_lock);
+
+	return 0;
+}
+
+static int pldm_open(struct inode *inode, struct file *filp)
+{
+	mutex_lock(&pldm_device.dev_lock);
+	pldm_device.open_count++;
+	mutex_unlock(&pldm_device.dev_lock);
+
+	return 0;
+}
+
+static ssize_t mctp_read(struct file *file, char __user *buf,
+			 size_t count, loff_t *ppos)
+{
+	uint32_t copied;
+	ssize_t ret;
+
+	if ((kfifo_len(&mctp_device.rx_fifo) == 0) &&
+	    (file->f_flags & O_NONBLOCK)) {
+		return -EAGAIN;
+	}
+
+	if (mutex_lock_interruptible(&mctp_device.dev_lock))
+		return -ERESTARTSYS;
+
+	ret = kfifo_to_user(&mctp_device.rx_fifo, buf, count, &copied);
+	stats.ctrl_rx_bytes += copied;
+	mutex_unlock(&mctp_device.dev_lock);
+
+	return ret ? ret : copied;
+}
+
+static uint32_t mctp_poll(struct file *fp, poll_table *wait)
+{
+	int len;
+
+	poll_wait(fp, &mctp_device.fifo_proc_list, wait);
+
+	len = kfifo_len(&mctp_device.rx_fifo);
+	if (len)
+		return POLLIN | POLLRDNORM;    /* fd is readable */
+
+	return 0;
+}
+
+static ssize_t mctp_write(struct file *file, const char __user *buf,
+			  size_t count, loff_t *ppos)
+{
+	struct i2c_client *client = get_i2c_dw_mctp();
+
+	if ((count < MCTP_HDR_SIZE) || (count > MCTP_BUF_SIZE)) {
+		dev_info(&client->dev, "mctp write EMSGSIZE %lu\n", count);
+		return -EMSGSIZE;
+	}
+
+	if (mutex_lock_interruptible(&mctp_device.tx_lock)) {
+		dev_info(&client->dev, "mctp write ERESTARTSYS\n");
+		return -ERESTARTSYS;
+	}
+
+	if (copy_from_user(mctp_data.buf, buf, count)) {
+		dev_info(&client->dev, "mctp write EFAULT\n");
+		return -EFAULT;
+	}
+
+	if (ctrl_msg_active) {
+		stats.ctrl_tx_bytes += count;
+		stats.mctp_tx_bytes += count;
+		if (count > stats.mctp_txfifo_max_bytes)
+			stats.mctp_txfifo_max_bytes = count;
+
+		tx_packet(count);
+
+		/* mctp rx fifo is being read */
+		squelch_ctrl_not_read_log = false;
+		ctrl_timer_count = 0;
+	}
+
+	mutex_unlock(&mctp_device.tx_lock);
+
+	return count;
+}
+
+static ssize_t ncsi_read(struct file *file, char __user *buf,
+			 size_t count, loff_t *ppos)
+{
+	uint32_t copied;
+	ssize_t ret;
+
+	if ((kfifo_len(&ncsi_device.rx_fifo) == 0) &&
+	    (file->f_flags & O_NONBLOCK)) {
+		return -EAGAIN;
+	}
+
+	if (mutex_lock_interruptible(&ncsi_device.dev_lock))
+		return -ERESTARTSYS;
+
+	ret = kfifo_to_user(&ncsi_device.rx_fifo, buf, count, &copied);
+	stats.ncsi_rx_bytes += copied;
+	mutex_unlock(&ncsi_device.dev_lock);
+
+	return ret ? ret : copied;
+}
+
+static uint32_t ncsi_poll(struct file *fp, poll_table *wait)
+{
+	int len;
+
+	poll_wait(fp, &ncsi_device.fifo_proc_list, wait);
+
+	len = kfifo_len(&ncsi_device.rx_fifo);
+	if (len)
+		return POLLIN | POLLRDNORM;    /* fd is readable */
+
+	return 0;
+}
+
+static ssize_t ncsi_write(struct file *file, const char __user *buf,
+			  size_t count, loff_t *ppos)
+{
+	struct i2c_client *client = get_i2c_dw_mctp();
+
+	if ((count < MCTP_HDR_SIZE) || (count > MCTP_BUF_SIZE)) {
+		dev_info(&client->dev, "ncsi write EMSGSIZE %lu\n", count);
+		return -EMSGSIZE;
+	}
+
+	if (mutex_lock_interruptible(&mctp_device.tx_lock)) {
+		dev_info(&client->dev, "ncsi write ERESTARTSYS\n");
+		return -ERESTARTSYS;
+	}
+
+	if (copy_from_user(mctp_data.buf, buf, count)) {
+		dev_info(&client->dev, "ncsi write EFAULT\n");
+		return -EFAULT;
+	}
+
+	if (ncsi_msg_active) {
+		stats.ncsi_tx_bytes += count;
+		stats.mctp_tx_bytes += count;
+		if (count > stats.mctp_txfifo_max_bytes)
+			stats.mctp_txfifo_max_bytes = count;
+
+		tx_packet(count);
+
+		/* ncsi rx fifo is being read */
+		squelch_ncsi_not_read_log = false;
+		ncsi_timer_count = 0;
+	}
+
+	mutex_unlock(&mctp_device.tx_lock);
+
+	return count;
+}
+
+static ssize_t pldm_read(struct file *file, char __user *buf,
+			 size_t count, loff_t *ppos)
+{
+	uint32_t copied;
+	ssize_t ret;
+
+	if ((kfifo_len(&pldm_device.rx_fifo) == 0) &&
+	    (file->f_flags & O_NONBLOCK)) {
+		return -EAGAIN;
+	}
+
+	if (mutex_lock_interruptible(&pldm_device.dev_lock))
+		return -ERESTARTSYS;
+
+	ret = kfifo_to_user(&pldm_device.rx_fifo, buf, count, &copied);
+	stats.pldm_rx_bytes += copied;
+	mutex_unlock(&pldm_device.dev_lock);
+
+	return ret ? ret : copied;
+}
+
+static uint32_t pldm_poll(struct file *fp, poll_table *wait)
+{
+	int len;
+
+	poll_wait(fp, &pldm_device.fifo_proc_list, wait);
+
+	len = kfifo_len(&pldm_device.rx_fifo);
+	if (len)
+		return POLLIN | POLLRDNORM;    /* fd is readable */
+
+	return 0;
+}
+
+static ssize_t pldm_write(struct file *file, const char __user *buf,
+			  size_t count, loff_t *ppos)
+{
+	struct i2c_client *client = get_i2c_dw_mctp();
+
+	if ((count < MCTP_HDR_SIZE) || (count > MCTP_BUF_SIZE)) {
+		dev_info(&client->dev, "pldm write EMSGSIZE %lu\n", count);
+		return -EMSGSIZE;
+	}
+
+	if (mutex_lock_interruptible(&mctp_device.tx_lock)) {
+		dev_info(&client->dev, "pldm write ERESTARTSYS\n");
+		return -ERESTARTSYS;
+	}
+
+	if (copy_from_user(mctp_data.buf, buf, count)) {
+		dev_info(&client->dev, "pldm write EFAULT\n");
+		return -EFAULT;
+	}
+
+	if (pldm_msg_active) {
+		stats.pldm_tx_bytes += count;
+		stats.mctp_tx_bytes += count;
+		if (count > stats.mctp_txfifo_max_bytes)
+			stats.mctp_txfifo_max_bytes = count;
+
+		tx_packet(count);
+
+		/* pldm rx fifo is being read */
+		squelch_pldm_not_read_log = false;
+		pldm_timer_count = 0;
+	}
+
+	mutex_unlock(&mctp_device.tx_lock);
+
+	return count;
+}
+
+static int mctp_release(struct inode *inode, struct file *file)
+{
+	mutex_lock(&mctp_device.dev_lock);
+	mctp_device.open_count--;
+	mutex_unlock(&mctp_device.dev_lock);
+
+	return 0;
+}
+
+static int ncsi_release(struct inode *inode, struct file *file)
+{
+	mutex_lock(&ncsi_device.dev_lock);
+	ncsi_device.open_count--;
+	mutex_unlock(&ncsi_device.dev_lock);
+
+	return 0;
+}
+
+static int pldm_release(struct inode *inode, struct file *file)
+{
+	mutex_lock(&pldm_device.dev_lock);
+	pldm_device.open_count--;
+	mutex_unlock(&pldm_device.dev_lock);
+
+	return 0;
+}
+
+static void response_timing(struct mctp_data *mctp_data)
+{
+	struct i2c_client *client = get_i2c_dw_mctp();
+	s64 dt_usec;
+
+	if (ctrl_msg_active) {
+		dt_usec = ktime_to_ns(ktime_sub(ktime_get(), ctrl_start)) /
+			  USEC_TO_NSEC;
+
+		if (dt_usec > stats.ctrl_max_latency_usec)
+			stats.ctrl_max_latency_usec = dt_usec;
+
+		ctrl_dt_usec_sum += dt_usec;
+
+		stats.ctrl_avg_latency_usec =
+			ctrl_dt_usec_sum/stats.mctp_ctrl_msg;
+
+		dev_dbg(&client->dev, "ctrl msg lat %lld avg %u max %u usec\n",
+			dt_usec, stats.ctrl_avg_latency_usec,
+			stats.ctrl_max_latency_usec);
+
+	} else if (pldm_msg_active) {
+		dt_usec = ktime_to_ns(ktime_sub(ktime_get(), pldm_start)) /
+			  USEC_TO_NSEC;
+
+		if (dt_usec > stats.pldm_max_latency_usec)
+			stats.pldm_max_latency_usec = dt_usec;
+
+		pldm_dt_usec_sum += dt_usec;
+
+		stats.pldm_avg_latency_usec =
+			pldm_dt_usec_sum/stats.mctp_pldm_msg;
+
+		dev_dbg(&client->dev, "pldm msg lat %lld avg %u max %u usec\n",
+			dt_usec, stats.pldm_avg_latency_usec,
+			stats.pldm_max_latency_usec);
+
+	} else if (ncsi_msg_active) {
+		dt_usec = ktime_to_ns(ktime_sub(ktime_get(), ncsi_start)) /
+			  USEC_TO_NSEC;
+
+		if (dt_usec > stats.ncsi_max_latency_usec)
+			stats.ncsi_max_latency_usec = dt_usec;
+
+		ncsi_dt_usec_sum += dt_usec;
+
+		stats.ncsi_avg_latency_usec =
+			ncsi_dt_usec_sum/stats.mctp_ncsi_msg;
+
+		dev_dbg(&client->dev, "ncsi msg lat %lld avg %u max %u usec\n",
+			dt_usec, stats.ncsi_avg_latency_usec,
+			stats.ncsi_max_latency_usec);
+	}
+}
+
+/* Transmit work for each MCTP packet */
+static void tx_packet(int count)
+{
+	struct i2c_client *client = get_i2c_dw_mctp();
+	uint8_t hdr_flags;
+	struct i2c_msg msg;
+	int rc;
+
+	/*
+	 * The first byte in the FIFO is the 8-bit destination slave address.
+	 * Pass to i2c_transfer in 7-bit form and point the i2c_transfer
+	 * buffer at the second byte.
+	 */
+	msg.addr = (mctp_data.buf[0] >> 1);
+	msg.buf = (uint8_t *) mctp_data.buf + 1;
+	msg.len = count - 1;
+	msg.flags = 0;
+
+	i2c_smbus_add_pec(&msg);    // increments len
+
+	log_msg(msg.buf, count, "USER: send", MCTP_RESP_PKT);
+
+	hdr_flags = *(msg.buf + BUF_MCTP_FLAGS);
+	if (hdr_flags & MCTP_HDR_FLAG_SOM) {
+		rc = dw_enable_master();
+		dw_master = true;
+		if (rc) {
+			dev_warn(&client->dev, "tx dw_enable_master %d\n", rc);
+			return;
+		}
+	}
+
+	rc = i2c_transfer(i2c_mctp_adap, &msg, 1);
+	if (rc == 1) {
+		stats.i2c_transfer_success++;
+		stats.mctp_tx_pkts++;
+
+		if ((hdr_flags & MCTP_HDR_FLAG_SOM) &&
+		    (hdr_flags & MCTP_HDR_FLAG_EOM)) {
+
+			/* single packet message */
+			mctp_tx_msg_size = count;
+			update_tx_stats(mctp_tx_msg_size);
+			response_timing(&mctp_data);
+
+		} else if (hdr_flags & MCTP_HDR_FLAG_SOM) {
+
+			/* start of a new message */
+			mctp_tx_msg_size = count;
+
+		} else if (hdr_flags & MCTP_HDR_FLAG_EOM) {
+
+			/* end of multi-packet message */
+			mctp_tx_msg_size += count;
+			update_tx_stats(mctp_tx_msg_size);
+			response_timing(&mctp_data);
+
+		} else {
+
+			/* neither som or eom set */
+			mctp_tx_msg_size += count;
+		}
+	} else {
+		stats.i2c_transfer_error++;
+		dev_info(&client->dev, "i2c transfer error %d\n", rc);
+	}
+
+	if (hdr_flags & MCTP_HDR_FLAG_EOM) {
+		ctrl_msg_active = false;
+		ncsi_msg_active = false;
+		pldm_msg_active = false;
+
+		/* ok for active and inactive timers */
+		del_timer(&ctrl_timer);
+		del_timer(&ncsi_timer);
+		del_timer(&pldm_timer);
+
+		rc = dw_enable_slave();
+		if (rc)
+			dev_info(&client->dev, "tx dw_enable_slave - %d\n", rc);
+		dw_master = false;
+	}
+}
+
+static long mctp_info_cmd(struct file *file, void __user *arg)
+{
+	struct mctp_statistics *mctp_stats;
+
+	if (!capable(CAP_SYS_ADMIN))
+		return -EPERM;
+
+	mctp_stats = memdup_user(arg, sizeof(struct mctp_statistics));
+	if (IS_ERR(mctp_stats))
+		return -EFAULT;
+
+	memcpy(mctp_stats, &stats, sizeof(struct mctp_statistics));
+
+	if (copy_to_user(arg, mctp_stats, sizeof(struct mctp_statistics))) {
+		kfree(mctp_stats);
+		return -EFAULT;
+	}
+	kfree(mctp_stats);
+
+	return 0;
+}
+
+/*
+ * mctp_ioctl - IOCTL for mctp endpoint control/status
+ * @file: file this ioctl is called on
+ * @cmd: ioctl cmd number
+ * @arg: user argument
+ *
+ * Returns:
+ * Zero on success, negative error code on failure.
+ */
+static long mctp_ioctl(struct file *file, uint cmd, unsigned long arg)
+{
+	void __user *argp = (void __user *)arg;
+	struct i2c_client *client = get_i2c_dw_mctp();
+	struct mctp_data *mctp_data = i2c_get_clientdata(client);
+	u32 eid;
+	u32 addr;
+	int rc = 0;
+
+	if (!argp)
+		return -EINVAL;
+
+	switch (cmd) {
+	case SLAVE_RESET:
+		dev_info(&client->dev, "ioctl i2c reset\n");
+		reset_all_fifos();
+		rc = dw_enable_master();
+		if (rc) {
+			dev_info(&client->dev, "reset dw_enable_master - %d\n",
+				 rc);
+		}
+		rc = dw_enable_slave();
+		if (rc) {
+			dev_info(&client->dev, "reset dw_enable_slave - %d\n",
+				 rc);
+		}
+		stats.slave_reset++;
+		break;
+
+	case SET_EID:
+		if (copy_from_user(&eid, argp, sizeof(u32)))
+			return -EFAULT;
+		mctp_data->assigned_eid = (u8) eid;
+		break;
+
+	case GET_EID:
+		eid = (u32) mctp_data->assigned_eid;
+		if (copy_to_user(argp, &eid, sizeof(u32)))
+			return -EFAULT;
+		break;
+
+	case SLAVE_ADDR:
+		addr = (u32) mctp_data->slave_addr;
+		if (copy_to_user(argp, &addr, sizeof(u32)))
+			return -EFAULT;
+		break;
+
+	case ARP_RESET:
+		dev_info(&client->dev, "smbus av/ar flags cleared\n");
+		mctp_data->arp_complete = false;
+		mctp_data->mctp_discovery_started = false;
+		mctp_data->smbus_address_valid = false;
+		mctp_data->smbus_address_resolved = false;
+
+		dev_info(&client->dev, "smbus slave address 0xc2\n");
+		mctp_data->slave_addr = SMBUS_DEFAULT_ADDR;
+		client->addr = (SMBUS_DEFAULT_ADDR >> 1);
+
+		/* Disruptive action, reset */
+		reset_all_fifos();
+		rc = dw_enable_master();
+		if (rc) {
+			dev_warn(&client->dev, "arp dw_enable_master %d\n",
+				 rc);
+		}
+		rc = dw_enable_slave();
+		if (rc) {
+			dev_info(&client->dev, "arp dw_enable_slave %d\n",
+				 rc);
+		}
+		stats.arp_reset++;
+		break;
+
+	case MCTP_INFO:
+		rc = mctp_info_cmd(file, argp);
+		break;
+
+	default:
+		return -ENOIOCTLCMD;
+	}
+
+	return rc;
+}
+
+static const struct file_operations mctp_misc_fops = {
+	.owner =   THIS_MODULE,
+	.open =    mctp_open,
+	.read =    mctp_read,
+	.poll =    mctp_poll,
+	.write =   mctp_write,
+	.release = mctp_release,
+	.unlocked_ioctl = mctp_ioctl,
+};
+
+static struct miscdevice mctp_miscdev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "mctp",
+	.fops = &mctp_misc_fops
+};
+
+static const struct file_operations ncsi_misc_fops = {
+	.owner =   THIS_MODULE,
+	.open =    ncsi_open,
+	.read =    ncsi_read,
+	.poll =    ncsi_poll,
+	.write =   ncsi_write,
+	.release = ncsi_release,
+};
+
+static struct miscdevice ncsi_miscdev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "ncsi",
+	.fops = &ncsi_misc_fops
+};
+
+static const struct file_operations pldm_misc_fops = {
+	.owner =   THIS_MODULE,
+	.open =    pldm_open,
+	.read =    pldm_read,
+	.poll =    pldm_poll,
+	.write =   pldm_write,
+	.release = pldm_release,
+};
+
+static struct miscdevice pldm_miscdev = {
+	.minor = MISC_DYNAMIC_MINOR,
+	.name = "pldm",
+	.fops = &pldm_misc_fops
+};
+
+static int i2c_dw_mctp_probe(struct i2c_client *client,
+	const struct i2c_device_id *id)
+{
+	struct mctp_data *mctp_data;
+	int ret;
+
+	mctp_data = devm_kzalloc(&client->dev, sizeof(struct mctp_data),
+				 GFP_KERNEL);
+	if (!mctp_data)
+		return -ENOMEM;
+
+	memset(&stats, 0, sizeof(stats));
+
+	i2c_mctp_adap = client->adapter;
+
+	mctp_data->first_write = true;
+	mctp_data->buf_idx = 0;
+
+	i2c_set_clientdata(client, mctp_data);
+
+	ret = sysfs_create_group(&client->dev.kobj, &mctp_attr_group);
+	if (ret) {
+		dev_err(&client->dev, "failed to create sysfs files\n");
+		return ret;
+	}
+
+	mctp_data->slave_addr = MCTP_DEFAULT_FIXED_ADDR;
+	mctp_data->smbus_address_valid = true;
+	mctp_data->smbus_address_resolved = true;
+	dev_info(&client->dev, "slave address 0x%02x\n", mctp_data->slave_addr);
+
+	/* mctpd accesses naples catalog to override these via sysfs */
+	mctp_data->pcie_vendorid = 0x1dd8;
+	mctp_data->pcie_deviceid = 0x1002;
+	mctp_data->pcie_subvendorid = 0x1dd8;
+	mctp_data->pcie_subdeviceid = 0x4007;
+
+	dev_info(&client->dev, "default vendorid 0x%02x\n",
+		 mctp_data->pcie_vendorid);
+	dev_info(&client->dev, "default deviceid 0x%02x\n",
+		 mctp_data->pcie_deviceid);
+	dev_info(&client->dev, "default subvendorid 0x%02x\n",
+		 mctp_data->pcie_subvendorid);
+	dev_info(&client->dev, "default subdeviceid 0x%02x\n",
+		 mctp_data->pcie_subdeviceid);
+
+	/* Create workqueues messages and device control */
+	INIT_WORK(&mctp_data->rx_packet, rx_packet);     /* host send */
+	INIT_WORK(&mctp_data->update_addr, update_addr); /* slave addr update */
+	INIT_WORK(&mctp_data->arp_reset, arp_reset);     /* reset to default */
+	INIT_WORK(&mctp_data->reset, reset);             /* reset to slave */
+
+	/* Response latency measurement and i2c bus collision avoidance */
+	timer_setup(&ctrl_timer, ctrl_timer_expired, 0);
+	timer_setup(&ncsi_timer, ncsi_timer_expired, 0);
+	timer_setup(&pldm_timer, pldm_timer_expired, 0);
+
+	/* Check the bus owner started MCTP discovery after ARP complete */
+	timer_setup(&arp_timer, arp_timer_expired, 0);
+
+	/* Init userspace mctp device access */
+	spin_lock_init(&mctp_device.rx_fifo_spinlock);
+
+	ret = kfifo_alloc(&mctp_device.rx_fifo, MCTP_FIFO_DEPTH, GFP_KERNEL);
+	if (ret) {
+		dev_err(&client->dev, "failed to allocate mctp rx fifo\n");
+		return ret;
+	}
+
+	init_waitqueue_head(&mctp_device.fifo_proc_list);
+
+	mutex_init(&mctp_device.tx_lock);
+
+	mutex_init(&mctp_device.dev_lock);
+	ret = misc_register(&mctp_miscdev);
+	if (ret) {
+		dev_err(&client->dev, "failed to register mctp misc device\n");
+		return ret;
+	}
+
+	/* Init userspace ncsi device access */
+	spin_lock_init(&ncsi_device.rx_fifo_spinlock);
+
+	ret = kfifo_alloc(&ncsi_device.rx_fifo, MCTP_FIFO_DEPTH, GFP_KERNEL);
+	if (ret) {
+		dev_err(&client->dev, "failed to allocate ncsi rx fifo\n");
+		return ret;
+	}
+
+	init_waitqueue_head(&ncsi_device.fifo_proc_list);
+
+	mutex_init(&ncsi_device.dev_lock);
+	ret = misc_register(&ncsi_miscdev);
+	if (ret) {
+		dev_err(&client->dev, "failed to register ncsi misc device\n");
+		return ret;
+	}
+
+	/* Init userspace pldm device access */
+	spin_lock_init(&pldm_device.rx_fifo_spinlock);
+
+	ret = kfifo_alloc(&pldm_device.rx_fifo, MCTP_FIFO_DEPTH, GFP_KERNEL);
+	if (ret) {
+		dev_err(&client->dev, "failed to allocate pldm rx fifo\n");
+		return ret;
+	}
+
+	init_waitqueue_head(&pldm_device.fifo_proc_list);
+
+	mutex_init(&pldm_device.dev_lock);
+	ret = misc_register(&pldm_miscdev);
+	if (ret) {
+		dev_err(&client->dev, "failed to register pldm misc device\n");
+		return ret;
+	}
+
+	/* Ready for I2C slave interrupts */
+	ret = i2c_slave_register(client, i2c_dw_mctp_slave_cb);
+	if (ret) {
+		dev_err(&client->dev, "failed to register i2c slave\n");
+		return ret;
+	}
+
+	return 0;
+};
+
+static int i2c_dw_mctp_remove(struct i2c_client *client)
+{
+	i2c_slave_unregister(client);
+	sysfs_remove_group(&client->dev.kobj, &mctp_attr_group);
+
+	return 0;
+}
+
+static const struct i2c_device_id i2c_dw_mctp_id[] = {
+	{ "mctp", 0 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, i2c_dw_mctp_id);
+
+static struct i2c_driver i2c_dw_mctp_driver = {
+	.driver = {
+		.name = "i2c-mctp",
+	},
+	.probe = i2c_dw_mctp_probe,
+	.remove = i2c_dw_mctp_remove,
+	.id_table = i2c_dw_mctp_id,
+};
+module_i2c_driver(i2c_dw_mctp_driver);
+
+MODULE_AUTHOR("Brad Larson <brad@pensando.io>");
+MODULE_DESCRIPTION("Synopsys DesignWare I2C MCTP Endpoint Controller");
+MODULE_LICENSE("GPL v2");
diff --git a/drivers/i2c/busses/i2c-designware-mctp.h b/drivers/i2c/busses/i2c-designware-mctp.h
new file mode 100644
index 00000000..ad5aee3
--- /dev/null
+++ b/drivers/i2c/busses/i2c-designware-mctp.h
@@ -0,0 +1,209 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020, Pensando Systems Inc.
+ *
+ * Pensando MCTP driver definitions for Synopsys DesignWare I2C adapter.
+ *
+ */
+
+#ifndef __I2C_DESIGNWARE_MCTP_H
+#define __I2C_DESIGNWARE_MCTP_H
+
+void i2c_dw_configure_master(struct dw_i2c_dev *dev);
+void i2c_dw_configure_slave(struct dw_i2c_dev *dev);
+int i2c_dw_unreg_slave(struct i2c_client *slave);
+struct i2c_adapter *get_i2c_mctp_adap(void);
+void *get_i2c_dw_mctp(void);
+
+/* SMBUS default addresses (8-bit) */
+#define SMBUS_HOST_ADDR            0x10
+#define SMBUS_ALERT_ADDR           0x18
+#define SMBUS_DEFAULT_ADDR         0xc2
+#define MCTP_DEFAULT_FIXED_ADDR    0x64
+
+/*
+ * Clients mctpd, pldmd, and ncsid have this amount of time to read all
+ * bytes out of the kfifo and complete the response to the BMC.  The BMC
+ * will retry the request at ~1 second and this avoids a late response bus
+ * collision.  An app that is not running will result in each message being
+ * dropped at the timeout which is counted in the "client"_msg_resp_late.
+ */
+#define KFIFO_READ_TIMEOUT    800    // msec
+
+/*
+ * MCTP over I2C packet encapsulation
+ *   MCTP I2C transport header  mctp_i2c_header
+ *   MCTP header                mctp_header
+ *   MCTP message header        mctp_message_header
+ *   MCTP message data          mctp_message
+ */
+
+/* MCTP I2C transport header */
+struct mctp_i2c_header {
+	uint8_t dest;    /* smbus destination slave address */
+	uint8_t cmd;     /* mctp over smbus command code (0x0f) */
+	uint8_t len;     /* byte count (src to msg end, not incl. pec) */
+	uint8_t src;     /* smbus source slave address */
+};
+#define I2C_HDR_LEN    4
+
+/* MCTP header */
+struct mctp_header {
+	uint8_t ver;          /* reserved, header version */
+	uint8_t dest;         /* destination endpoint id */
+	uint8_t src;          /* source endpoint id */
+	uint8_t hdr_flags;    /* som,eom,seq,to,tag */
+};
+#define MCTP_HDR_LEN         4
+#define MCTP_HDR_VER_MASK    (0xf)     /* mctp header version */
+
+/* MCTP header hdr_flags fields */
+#define MCTP_HDR_FLAG_SOM    (1<<7)    /* start of message */
+#define MCTP_HDR_FLAG_EOM    (1<<6)    /* end of message */
+#define MCTP_HDR_FLAG_TO     (1<<3)    /* tag owner */
+#define MCTP_HDR_SEQ_SHIFT   (4)       /* pkt seq number */
+#define MCTP_HDR_SEQ_MASK    (0x3)     /* modulo 4 incremented */
+#define MCTP_HDR_TAG_SHIFT   (0)       /* message tag */
+#define MCTP_HDR_TAG_MASK    (0x7)
+
+
+/* MCTP message_header */
+struct mctp_message_header {
+	uint8_t ic_msg_type;        /* integrity check, message type */
+	uint8_t msg_flags;          /* rqst, d-bit, instance id */
+	uint8_t cmd_code;           /* mctp control command */
+	uint8_t completion_code;    /* only present in response messages */
+};
+
+/* MCTP message header msg_flags */
+#define MCTP_MSG_HDR_IC          (1<<7)    /* integrity check, zero for control msgs */
+#define MCTP_MSG_HDR_MSG_TYPE    (0x7f)    /* message type, 0=mctp control */
+#define MCTP_MSG_HDR_RQ          (1<<7)    /* request bit, mctp control vs other msgs */
+#define MCTP_MSG_HDR_DBIT        (1<<6)    /* datagram bit */
+#define MCTP_MSG_HDR_INSTANCE    (0x1f)    /* instance id */
+
+/*
+ * SMBus definitions
+ */
+
+/* ARP Commands */
+#define ARP_PREPARE             0x01
+#define ARP_RESET_DEV           0x02
+#define ARP_GET_UDID_GENERAL    0x03
+#define ARP_ASSIGN_ADDR         0x04
+
+struct smbus_udid {
+	uint8_t device_capabilities;
+	uint8_t version;
+	uint16_t vendor_id;
+	uint16_t device_id;
+	uint16_t interface;
+	uint16_t subsystem_vendor_id;
+	uint16_t subsystem_device_id;
+	uint32_t vendor_specific_id;
+};
+
+/*
+ * MCTP definitions
+ */
+
+/* Baseline Transmission Unit and packet size */
+#define MCTP_BTU                64
+#define MCTP_PACKET_SIZE(unit)  ((unit) + sizeof(struct mctp_hdr))
+
+struct mctp_i2c_trailer {
+	uint8_t pec;     /* packet error code */
+};
+
+#define EID_REJECTED    (1 << 4)
+
+struct mctp_response {
+	struct mctp_i2c_header i2c_hdr;
+	struct mctp_header mctp_hdr;
+	uint8_t msg_type;
+	uint8_t msg_hdr;
+	uint8_t cmd_code;
+	uint8_t data[];
+} __packed;
+
+#define MCTP_HEADER_SIZE    (sizeof(struct mctp_header) + sizeof(struct mctp_i2c_header))
+#define CONTROL_MSG_SIZE    11
+#define MCTP_CMD            0x0f
+
+/* MCTP transport binding identifier */
+enum {
+	MCTP_BINDING_RSVD     = 0x00,
+	MCTP_BINDING_SMBUS    = 0x01,
+	MCTP_BINDING_PCIE_VDM = 0x02,
+	MCTP_BINDING_USB      = 0x03,
+	MCTP_BINDING_KCS      = 0x04,
+	MCTP_BINDING_SERIAL   = 0x05,
+	MCTP_BINDING_VENDORL  = 0xff,
+};
+
+/* MCTP message types */
+enum {
+	MSG_TYPE_MCTP_CONTROL_MSG   = 0x00,
+	MSG_TYPE_PLDM_MSG           = 0x01,
+	MSG_TYPE_NCSI_OVER_MCTP_MSG = 0x02,
+	MSG_TYPE_ETH_OVER_MCTP_MSG  = 0x03,
+	MSG_TYPE_VENDOR_PCI_MSG     = 0x7e,
+	MSG_TYPE_VENDOR_IANA_MSG    = 0x7f,
+};
+
+/* MCTP control message completion codes */
+enum {
+	MCTP_CTRL_SUCCESS         = 0,
+	MCTP_CTRL_ERROR           = 1,
+	MCTP_CTRL_INVALID_DATA    = 2,
+	MCTP_CTRL_INVALID_LENGTH  = 3,
+	MCTP_CTRL_NOT_READY       = 4,
+	MCTP_CTRL_UNSUPPORTED_CMD = 5,
+};
+
+/**
+ * struct mctp_binding_i2c - mctp over i2c binding
+ * @fd: parent device
+ */
+struct mctp_binding_i2c {
+	int                     fd;
+	unsigned long           bus_id;
+	void                    *tx_fn_data;
+
+	/* Receive buffer and state */
+	uint8_t                 rxbuf[1024];
+	struct mctp_pktbuf      *rx_pkt;
+	uint8_t                 rx_exp_len;
+	uint16_t                rx_pec;
+	uint8_t                 src_addr;
+	enum {
+		STATE_WAIT_MCTP_CMD,
+		STATE_WAIT_LEN,
+		STATE_WAIT_SRC_ADDR,
+		STATE_DATA,
+		STATE_WAIT_PEC,
+	} rx_state;
+
+	/* Temporary transmit buffer */
+	uint8_t                 tx_buf[256];
+};
+
+/* The ioctl type, 'L', 0x30 - 0x3F, unused in ioctl-number.txt */
+enum {
+	_SLAVE_RESET = 0x30,
+	_SET_EID,
+	_GET_EID,
+	_SLAVE_ADDR,
+	_ARP_RESET,
+	_MCTP_INFO,
+};
+
+#define MCTP_IOCTL 'L'
+#define SLAVE_RESET  _IO(MCTP_IOCTL, _SLAVE_RESET)
+#define SET_EID      _IOW(MCTP_IOCTL, _SET_EID, unsigned int *)
+#define GET_EID      _IOR(MCTP_IOCTL, _GET_EID, unsigned int *)
+#define SLAVE_ADDR   _IOR(MCTP_IOCTL, _SLAVE_ADDR, unsigned int *)
+#define ARP_RESET    _IO(MCTP_IOCTL, _ARP_RESET)
+#define MCTP_INFO    _IOR(MCTP_IOCTL, _MCTP_INFO, struct mctp_statistics *)
+
+#endif /* __I2C_DESIGNWARE_MCTP_H */
diff --git a/drivers/i2c/busses/i2c-designware-platdrv.c b/drivers/i2c/busses/i2c-designware-platdrv.c
index ad91c7c..d7a6cbd 100644
--- a/drivers/i2c/busses/i2c-designware-platdrv.c
+++ b/drivers/i2c/busses/i2c-designware-platdrv.c
@@ -135,6 +135,9 @@ static int dw_i2c_of_configure(struct platform_device *pdev)
 {
 	struct dw_i2c_dev *dev = platform_get_drvdata(pdev);
 
+	device_property_read_u32(&pdev->dev, "snps,sda-timeout-ms",
+			&dev->sda_timeout_ms);
+
 	switch (dev->flags & MODEL_MASK) {
 	case MODEL_MSCC_OCELOT:
 		dev->ext = devm_platform_ioremap_resource(pdev, 1);
diff --git a/drivers/i2c/busses/i2c-designware-slave.c b/drivers/i2c/busses/i2c-designware-slave.c
index 0d15f4c..b5bc026 100644
--- a/drivers/i2c/busses/i2c-designware-slave.c
+++ b/drivers/i2c/busses/i2c-designware-slave.c
@@ -17,6 +17,15 @@
 #include <linux/regmap.h>
 
 #include "i2c-designware-core.h"
+#include "i2c-designware-mctp.h"
+
+#ifdef CONFIG_I2C_DESIGNWARE_MCTP
+struct i2c_client *i2c_client_mctp;
+void * get_i2c_dw_mctp(void)
+{
+	return (void *) i2c_client_mctp;
+}
+#endif
 
 static void i2c_dw_configure_fifo_slave(struct dw_i2c_dev *dev)
 {
@@ -62,6 +71,10 @@ static int i2c_dw_reg_slave(struct i2c_client *slave)
 {
 	struct dw_i2c_dev *dev = i2c_get_adapdata(slave->adapter);
 
+#ifdef CONFIG_I2C_DESIGNWARE_MCTP
+	i2c_client_mctp = slave;
+#endif
+
 	if (dev->slave)
 		return -EBUSY;
 	if (slave->flags & I2C_CLIENT_TEN)
@@ -89,7 +102,7 @@ static int i2c_dw_reg_slave(struct i2c_client *slave)
 	return 0;
 }
 
-static int i2c_dw_unreg_slave(struct i2c_client *slave)
+int i2c_dw_unreg_slave(struct i2c_client *slave)
 {
 	struct dw_i2c_dev *dev = i2c_get_adapdata(slave->adapter);
 
@@ -224,6 +237,79 @@ static irqreturn_t i2c_dw_isr_slave(int this_irq, void *dev_id)
 	return IRQ_RETVAL(ret);
 }
 
+/*
+ * MCTP enable I2C slave mode
+ *   - Disable I2C interrupts
+ *   - Disable I2C device
+ *   - Free master mode IRQ
+ *   - Configure and initialize slave mode
+ *   - Register slave device
+ *   - Request slave mode IRQ
+ */
+#ifdef CONFIG_I2C_DESIGNWARE_MCTP
+int dw_enable_slave(void)
+{
+	struct i2c_adapter *i2c_mctp_adap = get_i2c_mctp_adap();
+	struct dw_i2c_dev *dev = i2c_get_adapdata(i2c_mctp_adap);
+	struct i2c_client *client = get_i2c_dw_mctp();
+	int ret = 0;
+
+	i2c_dw_wait_bus_not_busy(dev);
+
+	dev->init = i2c_dw_init_slave;
+	dev->disable_int(dev);
+	dev->disable(dev);
+	if (dev->irq)
+		devm_free_irq(dev->dev, dev->irq, dev);
+
+	ret = i2c_dw_init_regmap(dev);
+	if (ret)
+		return ret;
+
+	/* Configure in slave mode */
+	i2c_dw_configure_slave(dev);
+
+	ret = dev->init(dev);
+	if (ret) {
+		dev_info(dev->dev, "i2c slave enable error (%d)\n", ret);
+		return ret;
+	}
+
+	if (!client) {
+		dev_info(dev->dev, "i2c slave enable error, null client\n");
+		return -1;
+	}
+
+	ret = i2c_dw_reg_slave(client);
+	if (ret) {
+		dev_info(dev->dev, "i2c slave register error (%d)\n", ret);
+		return ret;
+	}
+
+	ret = devm_request_irq(dev->dev, dev->irq, i2c_dw_isr_slave,
+			       IRQF_SHARED, dev_name(dev->dev), dev);
+	if (ret) {
+		dev_info(dev->dev, "failure requesting irq %i: %d\n",
+			 dev->irq, ret);
+		return ret;
+	}
+
+	return ret;
+}
+
+/* Update slave address while in slave mode */
+void dw_update_slave_addr(void)
+{
+	struct i2c_adapter *i2c_mctp_adap = get_i2c_mctp_adap();
+	struct dw_i2c_dev *dev = i2c_get_adapdata(i2c_mctp_adap);
+	struct i2c_client *client = get_i2c_dw_mctp();
+
+	__i2c_dw_enable(dev);
+	regmap_write(dev->map, DW_IC_SAR, client->addr);
+	__i2c_dw_disable(dev);
+}
+#endif
+
 static const struct i2c_algorithm i2c_dw_algo = {
 	.functionality = i2c_dw_func,
 	.reg_slave = i2c_dw_reg_slave,
diff --git a/drivers/i2c/busses/i2c-rd1173.c b/drivers/i2c/busses/i2c-rd1173.c
new file mode 100644
index 00000000..f4b5989d
--- /dev/null
+++ b/drivers/i2c/busses/i2c-rd1173.c
@@ -0,0 +1,838 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Lattice RD1173 SPI to I2C bus interface driver
+ *
+ * Copyright (C) 2020-2022 Pensando Systems, Inc.
+ */
+
+#include <linux/gpio/consumer.h>
+#include <linux/i2c.h>
+#include <linux/interrupt.h>
+#include <linux/module.h>
+#include <linux/of_device.h>
+#include <linux/of_gpio.h>
+#include <linux/pm_runtime.h>
+#include <linux/regmap.h>
+#include <linux/spi/spi.h>
+#include <linux/delay.h>
+#include <linux/sysfs.h>
+
+/* SoC is assigned I2C bus 0 */
+#define PORT1_I2C_BUS_NUM    1
+#define PORT2_I2C_BUS_NUM    2
+
+/* SPI command bits 7:4 */
+#define RD1173_CMD_REG_WR         0x00    /* write internal reg */
+#define RD1173_CMD_REG_RD         0x10    /* read internal reg */
+#define RD1173_CMD_INT_CHECK      0x20    /* interrupt check */
+#define RD1173_CMD_I2C_WR_N       0x30    /* write N bytes */
+#define RD1173_CMD_I2C_RD_N       0x40    /* read N bytes */
+#define RD1173_CMD_RD_RX_FIFO     0x50    /* read rx fifo */
+
+/* Register address bits 3:0 */
+#define RD1173_FIFO_STATUS_REG    0x01
+#define RD1173_I2C0_CONFIG_REG    0x04
+#define RD1173_I2C0_MODE_REG      0x05
+#define RD1173_I2C0_CMD_STAT_REG  0x06
+#define RD1173_I2C1_CONFIG_REG    0x0a
+#define RD1173_I2C1_MODE_REG      0x0b
+#define RD1173_I2C1_CMD_STAT_REG  0x0c
+
+/* Register offset from master regbase */
+#define RD1173_CONFIG_REG         0x00
+#define RD1173_MODE_REG           0x01
+#define RD1173_CMD_STAT_REG       0x02
+
+/* FIFO register definitions */
+#define RD1173_FIFO_RX0_FULL      0x80
+#define RD1173_FIFO_RX0_EMPTY     0x40
+#define RD1173_FIFO_TX0_FULL      0x20
+#define RD1173_FIFO_TX0_EMPTY     0x10
+#define RD1173_FIFO_RX1_FULL      0x08
+#define RD1173_FIFO_RX1_EMPTY     0x04
+#define RD1173_FIFO_TX1_FULL      0x02
+#define RD1173_FIFO_TX1_EMPTY     0x01
+
+/* Configuration register definitions */
+#define RD1173_CONFIG_RESET       0x80
+#define RD1173_CONFIG_RXFIFO_CLR  0x40
+#define RD1173_CONFIG_TXFIFO_CLR  0x20
+#define RD1173_CONFIG_ABORT       0x10
+#define RD1173_CONFIG_RXREAD_CLR  0x08
+#define RD1173_CONFIG_TXREAD_CLR  0x04
+#define RD1173_CONFIG_INT_CLR     0x02
+#define RD1173_CONFIG_START       0x01
+
+/* Mode register definitions */
+#define RD1173_MODE_BPS1          0x80
+#define RD1173_MODE_BPS0          0x40
+#define RD1173_MODE_TX_IE         0x20
+#define RD1173_MODE_ACK_POL       0x10
+#define RD1173_MODE_RX_IE         0x08
+
+/* Command status register definitions */
+#define RD1173_STAT_I2C_BUSY      0x80
+#define RD1173_STAT_NO_ANS        0x40
+#define RD1173_STAT_NO_ACK        0x20
+#define RD1173_STAT_TX_ERR        0x10
+#define RD1173_STAT_RX_ERR        0x08
+#define RD1173_STAT_ABORT_ACK     0x04
+#define RD1173_STAT_TS            0x02
+
+struct i2c_stats {
+	u32 i2c0_tx_complete;
+	u32 i2c0_rx_complete;
+	u32 i2c0_busy;
+	u32 i2c0_no_answer;
+	u32 i2c0_no_ack;
+	u32 i2c0_tx_error;
+	u32 i2c0_rx_error;
+	u32 i2c0_abort_ack;
+
+	u32 i2c1_tx_complete;
+	u32 i2c1_rx_complete;
+	u32 i2c1_busy;
+	u32 i2c1_no_answer;
+	u32 i2c1_no_ack;
+	u32 i2c1_tx_error;
+	u32 i2c1_rx_error;
+	u32 i2c1_abort_ack;
+};
+
+struct rd1173_i2c_adapter {
+	struct rd1173dev *rd1173dev;
+	struct i2c_adapter i2c_adap;
+	int i2c_master;
+	int state;
+	u32 offset;
+};
+
+struct rd1173dev {
+	struct spi_device *spi;
+	const struct chipdesc *chip;
+	struct regmap *regmap;
+	struct rd1173_i2c_adapter i2c_adap[2];
+	struct i2c_stats stats;
+	struct mutex xfer_active;
+	struct completion completion;
+	int active_port;
+};
+
+enum chiptype {
+	SPI2I2C_PENCPLD,
+};
+
+struct chipdesc {
+	u8  type;
+	u32 buffer_size;
+	const struct regmap_config *regmap_cfg;
+};
+
+#define i2c_show_simple(field, name, format_string, cast)                  \
+static ssize_t                                                             \
+show_##name(struct device *dev, struct device_attribute *attr, char *buf)  \
+{                                                                          \
+	struct spi_device *spi = to_spi_device(dev);                       \
+	struct rd1173dev *rd1173dev = spi_get_drvdata(spi);                \
+	struct i2c_stats *i2c_stats = &rd1173dev->stats;                   \
+									   \
+	return snprintf(buf, 20, format_string, cast i2c_stats->field);    \
+}
+
+#define i2c_attr_show(field, name, format_string, type)         \
+	i2c_show_simple(field, name, format_string, (type))     \
+static DEVICE_ATTR(name, 0444, show_##name, NULL)
+
+i2c_attr_show(i2c0_tx_complete, i2c0_tx_complete, "%d\n", u32);
+i2c_attr_show(i2c0_rx_complete, i2c0_rx_complete, "%d\n", u32);
+i2c_attr_show(i2c0_busy, i2c0_busy, "%d\n", u32);
+i2c_attr_show(i2c0_no_answer, i2c0_no_answer, "%d\n", u32);
+i2c_attr_show(i2c0_no_ack, i2c0_no_ack, "%d\n", u32);
+i2c_attr_show(i2c0_tx_error, i2c0_tx_error, "%d\n", u32);
+i2c_attr_show(i2c0_rx_error, i2c0_rx_error, "%d\n", u32);
+i2c_attr_show(i2c0_abort_ack, i2c0_abort_ack, "%d\n", u32);
+
+i2c_attr_show(i2c1_tx_complete, i2c1_tx_complete, "%d\n", u32);
+i2c_attr_show(i2c1_rx_complete, i2c1_rx_complete, "%d\n", u32);
+i2c_attr_show(i2c1_busy, i2c1_busy, "%d\n", u32);
+i2c_attr_show(i2c1_no_answer, i2c1_no_answer, "%d\n", u32);
+i2c_attr_show(i2c1_no_ack, i2c1_no_ack, "%d\n", u32);
+i2c_attr_show(i2c1_tx_error, i2c1_tx_error, "%d\n", u32);
+i2c_attr_show(i2c1_rx_error, i2c1_rx_error, "%d\n", u32);
+i2c_attr_show(i2c1_abort_ack, i2c1_abort_ack, "%d\n", u32);
+
+static struct attribute *i2c_attrs[] = {
+	&dev_attr_i2c0_tx_complete.attr,
+	&dev_attr_i2c0_rx_complete.attr,
+	&dev_attr_i2c0_busy.attr,
+	&dev_attr_i2c0_no_answer.attr,
+	&dev_attr_i2c0_no_ack.attr,
+	&dev_attr_i2c0_tx_error.attr,
+	&dev_attr_i2c0_rx_error.attr,
+	&dev_attr_i2c0_abort_ack.attr,
+
+	&dev_attr_i2c1_tx_complete.attr,
+	&dev_attr_i2c1_rx_complete.attr,
+	&dev_attr_i2c1_busy.attr,
+	&dev_attr_i2c1_no_answer.attr,
+	&dev_attr_i2c1_no_ack.attr,
+	&dev_attr_i2c1_tx_error.attr,
+	&dev_attr_i2c1_rx_error.attr,
+	&dev_attr_i2c1_abort_ack.attr,
+	NULL,
+};
+
+static const struct attribute_group i2c_attr_group = {
+	.attrs = i2c_attrs,
+};
+
+#define rd1173_show_simple(field, name, format_string, cast)		\
+static ssize_t								\
+show_##name(struct device *dev, struct device_attribute *attr,		\
+	    char *buf)							\
+{									\
+	struct spi_device *spi = to_spi_device(dev);			\
+	struct rd1173dev *rd1173dev = spi_get_drvdata(spi);		\
+	unsigned int val;						\
+									\
+	regmap_read(rd1173dev->regmap, field, &val);			\
+	return snprintf(buf, 20, format_string, cast val);		\
+}
+
+#define rd1173_store_simple(field, name, base)				\
+static ssize_t								\
+store_##name(struct device *dev, struct device_attribute *attr,		\
+	     const char *buf, size_t count)				\
+{									\
+	struct spi_device *spi = to_spi_device(dev);			\
+	struct rd1173dev *rd1173dev = spi_get_drvdata(spi);		\
+	unsigned long val;						\
+	int ret;							\
+									\
+	ret = kstrtoul(buf, base, &val);				\
+	if (ret) return ret;						\
+	regmap_write(rd1173dev->regmap, field, (unsigned int)val);	\
+	return count;							\
+}
+
+#define rd1173_attr_show(field, name, format_string, type)		\
+	rd1173_show_simple(field, name, format_string, (type))		\
+static DEVICE_ATTR(name, 0444, show_##name, NULL)
+
+#define rd1173_attr_rw(field, name, format_string, type)		\
+	rd1173_show_simple(field, name, format_string, (type))		\
+	rd1173_store_simple(field, name, 0)				\
+static DEVICE_ATTR(name, 0644, show_##name, store_##name)
+
+rd1173_attr_rw(RD1173_I2C0_CONFIG_REG, i2c0_cfg, "0x%02x\n", u32);
+rd1173_attr_rw(RD1173_I2C1_CONFIG_REG, i2c1_cfg, "0x%02x\n", u32);
+rd1173_attr_show(RD1173_I2C0_MODE_REG, i2c0_mode, "0x%02x\n", u32);
+rd1173_attr_show(RD1173_I2C1_MODE_REG, i2c1_mode, "0x%02x\n", u32);
+rd1173_attr_show(RD1173_I2C0_CMD_STAT_REG, i2c0_cmdstat, "0x%02x\n", u32);
+rd1173_attr_show(RD1173_I2C1_CMD_STAT_REG, i2c1_cmdstat, "0x%02x\n", u32);
+rd1173_attr_show(RD1173_FIFO_STATUS_REG, i2c_fifo_status, "0x%02x\n", u32);
+
+static struct attribute *rd1173_attrs[] = {
+	&dev_attr_i2c0_cfg.attr,
+	&dev_attr_i2c1_cfg.attr,
+	&dev_attr_i2c0_mode.attr,
+	&dev_attr_i2c1_mode.attr,
+	&dev_attr_i2c0_cmdstat.attr,
+	&dev_attr_i2c1_cmdstat.attr,
+	&dev_attr_i2c_fifo_status.attr,
+	NULL,
+};
+
+static const struct attribute_group rd1173_attr_group = {
+	.attrs = rd1173_attrs,
+};
+
+static bool rd1173_writeable_reg(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case RD1173_FIFO_STATUS_REG:
+	case RD1173_I2C0_CMD_STAT_REG:
+	case RD1173_I2C1_CMD_STAT_REG:
+		return false;
+	default:
+		return true;
+	}
+}
+
+static const struct regmap_config rd1173_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.max_register = RD1173_I2C1_CMD_STAT_REG,
+	.writeable_reg = rd1173_writeable_reg,
+};
+
+static const struct chipdesc chip_rd1173 = {
+	.type = SPI2I2C_PENCPLD,
+	.buffer_size = 8,
+	.regmap_cfg = &rd1173_regmap_config,
+};
+
+static irqreturn_t rd1173_irq_handler(int this_irq, void *data)
+{
+	struct rd1173dev *rd1173dev = data;
+	struct rd1173_i2c_adapter *i2c0 = &rd1173dev->i2c_adap[0];
+	struct rd1173_i2c_adapter *i2c1 = &rd1173dev->i2c_adap[1];
+	int rc;
+
+	if (rd1173dev->active_port == 1) {
+		rc = regmap_read(rd1173dev->regmap,
+				 i2c0->offset + RD1173_CMD_STAT_REG,
+				 &i2c0->state);
+		if (rc)
+			return IRQ_NONE;
+
+		if (i2c0->state & RD1173_STAT_TS) {
+			complete(&i2c0->rd1173dev->completion);
+			return IRQ_HANDLED;
+		}
+	} else if (rd1173dev->active_port == 2) {
+		rc = regmap_read(rd1173dev->regmap,
+				 i2c1->offset + RD1173_CMD_STAT_REG,
+				 &i2c1->state);
+		if (rc)
+			return IRQ_NONE;
+
+		if (i2c1->state & RD1173_STAT_TS) {
+			complete(&i2c1->rd1173dev->completion);
+			return IRQ_HANDLED;
+		}
+	}
+	return IRQ_NONE;
+}
+
+/**
+ * reg_read - RD1173 internal register read
+ * @context: Pointer to rd1173 device
+ * @reg: Internal register address
+ * @val: Read data
+ *
+ * Return: zero on success, else a negative error code.
+ */
+static int reg_read(void *context, unsigned int reg, unsigned int *val)
+{
+	struct device *dev = context;
+	struct spi_device *spi = to_spi_device(dev);
+	u8 txbuffer[1] = { RD1173_CMD_REG_RD | (reg & 0xf) };
+	u8 rxbuffer[1];
+	int rc;
+
+	rc = spi_write_then_read(spi, txbuffer, sizeof(txbuffer),
+				 rxbuffer, sizeof(rxbuffer));
+	if (rc) {
+		dev_dbg(&spi->dev, "reg read error %d\n", rc);
+		return rc;
+	}
+	*val = rxbuffer[0];
+
+	return 0;
+}
+
+/**
+ * reg_write - RD1173 internal register write
+ * @context: Pointer to rd1173 device
+ * @reg: Internal register address
+ * @val: Write data
+ *
+ * Return: zero on success, else a negative error code.
+ */
+static int reg_write(void *context, unsigned int reg, unsigned int val)
+{
+	struct device *dev = context;
+	struct spi_device *spi = to_spi_device(dev);
+	u8 txbuffer[2] = { RD1173_CMD_REG_WR | (reg & 0xf), val & 0xff };
+
+	return spi_write(spi, txbuffer, sizeof(txbuffer));
+}
+
+static struct regmap_bus regmap_rd1173_bus = {
+	.reg_write = reg_write,
+	.reg_read = reg_read,
+	.reg_format_endian_default = REGMAP_ENDIAN_BIG,
+	.val_format_endian_default = REGMAP_ENDIAN_BIG,
+};
+
+/**
+ * rd1173_reset - Reset i2c master
+ * @i2c: Pointer to rd1173 i2c master device
+ *
+ * Return: zero on success, else a negative error code.
+ */
+static int rd1173_reset(struct rd1173_i2c_adapter *i2c)
+{
+	struct device *dev = &i2c->rd1173dev->spi->dev;
+	int reset = RD1173_CONFIG_RESET | RD1173_CONFIG_INT_CLR |
+		    RD1173_CONFIG_ABORT;
+	int enable = RD1173_MODE_TX_IE | RD1173_MODE_RX_IE;
+	int rc;
+
+	dev_dbg(dev, "rd1173 i2c%d reset, cmdstat 0x%x\n",
+		i2c->i2c_adap.nr - 1, i2c->state);
+
+	/* Assert reset */
+	rc = regmap_update_bits(i2c->rd1173dev->regmap,
+				i2c->offset + RD1173_CONFIG_REG,
+				reset, reset);
+	if (rc)
+		dev_dbg(dev, "assert reset error %d\n", rc);
+
+	/* Remove reset */
+	rc = regmap_update_bits(i2c->rd1173dev->regmap,
+				i2c->offset + RD1173_CONFIG_REG,
+				reset, 0);
+	if (rc)
+		dev_dbg(dev, "deassert reset error %d\n", rc);
+
+	/* Enable TX/RX interrupts, standard I2C speed */
+	rc = regmap_update_bits(i2c->rd1173dev->regmap,
+				i2c->offset + RD1173_MODE_REG,
+				enable, enable);
+	if (rc)
+		dev_dbg(dev, "enable int error %d\n", rc);
+
+	return rc;
+}
+
+/**
+ * rd1173_fifo_clear - Clear TX and RX FIFOs
+ * @i2c: Pointer to rd1173 i2c master device
+ *
+ * Return: zero on success, else a negative error code.
+ */
+static int rd1173_fifo_clear(struct rd1173_i2c_adapter *i2c)
+{
+	struct device *dev = &i2c->rd1173dev->spi->dev;
+	int clr = RD1173_CONFIG_RXFIFO_CLR | RD1173_CONFIG_TXFIFO_CLR |
+		  RD1173_CONFIG_RXREAD_CLR | RD1173_CONFIG_TXREAD_CLR;
+	int rc;
+
+	/* Assert fifo clear */
+	rc = regmap_update_bits(i2c->rd1173dev->regmap,
+				i2c->offset + RD1173_CONFIG_REG,
+				clr, clr);
+	if (rc)
+		dev_dbg(dev, "fifo clear error %d\n", rc);
+
+	/* Deassert fifo clear */
+	rc = regmap_update_bits(i2c->rd1173dev->regmap,
+				i2c->offset + RD1173_CONFIG_REG,
+				clr, 0);
+	if (rc)
+		dev_dbg(dev, "fifo clear error %d\n", rc);
+
+	return rc;
+}
+
+/**
+ * rd1173_read - Initiate a read from rd1173 i2c master
+ * @i2c: Pointer to rd1173 i2c master device
+ * @msg: Pointer to i2c message structure
+ * @cnt: Number of bytes to read (max 8)
+ *
+ * Return: Return: zero on success, else a negative error code.
+ */
+static int rd1173_read(struct rd1173_i2c_adapter *i2c, struct i2c_msg *msg, u8 cnt)
+{
+	u8 hdr[] = { RD1173_CMD_I2C_RD_N | (i2c->i2c_master << 1),
+		     cnt, msg->addr };
+	u8 start[] = { RD1173_CMD_REG_WR | (i2c->offset + RD1173_CONFIG_REG),
+		       RD1173_CONFIG_START };
+	int rc;
+
+	rc = spi_write(i2c->rd1173dev->spi, hdr, sizeof(hdr));
+	if (rc)
+		return rc;
+
+	return spi_write(i2c->rd1173dev->spi, start, sizeof(start));
+}
+
+/**
+ * rd1173_write - Initiate a write to rd1173 i2c master
+ * @i2c: Pointer to rd1173 i2c master device
+ * @msg: Pointer to i2c message structure
+ * @cnt: Number of bytes to write (max 8)
+ *
+ * Return: Return: zero on success, else a negative error code.
+ */
+static int rd1173_write(struct rd1173_i2c_adapter *i2c, struct i2c_msg *msg, u8 cnt)
+{
+	u8 hdr[] = { RD1173_CMD_I2C_WR_N | (i2c->i2c_master << 1),
+		     cnt, msg->addr };
+	u8 start[] = { RD1173_CMD_REG_WR | (i2c->offset + RD1173_CONFIG_REG),
+		       RD1173_CONFIG_START };
+	struct spi_transfer xfer[2] = { 0 };
+	int rc;
+
+	xfer[0].tx_buf = hdr;
+	xfer[0].len = sizeof(hdr);
+
+	xfer[1].tx_buf = msg->buf;
+	xfer[1].len = msg->len;
+
+	rc = spi_sync_transfer(i2c->rd1173dev->spi, xfer, 2);
+	if (rc)
+		return rc;
+
+	return spi_write(i2c->rd1173dev->spi, start, sizeof(start));
+}
+
+/**
+ * rd1173_read_buffer - Read rd1173 i2c master receive fifo
+ * @i2c: Pointer to rd1173 i2c master device
+ * @buf: Pointer to receive buffer address
+ * @cnt: Number of bytes to read from rx fifo (max 8)
+ *
+ * Return: zero on success, else a negative error code.
+ */
+static int rd1173_read_buffer(struct rd1173_i2c_adapter *i2c, u8 *buf, u8 cnt)
+{
+	u8 txbuffer[1] = { RD1173_CMD_RD_RX_FIFO | (i2c->i2c_master << 1) };
+
+	return spi_write_then_read(i2c->rd1173dev->spi,
+				   txbuffer, sizeof(txbuffer),
+				   buf, cnt + 1);
+}
+
+/**
+ * rd1173_clear_cmdstat - Clear rd1173 command/status register
+ * @i2c: Pointer to rd1173 i2c master device
+ *
+ * Return: zero on success, else a negative error code.
+ */
+static int rd1173_clear_cmdstat(struct rd1173_i2c_adapter *i2c)
+{
+	struct device *dev = &i2c->rd1173dev->spi->dev;
+	int rc;
+
+	rc = regmap_update_bits(i2c->rd1173dev->regmap,
+				i2c->offset + RD1173_CONFIG_REG,
+				RD1173_CONFIG_INT_CLR, RD1173_CONFIG_INT_CLR);
+	if (rc)
+		dev_dbg(dev, "clear cmdstat err %d\n", rc);
+
+	rc = regmap_update_bits(i2c->rd1173dev->regmap,
+				i2c->offset + RD1173_CONFIG_REG,
+				RD1173_CONFIG_INT_CLR, 0);
+	if (rc)
+		dev_dbg(dev, "clear cmdstat err %d\n", rc);
+
+	return rc;
+}
+
+/**
+ * update_i2c_stats - Update the i2c transfer state counters
+ * @i2c: Pointer to rd1173 i2c master device
+ * @readop: I2C readop or writeop
+ *
+ */
+static void update_i2c_stats(struct rd1173_i2c_adapter *i2c, int readop)
+{
+	struct i2c_stats *stats = &i2c->rd1173dev->stats;
+
+	regmap_read(i2c->rd1173dev->regmap,
+		    i2c->offset + RD1173_CMD_STAT_REG,
+		    &i2c->state);
+
+	if (i2c->state & RD1173_STAT_TS) {
+		if (i2c->i2c_master)
+			readop ? stats->i2c1_rx_complete++ :
+				 stats->i2c1_tx_complete++;
+		else
+			readop ? stats->i2c0_rx_complete++ :
+				 stats->i2c0_tx_complete++;
+	}
+	if (i2c->state & RD1173_STAT_I2C_BUSY)
+		i2c->i2c_master ? stats->i2c1_busy++ :
+				  stats->i2c0_busy++;
+	if (i2c->state & RD1173_STAT_NO_ANS)
+		i2c->i2c_master ? stats->i2c1_no_answer++ :
+				  stats->i2c0_no_answer++;
+	if (i2c->state & RD1173_STAT_NO_ACK)
+		i2c->i2c_master ? stats->i2c1_no_ack++ :
+				  stats->i2c0_no_ack++;
+	if (i2c->state & RD1173_STAT_TX_ERR)
+		i2c->i2c_master ? stats->i2c1_tx_error++ :
+				  stats->i2c0_tx_error++;
+	if (i2c->state & RD1173_STAT_RX_ERR)
+		i2c->i2c_master ? stats->i2c1_rx_error++ :
+				  stats->i2c0_rx_error++;
+	if (i2c->state & RD1173_STAT_ABORT_ACK)
+		i2c->i2c_master ? stats->i2c1_abort_ack++ :
+				  stats->i2c0_abort_ack++;
+}
+
+/**
+ * rd1173_xfer - The master spi to i2c transfer function
+ * @adap: Pointer to the i2c_adapter structure
+ * @msgs: Pointer to the messages to be processed
+ * @num: Length of the MSGS array
+ *
+ * Returns the number of messages processed, or a negative errno on failure.
+ */
+static int rd1173_xfer(struct i2c_adapter *i2c_adap, struct i2c_msg *msgs, int num)
+{
+	struct rd1173_i2c_adapter *i2c = i2c_get_adapdata(i2c_adap);
+	struct device *dev = &i2c->rd1173dev->spi->dev;
+	u8 max_len = i2c->rd1173dev->chip->buffer_size;
+	int read_operation = 0;
+	u16 bytes_remaining;
+	u16 bytes_transferred;
+	u8 num_transfers;
+	u8 rx_fifo[9];
+	u8 cnt;
+	int rc = 0;
+	int i, j;
+
+	if (num > 2)
+		return -EOPNOTSUPP;
+
+	for (i = 0; i < num; i++) {
+		if (msgs[i].flags & I2C_M_RD) {
+			if (msgs[i].len > 256)
+				return -EOPNOTSUPP;
+			read_operation++;
+		} else {
+			/* Writes limited buffer size */
+			if (msgs[i].len > max_len)
+				return -EOPNOTSUPP;
+		}
+		dev_dbg(dev, "i2c%d msgs[%d]: addr 0x%x flags 0x%x len %d\n",
+			i2c->i2c_adap.nr - 1, i, msgs[i].addr, msgs[i].flags,
+			msgs[i].len);
+	}
+
+	if (mutex_lock_interruptible(&i2c->rd1173dev->xfer_active))
+		return -ERESTARTSYS;
+
+	reinit_completion(&i2c->rd1173dev->completion);
+	i2c->rd1173dev->active_port = i2c->i2c_adap.nr;
+
+	for (i = 0; i < num; i++) {
+		rd1173_fifo_clear(i2c);
+		rd1173_clear_cmdstat(i2c);
+
+		bytes_transferred = 0;
+		bytes_remaining = msgs[i].len;
+		num_transfers = (bytes_remaining + max_len - 1) / max_len;
+
+		for (j = 0; j < num_transfers; j++) {
+			rd1173_fifo_clear(i2c);
+			rd1173_clear_cmdstat(i2c);
+
+			if (bytes_remaining > max_len)
+				cnt = max_len;
+			else
+				cnt = bytes_remaining;
+
+			if (msgs[i].flags & I2C_M_RD) {
+				dev_dbg(dev, "i2c%d read addr 0x%x len %d\n",
+					i2c->i2c_adap.nr - 1, msgs[i].addr,
+					msgs[i].len);
+				rc = rd1173_read(i2c, &msgs[i], cnt);
+			} else {
+				dev_dbg(dev, "i2c%d write addr 0x%x len %d\n",
+					i2c->i2c_adap.nr - 1, msgs[i].addr,
+					msgs[i].len);
+				rc = rd1173_write(i2c, &msgs[i], cnt);
+			}
+
+			rc = wait_for_completion_timeout(&i2c->rd1173dev->completion,
+							 i2c->i2c_adap.timeout);
+
+			update_i2c_stats(i2c, msgs[i].flags & I2C_M_RD);
+
+			if (!rc && i2c->state != RD1173_STAT_TS)
+				dev_dbg(dev, "i2c%d cmdstat 0x%02x\n",
+					i2c->i2c_adap.nr - 1, i2c->state);
+
+			if (!rc || i2c->state != RD1173_STAT_TS)
+				goto done;
+
+			if (msgs[i].flags & I2C_M_RD) {
+				rc = rd1173_read_buffer(i2c, rx_fifo, cnt);
+				if (rc)
+					goto done;
+
+				memcpy((u8 *)(msgs[i].buf + bytes_transferred),
+				       &rx_fifo[1], cnt);
+
+				bytes_remaining -= cnt;
+				bytes_transferred += cnt;
+			}
+		}
+	}
+
+done:
+	rd1173_clear_cmdstat(i2c);
+	switch (i2c->state) {
+	case RD1173_STAT_TS:
+		rc = num;        /* transfer complete */
+		break;
+	case RD1173_STAT_I2C_BUSY:
+		rd1173_reset(i2c);
+		rc = -EAGAIN;
+		break;
+	case RD1173_STAT_NO_ANS:
+		rc = -ENXIO;
+		break;
+	case RD1173_STAT_NO_ACK:
+		rc = -EREMOTEIO;
+		break;
+	case RD1173_STAT_TX_ERR:
+	case RD1173_STAT_RX_ERR:
+	case RD1173_STAT_ABORT_ACK:
+		rd1173_reset(i2c);
+		rc = -EAGAIN;
+	default:
+		rc = -EAGAIN;
+	}
+
+	i2c->rd1173dev->active_port = 0;
+	mutex_unlock(&i2c->rd1173dev->xfer_active);
+	return rc;
+}
+
+static u32 rd1173_func(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_I2C | I2C_FUNC_SMBUS_EMUL;
+}
+
+static const struct i2c_algorithm rd1173_algo = {
+	.master_xfer   = rd1173_xfer,
+	.functionality = rd1173_func,
+};
+
+static int rd1173_probe(struct spi_device *spi)
+{
+	struct rd1173dev *rd1173dev;
+	struct rd1173_i2c_adapter *i2c;
+	int i, rc;
+
+	rd1173dev = devm_kzalloc(&spi->dev, sizeof(*rd1173dev), GFP_KERNEL);
+	if (!rd1173dev)
+		return -ENOMEM;
+
+	spi_set_drvdata(spi, rd1173dev);
+	init_completion(&rd1173dev->completion);
+	rd1173dev->spi = spi;
+	spi->bits_per_word = 8;
+	spi->mode = SPI_MODE_0;
+
+	for (i = 0; i < 2; i++) {
+		i2c = &rd1173dev->i2c_adap[i];
+		i2c_set_adapdata(&i2c->i2c_adap, i2c);
+		i2c->rd1173dev = rd1173dev;
+		i2c->i2c_master = i;
+		i2c->i2c_adap.algo = &rd1173_algo;
+		i2c->i2c_adap.algo_data = NULL;
+		i2c->i2c_adap.dev.parent = &spi->dev;
+		i2c->i2c_adap.owner = THIS_MODULE;
+		i2c->i2c_adap.class = I2C_CLASS_DEPRECATED;
+		i2c->i2c_adap.timeout = msecs_to_jiffies(100);
+		i2c->i2c_adap.nr = PORT1_I2C_BUS_NUM + i;
+
+		if (i == 0)
+			i2c->offset = RD1173_I2C0_CONFIG_REG;
+		else
+			i2c->offset = RD1173_I2C1_CONFIG_REG;
+
+		snprintf(i2c->i2c_adap.name, sizeof(i2c->i2c_adap.name),
+			 "CPLD Lattice RD1173 I2C%d", i);
+
+		dev_info(&spi->dev, "%s mode %d irq %d\n", i2c->i2c_adap.name,
+			 spi->mode, spi->irq);
+	}
+
+	rd1173dev->chip = of_device_get_match_data(&spi->dev);
+	if (!rd1173dev->chip) {
+		dev_info(&spi->dev, "No matching chip %d\n", -ENODEV);
+		return -ENODEV;
+	}
+
+	rd1173dev->regmap = devm_regmap_init(&spi->dev, &regmap_rd1173_bus,
+					     &spi->dev,
+					     rd1173dev->chip->regmap_cfg);
+	if (IS_ERR(rd1173dev->regmap)) {
+		rc = PTR_ERR(rd1173dev->regmap);
+		dev_err(&spi->dev, "Failed to init regmap, %d\n", rc);
+		return rc;
+	}
+
+
+	mutex_init(&rd1173dev->xfer_active);
+
+	rc = devm_request_threaded_irq(&spi->dev, spi->irq, NULL,
+				       rd1173_irq_handler,
+				       IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+				       "cpld-rd1173", rd1173dev);
+	if (rc) {
+		dev_err(&spi->dev, "Failed to request irq, err %d\n", rc);
+		return rc;
+	}
+
+	rc = spi_setup(spi);
+	if (rc) {
+		dev_info(&spi->dev, "spi setup error %d\n", rc);
+		return rc;
+	}
+
+	for (i = 0; i < 2; i++) {
+		i2c = &rd1173dev->i2c_adap[i];
+		rd1173_reset(i2c);
+		rd1173_fifo_clear(i2c);
+
+		rc = i2c_add_numbered_adapter(&i2c->i2c_adap);
+		if (rc) {
+			dev_err(&spi->dev, "error adding i2c adapter: %d\n", rc);
+			return rc;
+		}
+		dev_info(&spi->dev, "registered I2C bus number %d\n",
+			 i2c->i2c_adap.nr);
+	}
+
+	rc = sysfs_create_group(&spi->dev.kobj, &i2c_attr_group);
+	if (rc)
+		dev_warn(&spi->dev, "failed to create i2c sysfs files\n");
+
+	rc = sysfs_create_group(&spi->dev.kobj, &rd1173_attr_group);
+	if (rc)
+		dev_warn(&spi->dev, "failed to create rd1173 sysfs files\n");
+
+	return 0;
+}
+
+static int rd1173_remove(struct spi_device *spi)
+{
+	struct rd1173dev *rd1173dev = spi_get_drvdata(spi);
+
+	i2c_del_adapter(&rd1173dev->i2c_adap[0].i2c_adap);
+	i2c_del_adapter(&rd1173dev->i2c_adap[1].i2c_adap);
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id rd1173_of_match[] = {
+	{ .compatible = "pensando,cpld-rd1173", .data = &chip_rd1173 },
+	{},
+};
+MODULE_DEVICE_TABLE(of, rd1173_of_match);
+#endif
+
+static struct spi_driver rd1173_driver = {
+	.probe  = rd1173_probe,
+	.remove = rd1173_remove,
+	.driver = {
+		.name  = "i2c-rd1173",
+		.of_match_table = of_match_ptr(rd1173_of_match),
+	},
+};
+module_spi_driver(rd1173_driver);
+
+MODULE_AUTHOR("Brad Larson <brad@pensando.io>");
+MODULE_DESCRIPTION("Pensando CPLD Lattice RD1173 SPI to I2C bus adapter");
+MODULE_LICENSE("GPL");
diff --git a/drivers/irqchip/Kconfig b/drivers/irqchip/Kconfig
index 3c24bf4..2165031 100644
--- a/drivers/irqchip/Kconfig
+++ b/drivers/irqchip/Kconfig
@@ -190,6 +190,17 @@ config CLPS711X_IRQCHIP
 	select SPARSE_IRQ
 	default y
 
+config IRQ_PENSANDO
+	bool "Support for Pensando SOC IRQ chip structure"
+	depends on ARCH_PENSANDO_CAPRI_SOC || ARCH_PENSANDO_ELBA_SOC || ARCH_PENSANDO_GIGLIO_SOC
+	default "y"
+	select IRQ_DOMAIN
+	select IRQ_DOMAIN_HIERARCHY
+	help
+	  This controls whether the Pensando IRQ chip code is used. This code
+	  works in sync with the SOC device tree to define the topology
+	  of devices controlling interrupts.
+
 config OMPIC
 	bool
 
diff --git a/drivers/irqchip/Makefile b/drivers/irqchip/Makefile
index 94c2885..4db853d 100644
--- a/drivers/irqchip/Makefile
+++ b/drivers/irqchip/Makefile
@@ -114,3 +114,4 @@ obj-$(CONFIG_LOONGSON_PCH_PIC)		+= irq-loongson-pch-pic.o
 obj-$(CONFIG_LOONGSON_PCH_MSI)		+= irq-loongson-pch-msi.o
 obj-$(CONFIG_MST_IRQ)			+= irq-mst-intc.o
 obj-$(CONFIG_SL28CPLD_INTC)		+= irq-sl28cpld.o
+obj-$(CONFIG_IRQ_PENSANDO)		+= irq-pensando.o
diff --git a/drivers/irqchip/irq-pensando.c b/drivers/irqchip/irq-pensando.c
new file mode 100644
index 00000000..c7fcba0
--- /dev/null
+++ b/drivers/irqchip/irq-pensando.c
@@ -0,0 +1,879 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Pensando register-based hierarchical IRQ driver
+ *
+ * Copyright (C) 2019-2021 Pensando, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ *
+ * Thanks to other irqchip developers!
+ *
+ * There are three types of registers in the Pensando Capri and Elba ASICs:
+ * o	csr - a particular device. This has enable set, enable clear, and
+ *	interrupt status registers
+ * o	group - a group of devices. This has an enable register and an
+ *	interrupt status register
+ * o	csrintr - module level interrupts. This has a single register with the
+ *	interrupt status at bit 0 and the enable at bit 1. The csrintr code
+ *	supports two or more address tuples, which are all considered for
+ *	interrupt enable, disable, and EOI processing.
+ *
+ * Items remaining to do:
+ * o	Make interrupts use two cells. Right now they have 3 with an
+ *	unnecessary leading GIC_SPI.
+ * o	Drop enable_csr_padddr and enable_mask:
+ *
+ *	a.	Change reg to have what is now in enable_csr_paddr be
+ *		the first element, which will be the same as the current
+ *		value of enable_csr_paddr.
+ *	b.	The enable mask should be the same as 1 shifted left by
+ *		the second value in the interrupts property
+ *
+ *	Doing these, and documenting them, should make this easier to maintain.
+ */
+
+#define pr_fmt(fmt)	KBUILD_MODNAME	": " fmt
+
+#include <asm/stacktrace.h>
+#include <asm-generic/bitops/find.h>
+#include <linux/init.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/interrupt.h>
+#include <linux/irq.h>
+#include <linux/io.h>
+#include <linux/irqdomain.h>
+#include <linux/reboot.h>
+#include <linux/bitops.h>
+#include <linux/irqchip.h>
+#include <linux/irqchip/chained_irq.h>
+#include <linux/spinlock.h>
+#include <linux/irqchip/irq-pensando.h>
+#include <dt-bindings/interrupt-controller/arm-gic.h>
+#include <asm/stacktrace.h>
+
+#ifndef CHAR_BIT
+#define CHAR_BIT	8
+#endif
+
+/* Build in debugging messages in unmask_enable, eio, etc. functions */
+#undef TRACE_IRQ_DOMAIN_OPS
+
+#ifdef TRACE_IRQ_DOMAIN_OPS
+#define trace_irq_domain_ops(fmt, ...) pr_err("%s: " fmt, __func__, \
+	##__VA_ARGS__)
+#else
+#define trace_irq_domain_ops(fmt, ...) do { } while (false)
+#endif
+
+/* Maximum number of supported domains */
+#define MAX_DOMAINS	25
+
+#define MAX_N_IRQS_PER_CHIP	32
+
+/* Parameters for interpreting an irq_fwspec parsed from the device tree */
+#define IRQ_GIC_INTR_TYPE	0
+#define IRQ_FWSPEC_HWIRQ	1
+#define IRQ_FWSPEC_TYPE		2
+#define N_INTERRUPT_CELLS	3
+#define N_CHIP_TYPES		1		/* On a per-domain basis */
+
+struct domain_info {
+	unsigned int		i;
+	struct irq_domain	*domain;
+};
+
+/*
+ * Control access to IRQ data
+ */
+static unsigned long info_irq_lock(struct pen_ictlr_info *info)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&info->irq_lock, flags);
+	return flags;
+}
+
+static void info_irq_unlock(struct pen_ictlr_info *info, unsigned long flags)
+{
+	spin_unlock_irqrestore(&info->irq_lock, flags);
+}
+
+/*
+ * Interrupt functions with disjoint enable and disable registers.
+ *
+ * The following interrupt enable/disable functions are here for
+ * debugging only and should be replaced by the corresponding
+ * irq_gc* function.
+ */
+void pen_irq_unmask_enable_csr_one(struct irq_data *irq_data)
+{
+	struct irq_domain *domain;
+	struct pen_ictlr_info *info;
+	struct pen_ictlr_csr __iomem *data;
+	irq_hw_number_t hwirq;
+	u32 mask;
+
+	hwirq = irq_data->hwirq;
+	domain = irq_data->domain;
+	info = domain->host_data;
+	data = info->map_base[0];
+	mask = BIT(hwirq);
+	trace_irq_domain_ops("enable %s with %x\n", irq_data->domain->name,
+		mask);
+	writel(mask, &data->int_enable_set);
+}
+EXPORT_SYMBOL(pen_irq_unmask_enable_csr_one);
+
+void pen_irq_unmask_enable_csr(struct irq_data *irq_data)
+{
+	pen_irq_unmask_enable_csr_one(irq_data);
+	irq_chip_unmask_parent(irq_data);
+}
+
+void pen_irq_mask_disable_csr_one(struct irq_data *irq_data)
+{
+	struct irq_domain *domain;
+	struct pen_ictlr_info *info;
+	struct irq_chip *irq_chip;
+	void *chip_data;
+	struct pen_ictlr_csr __iomem *data;
+	irq_hw_number_t hwirq;
+	u32 mask;
+
+	hwirq = irq_data->hwirq;
+	domain = irq_data->domain;
+	irq_chip = irq_data->chip;
+	chip_data = irq_data->chip_data;
+	info = domain->host_data;
+	data = info->map_base[0];
+
+	mask = BIT(hwirq);
+	trace_irq_domain_ops("disable %s with %x\n", irq_data->domain->name,
+		mask);
+	writel(mask, &data->int_enable_clear);
+}
+EXPORT_SYMBOL(pen_irq_mask_disable_csr_one);
+
+void pen_irq_mask_disable_csr(struct irq_data *irq_data)
+{
+	pen_irq_mask_disable_csr_one(irq_data);
+	irq_chip_mask_parent(irq_data);
+}
+
+void pen_irq_eoi_csr(struct irq_data *irq_data)
+{
+	struct irq_domain *domain;
+	struct pen_ictlr_info *info;
+	struct pen_ictlr_csr __iomem *data;
+	irq_hw_number_t hwirq;
+	u32 mask;
+	u32 intreg_before;
+
+	trace_irq_domain_ops("eio %s\n", irq_data->domain->name);
+	hwirq = irq_data->hwirq;
+	domain = irq_data->domain;
+	info = domain->host_data;
+	data = info->map_base[0];
+
+	mask = BIT(hwirq);
+	intreg_before = readl(&data->intreg);
+	writel(mask, &data->intreg);
+	irq_chip_eoi_parent(irq_data);
+}
+
+/*
+ * Interrupt functions with enable and disable in the bit of the same
+ * register but a disjoint interrupt status register
+ *
+ * The following interrupt enable/disable functions are here for
+ * debugging only and should be replaced by the corresponding
+ * irq_gc* function.
+ */
+void pen_irq_unmask_enable_grp_one(struct irq_data *irq_data)
+{
+	struct irq_domain *domain;
+	struct pen_ictlr_info *info;
+	struct pen_ictlr_grp *data;
+	irq_hw_number_t hwirq;
+	unsigned long flags;
+	u32 enable, mask;
+
+	hwirq = irq_data->hwirq;
+	domain = irq_data->domain;
+	info = domain->host_data;
+	data = info->map_base[0];
+
+	mask = BIT(hwirq);
+
+	flags = info_irq_lock(info);
+	enable = readl(&data->intreg);
+	trace_irq_domain_ops("enable %s with %x\n", irq_data->domain->name,
+		enable | mask);
+	writel(enable | mask, &data->int_enable_rw_reg);
+	info_irq_unlock(info, flags);
+}
+EXPORT_SYMBOL(pen_irq_unmask_enable_grp_one);
+
+void pen_irq_unmask_enable_grp(struct irq_data *irq_data)
+{
+	pen_irq_unmask_enable_grp_one(irq_data);
+	irq_chip_unmask_parent(irq_data);
+}
+
+void pen_irq_mask_disable_grp_one(struct irq_data *irq_data)
+{
+	struct irq_domain *domain;
+	struct pen_ictlr_info *info;
+	struct pen_ictlr_grp *data;
+	irq_hw_number_t hwirq;
+	unsigned long flags;
+	u32 enable, mask;
+
+	hwirq = irq_data->hwirq;
+	domain = irq_data->domain;
+	info = domain->host_data;
+	info = domain->host_data;
+	data = info->map_base[0];
+
+	mask = BIT(hwirq);
+
+	flags = info_irq_lock(info);
+	enable = readl(&data->int_enable_rw_reg);
+	trace_irq_domain_ops("disable %s with %x\n", irq_data->domain->name,
+		enable & ~mask);
+	writel(enable & ~mask, &data->int_enable_rw_reg);
+	info_irq_unlock(info, flags);
+}
+EXPORT_SYMBOL(pen_irq_mask_disable_grp_one);
+
+void pen_irq_mask_disable_grp(struct irq_data *irq_data)
+{
+	pen_irq_mask_disable_grp_one(irq_data);
+	irq_chip_mask_parent(irq_data);
+}
+
+void pen_irq_eoi_grp(struct irq_data *irq_data)
+{
+	struct irq_domain *domain;
+	struct pen_ictlr_info *info;
+	struct pen_ictlr_grp *data;
+	irq_hw_number_t hwirq;
+	unsigned long flags;
+	u32 before, after;
+
+	hwirq = irq_data->hwirq;
+	domain = irq_data->domain;
+	info = domain->host_data;
+	data = info->map_base[0];
+
+	flags = info_irq_lock(info);
+
+	/* No state here, so we just invoke the parent */
+	before = readl(&data->int_enable_rw_reg);
+	irq_chip_eoi_parent(irq_data);
+	after = readl(&data->int_enable_rw_reg);
+	info_irq_unlock(info, flags);
+	trace_irq_domain_ops("eio %s before %x after %x\n",
+		irq_data->domain->name, before, after);
+}
+
+/*
+ * Interrupt functions with enable and disable in one bit of the same
+ * register as the interrupt status bit
+ *
+ * The following interrupt enable/disable functions are here for
+ * debugging only and should be replaced by the corresponding
+ * irq_gc* function.
+ */
+void pen_irq_unmask_enable_csrintr_one(struct irq_data *irq_data)
+{
+	struct irq_domain *domain;
+	struct pen_ictlr_info *info;
+	struct pen_ictlr_csrintr *data;
+	irq_hw_number_t hwirq;
+	unsigned long flags;
+	u32 mask;
+	u32 enable;
+	unsigned int i;
+
+	hwirq = irq_data->hwirq;
+	domain = irq_data->domain;
+	info = domain->host_data;
+	mask = BIT(1);
+
+	flags = info_irq_lock(info);
+
+	for (i = 0; i < info->num_bases; i++) {
+		data = info->map_base[i];
+		enable = readl(&data->intr);
+		trace_irq_domain_ops("enable %s (base #%u) with %x\n",
+			irq_data->domain->name, i, enable | mask);
+		writel(enable | mask, &data->intr);
+	}
+
+	info_irq_unlock(info, flags);
+}
+EXPORT_SYMBOL(pen_irq_unmask_enable_csrintr_one);
+
+void pen_irq_unmask_enable_csrintr(struct irq_data *irq_data)
+{
+	pen_irq_unmask_enable_csrintr_one(irq_data);
+	irq_chip_unmask_parent(irq_data);
+}
+
+void pen_irq_mask_disable_csrintr_one(struct irq_data *irq_data)
+{
+	struct irq_domain *domain;
+	struct pen_ictlr_info *info;
+	struct pen_ictlr_csrintr *data;
+	irq_hw_number_t hwirq;
+	unsigned long flags;
+	u32 mask;
+	u32 enable;
+	unsigned int i;
+
+	hwirq = irq_data->hwirq;
+	domain = irq_data->domain;
+	info = domain->host_data;
+	mask = BIT(1);
+
+	flags = info_irq_lock(info);
+
+	for (i = 0; i < info->num_bases; i++) {
+		data = info->map_base[i];
+		enable = readl(&data->intr);
+		trace_irq_domain_ops("disable %s (base #%u) with %x\n",
+			irq_data->domain->name, i, enable & ~mask);
+		writel(enable & ~mask, &data->intr);
+	}
+
+	info_irq_unlock(info, flags);
+}
+EXPORT_SYMBOL(pen_irq_mask_disable_csrintr_one);
+
+void pen_irq_mask_disable_csrintr(struct irq_data *irq_data)
+{
+	pen_irq_mask_disable_csrintr_one(irq_data);
+	irq_chip_mask_parent(irq_data);
+}
+
+/*
+ * We don't need to do any real work here, just report debugging info
+ */
+void pen_irq_eoi_csrintr(struct irq_data *irq_data)
+{
+	struct irq_domain *domain;
+	struct pen_ictlr_info *info;
+	struct pen_ictlr_csrintr *data;
+	irq_hw_number_t hwirq;
+	unsigned long flags;
+	u32 before, after;
+	unsigned int i;
+
+	hwirq = irq_data->hwirq;
+	domain = irq_data->domain;
+	info = domain->host_data;
+	flags = info_irq_lock(info);
+
+	/* No state here, so we just invoke the parent */
+	for (i = 0; i < info->num_bases; i++) {
+		data = info->map_base[i];
+		before = readl(&data->intr);
+
+		irq_chip_eoi_parent(irq_data);
+
+		after = readl(&data->intr);
+		trace_irq_domain_ops("eio %s (base #%u) before %x after %x\n",
+			irq_data->domain->name, i, before, after);
+	}
+	info_irq_unlock(info, flags);
+}
+
+static struct irq_chip pen_irq_chip_csr = {
+	.name =			"CSR",
+	.irq_mask =		pen_irq_mask_disable_csr,
+	.irq_unmask =		pen_irq_unmask_enable_csr,
+	.irq_eoi =		pen_irq_eoi_csr,
+	.irq_set_type =		irq_chip_set_type_parent,
+#ifdef CONFIG_SMP
+	.irq_set_affinity =	irq_chip_set_affinity_parent,
+#endif
+};
+
+static struct irq_chip pen_irq_chip_grp = {
+	.name =			"GRP",
+	.irq_mask =		pen_irq_mask_disable_grp,
+	.irq_unmask =		pen_irq_unmask_enable_grp,
+#ifdef TRACE_IRQ_DOMAIN_OPS
+	.irq_eoi =		pen_irq_eoi_grp,
+#else
+	.irq_eoi =		irq_chip_eoi_parent,
+#endif
+	.irq_set_type =		irq_chip_set_type_parent,
+#ifdef CONFIG_SMP
+	.irq_set_affinity =	irq_chip_set_affinity_parent,
+#endif
+};
+
+static struct irq_chip pen_irq_chip_csrintr = {
+	.name =			"CSRintr",
+	.irq_mask =		pen_irq_mask_disable_csrintr,
+	.irq_unmask =		pen_irq_unmask_enable_csrintr,
+#ifdef TRACE_IRQ_DOMAIN_OPS
+	.irq_eoi =		pen_irq_eoi_csrintr,
+#else
+	.irq_eoi =		irq_chip_eoi_parent,
+#endif
+	.irq_set_type =		irq_chip_set_type_parent,
+#ifdef CONFIG_SMP
+	.irq_set_affinity =	irq_chip_set_affinity_parent,
+#endif
+};
+
+/*
+ * Pull the hardware IRQ number from the device tree information
+ * Returns the zero if successful, otherwise a negative errno value
+ */
+static int extract_hwirq(struct irq_fwspec *fwspec, irq_hw_number_t *hwirq)
+{
+
+	/* Verify that the value from the interrupts property is correct */
+	if (fwspec->param_count != N_INTERRUPT_CELLS ||
+		fwspec->param[IRQ_GIC_INTR_TYPE] != GIC_SPI) {
+		pr_err("Invalid value for #interrupts property\n");
+		return -EINVAL;
+	}
+
+	*hwirq = fwspec->param[IRQ_FWSPEC_HWIRQ];
+	if (*hwirq >= MAX_N_IRQS_PER_CHIP) {
+		pr_err("Hardware interrupt number too big (>%lu)", *hwirq);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+/*
+ * This will fill in the param_count and 3 elements of param of a
+ * struct irq_fwspec. It is narrowly tailored for this particular usage
+ * but could fairly easily be generalized.
+ *
+ * Returns 0 on success, or a negative errno on failure.
+ */
+static int pen_get_parent_fwspec(struct irq_domain *d,
+	struct irq_fwspec *fwspec)
+{
+	struct device_node *device;
+	struct device_node *parent;
+	struct pen_ictlr_info *info;
+	u32 intsize;
+	unsigned int i;
+	int err;
+
+	info = d->host_data;
+	device = info->dn;
+
+	/* Look for the interrupt parent. */
+	parent = of_irq_find_parent(device);
+	if (parent == NULL) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	/* Get size of interrupt specifier */
+	if (of_property_read_u32(parent, "#interrupt-cells", &intsize)) {
+		err = -EINVAL;
+		goto out;
+	}
+
+	/* This is not a general solution, fail if it's not one we can do */
+	if (intsize != N_INTERRUPT_CELLS) {
+		err = -EOPNOTSUPP;
+		goto out;
+	}
+
+	fwspec->param_count = N_INTERRUPT_CELLS;
+	for (i = 0; i < intsize; i++) {
+		err = of_property_read_u32_index(device, "interrupts", i,
+			&fwspec->param[i]);
+		if (err != 0)
+			goto out;
+	}
+
+	fwspec->param_count = intsize;
+
+	return 0;
+
+out:
+	of_node_put(parent);
+	return err;
+}
+
+/*
+ * Translate from a value in the device tree interrupts property to a
+ * hardware IRQ number.
+ * @d:		Domain for which translation should be done
+ * @fwspec:	Hardware IRQ information from the device tree for this
+ *		domain
+ * @out_hwirq:	Pointer to place to store the lowest supported hardware IRQ
+ * @out_type:	Pointer to the type of interrupt, e.g. edge, or level triggered
+ */
+static int pen_irq_domain_translate(struct irq_domain *d,
+	struct irq_fwspec *fwspec, irq_hw_number_t *out_hwirq,
+	unsigned int *out_type)
+{
+	if (is_of_node(fwspec->fwnode)) {
+		irq_hw_number_t hwirq;
+		int rc;
+
+		rc = extract_hwirq(fwspec, &hwirq);
+		if (rc != 0)
+			return rc;
+
+		*out_hwirq = hwirq;
+		*out_type = fwspec->param[IRQ_FWSPEC_TYPE] &
+			IRQ_TYPE_SENSE_MASK;
+		return 0;
+	}
+
+	return -EINVAL;
+}
+
+/*
+ * Recursively allocate the IRQ structures for this domain, using information
+ * provided in the device tree
+ * @d:		Domain for which IRQ information should be added
+ * @virq:	Lowest available kernel IRQ number
+ * @nr_irqs:	Number of IRQs to allocate
+ * @fw_data:	Hardware IRQ information for this domain
+ */
+static int pen_irq_domain_alloc(struct irq_domain *d, unsigned int virq,
+	unsigned int nr_irqs, void *fw_data)
+{
+	struct irq_fwspec *fwspec = fw_data;
+	struct irq_fwspec parent_fwspec;
+	struct pen_ictlr_info *info;
+	irq_hw_number_t hwirq;
+	unsigned int i;
+	int rc;
+
+	rc = extract_hwirq(fwspec, &hwirq);
+	if (rc != 0)
+		return rc;
+
+	/* Create the irq structure */
+	info = d->host_data;
+	for (i = 0; i < nr_irqs; i++) {
+		rc = irq_domain_set_hwirq_and_chip(d, virq + i, hwirq + i,
+			info->irq_chip, info);
+		if (rc != 0) {
+			pr_err("irq_domain_set_hwirq_and_chipd failed: %d\n",
+				rc);
+			return rc;
+		}
+	}
+
+	/* Set up the parent information */
+	rc = pen_get_parent_fwspec(d, &parent_fwspec);
+	parent_fwspec.fwnode = d->parent->fwnode;
+
+	rc = irq_domain_alloc_irqs_parent(d, virq, nr_irqs, &parent_fwspec);
+
+	return rc;
+}
+
+static void pen_irq_domain_free(struct irq_domain *d, unsigned int virq,
+				unsigned int nr_irqs)
+{
+	struct irq_data *data = irq_domain_get_irq_data(d, virq);
+
+	irq_domain_reset_irq_data(data);
+}
+
+static const struct irq_domain_ops pen_irq_domain_generic_chip_ops = {
+	.translate =	pen_irq_domain_translate,
+	.alloc =	pen_irq_domain_alloc,
+	.free =		pen_irq_domain_free,
+};
+
+/*
+ * Handle mapping I/O of a device register block
+ */
+static int __init pen_ictlr_iomap_csr(struct device_node *dn,
+				     struct pen_ictlr_info *info)
+{
+	if (info->num_bases != 1) {
+		pr_err("%pOF: reg property needs one tuple but has %u\n",
+			dn, info->num_bases);
+		return -EIO;
+	}
+
+	info->map_base[0] = of_iomap(dn, 0);
+	if (info->map_base[0] == NULL) {
+		pr_err("unable to map registers\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+/*
+ * Handle mapping I/O of a group register block
+ */
+static int __init pen_ictlr_iomap_grp(struct device_node *dn,
+				     struct pen_ictlr_info *info)
+{
+	if (info->num_bases != 1) {
+		pr_err("%pOF: reg property needs one tuple but has %u\n",
+			dn, info->num_bases);
+		return -EIO;
+	}
+
+	info->map_base[0] = of_iomap(dn, 0);
+	if (info->map_base[0] == NULL) {
+		pr_err("unable to map registers\n");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+/*
+ * Handle mapping I/O of a device register block
+ */
+static int __init pen_ictlr_iomap_csrintr(struct device_node *dn,
+					     struct pen_ictlr_info *info)
+{
+	unsigned int i;
+
+	if (info->num_bases < 1) {
+		pr_err("%pOF: reg property needs at least one tuple, has %u\n",
+			dn, info->num_bases);
+		return -EIO;
+	}
+
+	for (i = 0; i < info->num_bases; i++) {
+		info->map_base[i] = of_iomap(dn, i);
+		if (info->map_base[i] == NULL)
+			break;
+	}
+
+	if (i != info->num_bases) {
+		pr_err("only mapped %u of %u regions\n", i, info->num_bases);
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static struct pen_ictlr_info *__init pen_ictlr_probe(struct device_node *dn,
+	 struct device_node *parent, enum reg_type reg_type,
+	 int (*of_iomap_fn)(struct device_node *, struct pen_ictlr_info *),
+	 void (*set_irq_chip_info)(struct irq_chip_type *ct),
+	 struct irq_chip *irq_chip)
+{
+	struct irq_domain *parent_domain;
+	struct pen_ictlr_info *info;
+	unsigned int num_bases;
+	unsigned int info_size;
+	int ret = 0;
+
+	pr_info("Probe IRQ domain controller %s\n", dn->full_name);
+
+	if (parent == NULL) {
+		pr_err("%pOF has no device node parent\n", dn);
+		return ERR_PTR(-ENODEV);
+	}
+
+	parent_domain = irq_find_host(parent);
+	if (parent_domain == NULL) {
+		pr_err("%pOF has no domain parent\n", dn);
+		return ERR_PTR(-ENXIO);
+	}
+
+	/* Count the number of mapped areas */
+	num_bases = 0;
+	for (num_bases = 0; of_get_address(dn, num_bases, NULL, NULL) != NULL;
+		num_bases++) {
+	}
+	if (num_bases == 0) {
+		pr_err("no addresses found in reg property for %pOF\n",
+			dn);
+		return ERR_PTR(ENXIO);
+	}
+
+	/* Allocate a struct pen_ictlr_info and add on space for the
+	 * mapped addresses at the end
+	 */
+	info_size = offsetof(struct pen_ictlr_info, map_base[num_bases]);
+	info = kzalloc(info_size, GFP_KERNEL);
+	if (info == NULL)
+		return ERR_PTR(-ENOMEM);
+	info->num_bases = num_bases;
+
+	/* Set up the mapping to the register block */
+	ret = of_iomap_fn(dn, info);
+	if (ret != 0) {
+		pr_err("Unable to map register block\n");
+		goto out_free_info;
+	}
+
+	/* Create a new domain with a linear IRQ mapping */
+	info->reg_type = reg_type;
+	info->irq_chip = irq_chip;
+	info->domain = irq_domain_add_hierarchy(parent_domain, 0,
+		MAX_N_IRQS_PER_CHIP, dn, &pen_irq_domain_generic_chip_ops,
+		info);
+	if (info->domain == NULL) {
+		pr_err("Unable to create pensando soc domain\n");
+		ret = -ENOMEM;
+		goto out_unmap_regs;
+	}
+
+	info->dn = dn;
+
+	spin_lock_init(&info->irq_lock);
+
+	return info;
+
+out_unmap_regs:
+	if (info->map_base)
+		iounmap(info->map_base);
+
+out_free_info:
+	kfree(info);
+	return ERR_PTR(ret);
+}
+
+static void set_irq_chip_info_csr(struct irq_chip_type *ct)
+{
+	ct->chip.irq_mask = pen_irq_mask_disable_csr;
+	ct->chip.irq_unmask = pen_irq_unmask_enable_csr;
+
+	ct->regs.enable = offsetof(struct pen_ictlr_csr, int_enable_set);
+	ct->regs.disable = offsetof(struct pen_ictlr_csr, int_enable_set);
+	ct->regs.ack = offsetof(struct pen_ictlr_csr, intreg);
+
+	ct->chip.irq_ack = irq_gc_noop;
+}
+
+static void set_irq_chip_info_grp(struct irq_chip_type *ct)
+{
+	ct->chip.irq_mask = pen_irq_mask_disable_grp;
+	ct->chip.irq_unmask = pen_irq_unmask_enable_grp;
+
+	ct->regs.enable = offsetof(struct pen_ictlr_grp, int_enable_rw_reg);
+	ct->regs.disable = offsetof(struct pen_ictlr_grp,
+		int_enable_rw_reg);
+	ct->regs.ack = offsetof(struct pen_ictlr_grp, intreg);
+
+	ct->chip.irq_ack = irq_gc_noop;
+}
+
+static void set_irq_chip_info_csrintr(struct irq_chip_type *ct)
+{
+	ct->chip.irq_mask = pen_irq_mask_disable_csrintr;
+	ct->chip.irq_unmask = pen_irq_unmask_enable_csrintr;
+
+	ct->regs.enable = offsetof(struct pen_ictlr_csrintr, intr);
+	ct->regs.disable = offsetof(struct pen_ictlr_csrintr, intr);
+	ct->regs.ack = offsetof(struct pen_ictlr_csrintr, intr);
+
+	ct->chip.irq_ack = irq_gc_noop;
+}
+
+static int __init pen_ictlr_probe_csr(struct device_node *dn,
+	 struct device_node *parent,
+	 int (*iomap_fn)(struct device_node *,
+		 struct pen_ictlr_info *), struct irq_chip *irq_chip,
+	const char *intc_name)
+{
+	struct pen_ictlr_info *info;
+	int ret = 0;
+
+	info = pen_ictlr_probe(dn, parent, REG_TYPE_CSR, iomap_fn,
+		set_irq_chip_info_csr, &pen_irq_chip_csr);
+	if (IS_ERR(info))
+		return PTR_ERR(info);
+
+	return ret;
+}
+
+static int __init pen_ictlr_probe_grp(struct device_node *dn,
+	 struct device_node *parent,
+	 int (*iomap_fn)(struct device_node *,
+		 struct pen_ictlr_info *), struct irq_chip *irq_chip,
+	 const char *intc_name)
+{
+	struct pen_ictlr_info *info;
+	int ret = 0;
+
+	info = pen_ictlr_probe(dn, parent, REG_TYPE_GRP, iomap_fn,
+		set_irq_chip_info_grp, &pen_irq_chip_grp);
+	if (IS_ERR(info))
+		return PTR_ERR(info);
+
+	return ret;
+}
+
+static int __init pen_ictlr_probe_csrintr(struct device_node *dn,
+	 struct device_node *parent,
+	 int (*iomap_fn)(struct device_node *,
+		 struct pen_ictlr_info *), struct irq_chip *irq_chip,
+	 const char *intc_name)
+{
+	struct pen_ictlr_info *info;
+
+	info = pen_ictlr_probe(dn, parent, REG_TYPE_CSRINTR, iomap_fn,
+		set_irq_chip_info_csrintr, &pen_irq_chip_csrintr);
+	if (IS_ERR(info))
+		return PTR_ERR(info);
+
+	return 0;
+}
+
+/* Probe for device-level interrupts */
+static int __init soc_probe_csr(struct device_node *dn,
+				     struct device_node *parent)
+{
+	pr_info("Probe %pOF\n", dn);
+	return pen_ictlr_probe_csr(dn, parent,
+		pen_ictlr_iomap_csr, &pen_irq_chip_csr,
+		"Pensando SOC CSR");
+}
+
+/* Probe for group-level interrupts */
+static int __init soc_probe_grp(struct device_node *dn,
+				     struct device_node *parent)
+{
+	pr_info("Probe %pOF\n", dn);
+	return pen_ictlr_probe_grp(dn, parent,
+		pen_ictlr_iomap_grp, &pen_irq_chip_grp,
+		"Pensando SOC GRP");
+}
+
+/* Probe for module-level interrupts */
+static int __init soc_probe_csrintr(struct device_node *dn,
+				     struct device_node *parent)
+{
+	pr_info("Probe %pOF\n", dn);
+	return pen_ictlr_probe_csrintr(dn, parent,
+		pen_ictlr_iomap_csrintr, &pen_irq_chip_csrintr,
+		"Pensando SOC CSR Intr");
+}
+
+IRQCHIP_DECLARE(soc_ictlr_csr, "pensando,soc-ictlr-csr",
+	soc_probe_csr);
+IRQCHIP_DECLARE(soc_ictlr_grp, "pensando,soc-ictlr-grp",
+	soc_probe_grp);
+IRQCHIP_DECLARE(soc_ictlr_csrintr, "pensando,soc-ictlr-csrintr",
+	soc_probe_csrintr);
diff --git a/drivers/mfd/Kconfig b/drivers/mfd/Kconfig
index b8847ae..94d9a9d 100644
--- a/drivers/mfd/Kconfig
+++ b/drivers/mfd/Kconfig
@@ -1035,6 +1035,20 @@ config UCB1400_CORE
 	  To compile this driver as a module, choose M here: the
 	  module will be called ucb1400_core.
 
+config MFD_PENSANDO_ELBASR
+	bool "AMD Pensando Elba System Resource chip"
+	depends on SPI_MASTER=y
+	depends on (ARCH_PENSANDO && OF) || COMPILE_TEST
+	select REGMAP_SPI
+	select MFD_CORE
+	select MFD_SYSCON
+	help
+	  Support for the AMD Pensando Elba SoC System Resource chip using the
+	  SPI interface.  This driver provides userspace access to four device
+	  functions to include CS0 device registers, CS1 smbus interface for
+	  FRU and board peripherals, CS2 dual Lattice I2C masters for
+	  transceiver management, and CS3 flash for firmware update.
+
 config MFD_PM8XXX
 	tristate "Qualcomm PM8xxx PMIC chips driver"
 	depends on (ARM || HEXAGON || COMPILE_TEST)
diff --git a/drivers/mfd/Makefile b/drivers/mfd/Makefile
index 1780019..2c41e61 100644
--- a/drivers/mfd/Makefile
+++ b/drivers/mfd/Makefile
@@ -217,6 +217,7 @@ obj-$(CONFIG_MFD_INTEL_LPSS_ACPI)	+= intel-lpss-acpi.o
 obj-$(CONFIG_MFD_INTEL_MSIC)	+= intel_msic.o
 obj-$(CONFIG_MFD_INTEL_PMC_BXT)	+= intel_pmc_bxt.o
 obj-$(CONFIG_MFD_PALMAS)	+= palmas.o
+obj-$(CONFIG_MFD_PENSANDO_ELBASR)	+= pensando-elbasr.o
 obj-$(CONFIG_MFD_VIPERBOARD)    += viperboard.o
 obj-$(CONFIG_MFD_RC5T583)	+= rc5t583.o rc5t583-irq.o
 obj-$(CONFIG_MFD_RK808)		+= rk808.o
diff --git a/drivers/mfd/pensando-elbasr.c b/drivers/mfd/pensando-elbasr.c
new file mode 100644
index 00000000..fe41d92
--- /dev/null
+++ b/drivers/mfd/pensando-elbasr.c
@@ -0,0 +1,867 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * AMD Pensando Elba System Resource MFD Driver
+ *
+ * Userspace interface and reset driver support for SPI connected
+ * Pensando Elba System Resource Chip.
+ *
+ * Adapted from spidev.c
+ *
+ * Copyright (C) 2006 SWAPP
+ *	Andrea Paterniani <a.paterniani@swapp-eng.it>
+ * Copyright (C) 2007 David Brownell (simplification, cleanup)
+ * Copyright (C) 2022 Advanced Micro Devices, Inc.
+ */
+
+#include <linux/mfd/pensando-elbasr.h>
+#include <linux/mfd/core.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/ioctl.h>
+#include <linux/fs.h>
+#include <linux/device.h>
+#include <linux/err.h>
+#include <linux/list.h>
+#include <linux/errno.h>
+#include <linux/mutex.h>
+#include <linux/slab.h>
+#include <linux/compat.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/regmap.h>
+#include <linux/spi/spi.h>
+#include <linux/spi/spidev.h>
+#include <linux/delay.h>
+
+#define ELBASR_SPI_CMD_REGRD	0x0b
+#define ELBASR_SPI_CMD_REGWR	0x02
+#define ELBASR_MAX_DEVS		4
+
+/* The main reason to have this class is to make mdev/udev create the
+ * /dev/spidevB.C character device nodes exposing our userspace API.
+ * It also simplifies memory management.  The device nodes
+ * /dev/spidevB.C are used for backward compatibility.
+ */
+static struct class *elbasr_class;
+
+static dev_t elbasr_devt;
+static DECLARE_BITMAP(minors, ELBASR_MAX_DEVS);
+static unsigned int bufsiz = 4096;
+
+static LIST_HEAD(device_list);
+static DEFINE_MUTEX(device_list_lock);
+
+static const struct mfd_cell pensando_elbasr_subdev_info[] = {
+	{
+		.name = "pensando_elbasr_reset",
+		.of_compatible = "amd,pensando-elbasr-reset",
+	},
+};
+
+/* Bit masks for spi_device.mode management.  Note that incorrect
+ * settings for some settings can cause *lots* of trouble for other
+ * devices on a shared bus:
+ *
+ *  - CS_HIGH ... this device will be active when it shouldn't be
+ *  - 3WIRE ... when active, it won't behave as it should
+ *  - NO_CS ... there will be no explicit message boundaries; this
+ *	is completely incompatible with the shared bus model
+ *  - READY ... transfers may proceed when they shouldn't.
+ */
+#define SPI_MODE_MASK		(SPI_CPHA | SPI_CPOL | SPI_CS_HIGH \
+				| SPI_LSB_FIRST | SPI_3WIRE | SPI_LOOP \
+				| SPI_NO_CS | SPI_READY | SPI_TX_DUAL \
+				| SPI_TX_QUAD | SPI_TX_OCTAL | SPI_RX_DUAL \
+				| SPI_RX_QUAD | SPI_RX_OCTAL)
+
+static ssize_t
+elbasr_spi_sync(struct elbasr_data *elbasr_spi, struct spi_message *message)
+{
+	int status;
+	struct spi_device *spi;
+
+	spin_lock_irq(&elbasr_spi->spi_lock);
+	spi = elbasr_spi->spi;
+	spin_unlock_irq(&elbasr_spi->spi_lock);
+
+	if (spi == NULL)
+		status = -ESHUTDOWN;
+	else
+		status = spi_sync(spi, message);
+
+	if (status == 0)
+		status = message->actual_length;
+
+	return status;
+}
+
+static inline ssize_t
+elbasr_spi_sync_write(struct elbasr_data *elbasr, size_t len)
+{
+	struct spi_transfer	t = {
+			.tx_buf		= elbasr->tx_buffer,
+			.len		= len,
+			.speed_hz	= elbasr->speed_hz,
+		};
+	struct spi_message	m;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+	return elbasr_spi_sync(elbasr, &m);
+}
+
+static inline ssize_t
+elbasr_spi_sync_read(struct elbasr_data *elbasr, size_t len)
+{
+	struct spi_transfer	t = {
+			.rx_buf		= elbasr->rx_buffer,
+			.len		= len,
+			.speed_hz	= elbasr->speed_hz,
+		};
+	struct spi_message	m;
+
+	spi_message_init(&m);
+	spi_message_add_tail(&t, &m);
+	return elbasr_spi_sync(elbasr, &m);
+}
+
+/* Read-only message with current device setup */
+static ssize_t
+elbasr_spi_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+	struct elbasr_data *elbasr;
+	ssize_t status;
+
+	/* chipselect only toggles at start or end of operation */
+	if (count > bufsiz)
+		return -EMSGSIZE;
+
+	elbasr = filp->private_data;
+
+	mutex_lock(&elbasr->buf_lock);
+	status = elbasr_spi_sync_read(elbasr, count);
+	if (status > 0) {
+		unsigned long missing;
+
+		missing = copy_to_user(buf, elbasr->rx_buffer, status);
+		if (missing == status)
+			status = -EFAULT;
+		else
+			status = status - missing;
+	}
+	mutex_unlock(&elbasr->buf_lock);
+
+	return status;
+}
+
+/* Write-only message with current device setup */
+static ssize_t
+elbasr_spi_write(struct file *filp, const char __user *buf,
+		 size_t count, loff_t *f_pos)
+{
+	struct elbasr_data *elbasr;
+	ssize_t status;
+	unsigned long missing;
+
+	/* chipselect only toggles at start or end of operation */
+	if (count > bufsiz)
+		return -EMSGSIZE;
+
+	elbasr = filp->private_data;
+
+	mutex_lock(&elbasr->buf_lock);
+	missing = copy_from_user(elbasr->tx_buffer, buf, count);
+	if (missing == 0)
+		status = elbasr_spi_sync_write(elbasr, count);
+	else
+		status = -EFAULT;
+	mutex_unlock(&elbasr->buf_lock);
+
+	return status;
+}
+
+static int elbasr_spi_message(struct elbasr_data *elbasr,
+			      struct spi_ioc_transfer *u_xfers,
+			      unsigned int n_xfers)
+{
+	struct spi_message msg;
+	struct spi_transfer *k_xfers;
+	struct spi_transfer *k_tmp;
+	struct spi_ioc_transfer *u_tmp;
+	unsigned int n, total, tx_total, rx_total;
+	u8 *tx_buf, *rx_buf;
+	int status = -EFAULT;
+
+	spi_message_init(&msg);
+	k_xfers = kcalloc(n_xfers, sizeof(*k_tmp), GFP_KERNEL);
+	if (k_xfers == NULL)
+		return -ENOMEM;
+
+	/* Construct spi_message, copying any tx data to bounce buffer.
+	 * We walk the array of user-provided transfers, using each one
+	 * to initialize a kernel version of the same transfer.
+	 */
+	tx_buf = elbasr->tx_buffer;
+	rx_buf = elbasr->rx_buffer;
+	total = 0;
+	tx_total = 0;
+	rx_total = 0;
+	for (n = n_xfers, k_tmp = k_xfers, u_tmp = u_xfers;
+			n;
+			n--, k_tmp++, u_tmp++) {
+		/* Ensure that also following allocations from rx_buf/tx_buf will meet
+		 * DMA alignment requirements.
+		 */
+		unsigned int len_aligned = ALIGN(u_tmp->len,
+						 ARCH_KMALLOC_MINALIGN);
+
+		k_tmp->len = u_tmp->len;
+
+		total += k_tmp->len;
+		/* Since the function returns the total length of transfers
+		 * on success, restrict the total to positive int values to
+		 * avoid the return value looking like an error.  Also check
+		 * each transfer length to avoid arithmetic overflow.
+		 */
+		if (total > INT_MAX || k_tmp->len > INT_MAX) {
+			status = -EMSGSIZE;
+			goto done;
+		}
+
+		if (u_tmp->rx_buf) {
+			/* this transfer needs space in RX bounce buffer */
+			rx_total += len_aligned;
+			if (rx_total > bufsiz) {
+				status = -EMSGSIZE;
+				goto done;
+			}
+			k_tmp->rx_buf = rx_buf;
+			rx_buf += len_aligned;
+		}
+		if (u_tmp->tx_buf) {
+			/* this transfer needs space in TX bounce buffer */
+			tx_total += len_aligned;
+			if (tx_total > bufsiz) {
+				status = -EMSGSIZE;
+				goto done;
+			}
+			k_tmp->tx_buf = tx_buf;
+			if (copy_from_user(tx_buf, (const u8 __user *)
+						(uintptr_t) u_tmp->tx_buf,
+					u_tmp->len))
+				goto done;
+			tx_buf += len_aligned;
+		}
+
+		k_tmp->cs_change = !!u_tmp->cs_change;
+		k_tmp->tx_nbits = u_tmp->tx_nbits;
+		k_tmp->rx_nbits = u_tmp->rx_nbits;
+		k_tmp->bits_per_word = u_tmp->bits_per_word;
+		k_tmp->delay.value = u_tmp->delay_usecs;
+		k_tmp->delay.unit = SPI_DELAY_UNIT_USECS;
+		k_tmp->speed_hz = u_tmp->speed_hz;
+		k_tmp->word_delay.value = u_tmp->word_delay_usecs;
+		k_tmp->word_delay.unit = SPI_DELAY_UNIT_USECS;
+		if (!k_tmp->speed_hz)
+			k_tmp->speed_hz = elbasr->speed_hz;
+#ifdef VERBOSE
+		dev_dbg(&elbasr->spi->dev,
+			" xfer len %u %s%s%s%dbits %u usec %u usec %uHz (%u)\n",
+			k_tmp->len,
+			k_tmp->rx_buf ? "rx " : "",
+			k_tmp->tx_buf ? "tx " : "",
+			k_tmp->cs_change ? "cs " : "",
+			k_tmp->bits_per_word ? : elbasr->spi->bits_per_word,
+			k_tmp->delay.value,
+			k_tmp->word_delay.value,
+			k_tmp->speed_hz ? : elbasr->spi->max_speed_hz);
+#endif
+		spi_message_add_tail(k_tmp, &msg);
+	}
+
+	status = elbasr_spi_sync(elbasr, &msg);
+	if (status < 0)
+		goto done;
+
+	/* copy any rx data out of bounce buffer */
+	for (n = n_xfers, k_tmp = k_xfers, u_tmp = u_xfers;
+			n;
+			n--, k_tmp++, u_tmp++) {
+		if (u_tmp->rx_buf) {
+			if (copy_to_user((u8 __user *)
+					(uintptr_t) u_tmp->rx_buf, k_tmp->rx_buf,
+					u_tmp->len)) {
+				status = -EFAULT;
+				goto done;
+			}
+		}
+	}
+	status = total;
+
+done:
+	kfree(k_xfers);
+	return status;
+}
+
+static struct spi_ioc_transfer *
+elbasr_spi_get_ioc_message(unsigned int cmd,
+			   struct spi_ioc_transfer __user *u_ioc,
+			   unsigned int *n_ioc)
+{
+	u32 tmp;
+
+	/* Check type, command number and direction */
+	if (_IOC_TYPE(cmd) != SPI_IOC_MAGIC
+			|| _IOC_NR(cmd) != _IOC_NR(SPI_IOC_MESSAGE(0))
+			|| _IOC_DIR(cmd) != _IOC_WRITE)
+		return ERR_PTR(-ENOTTY);
+
+	tmp = _IOC_SIZE(cmd);
+	if ((tmp % sizeof(struct spi_ioc_transfer)) != 0)
+		return ERR_PTR(-EINVAL);
+	*n_ioc = tmp / sizeof(struct spi_ioc_transfer);
+	if (*n_ioc == 0)
+		return NULL;
+
+	/* copy into scratch area */
+	return memdup_user(u_ioc, tmp);
+}
+
+static long
+elbasr_spi_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	int retval = 0;
+	struct elbasr_data *elbasr;
+	struct spi_device *spi;
+	u32 tmp;
+	unsigned int n_ioc;
+	struct spi_ioc_transfer	*ioc;
+
+	/* Check type and command number */
+	if (_IOC_TYPE(cmd) != SPI_IOC_MAGIC)
+		return -ENOTTY;
+
+	/* guard against device removal before, or while,
+	 * we issue this ioctl.
+	 */
+	elbasr = filp->private_data;
+	spin_lock_irq(&elbasr->spi_lock);
+	spi = spi_dev_get(elbasr->spi);
+	spin_unlock_irq(&elbasr->spi_lock);
+
+	if (spi == NULL)
+		return -ESHUTDOWN;
+
+	/* use the buffer lock here for triple duty:
+	 *  - prevent I/O (from us) so calling spi_setup() is safe;
+	 *  - prevent concurrent SPI_IOC_WR_* from morphing
+	 *    data fields while SPI_IOC_RD_* reads them;
+	 *  - SPI_IOC_MESSAGE needs the buffer locked "normally".
+	 */
+	mutex_lock(&elbasr->buf_lock);
+
+	switch (cmd) {
+	/* read requests */
+	case SPI_IOC_RD_MODE:
+		retval = put_user(spi->mode & SPI_MODE_MASK,
+					(__u8 __user *)arg);
+		break;
+	case SPI_IOC_RD_MODE32:
+		retval = put_user(spi->mode & SPI_MODE_MASK,
+					(__u32 __user *)arg);
+		break;
+	case SPI_IOC_RD_LSB_FIRST:
+		retval = put_user((spi->mode & SPI_LSB_FIRST) ?  1 : 0,
+					(__u8 __user *)arg);
+		break;
+	case SPI_IOC_RD_BITS_PER_WORD:
+		retval = put_user(spi->bits_per_word, (__u8 __user *)arg);
+		break;
+	case SPI_IOC_RD_MAX_SPEED_HZ:
+		retval = put_user(elbasr->speed_hz, (__u32 __user *)arg);
+		break;
+
+	/* write requests */
+	case SPI_IOC_WR_MODE:
+	case SPI_IOC_WR_MODE32:
+		if (cmd == SPI_IOC_WR_MODE)
+			retval = get_user(tmp, (u8 __user *)arg);
+		else
+			retval = get_user(tmp, (u32 __user *)arg);
+		if (retval == 0) {
+			struct spi_controller *ctlr = spi->controller;
+			u32	save = spi->mode;
+
+			if (tmp & ~SPI_MODE_MASK) {
+				retval = -EINVAL;
+				break;
+			}
+
+			if (ctlr->use_gpio_descriptors && ctlr->cs_gpiods &&
+			    ctlr->cs_gpiods[spi->chip_select])
+				tmp |= SPI_CS_HIGH;
+
+			tmp |= spi->mode & ~SPI_MODE_MASK;
+			spi->mode = (u16)tmp;
+			retval = spi_setup(spi);
+			if (retval < 0)
+				spi->mode = save;
+			else
+				dev_dbg(&spi->dev, "spi mode %x\n", tmp);
+		}
+		break;
+	case SPI_IOC_WR_LSB_FIRST:
+		retval = get_user(tmp, (__u8 __user *)arg);
+		if (retval == 0) {
+			u32	save = spi->mode;
+
+			if (tmp)
+				spi->mode |= SPI_LSB_FIRST;
+			else
+				spi->mode &= ~SPI_LSB_FIRST;
+			retval = spi_setup(spi);
+			if (retval < 0)
+				spi->mode = save;
+			else
+				dev_dbg(&spi->dev, "%csb first\n",
+						tmp ? 'l' : 'm');
+		}
+		break;
+	case SPI_IOC_WR_BITS_PER_WORD:
+		retval = get_user(tmp, (__u8 __user *)arg);
+		if (retval == 0) {
+			u8	save = spi->bits_per_word;
+
+			spi->bits_per_word = tmp;
+			retval = spi_setup(spi);
+			if (retval < 0)
+				spi->bits_per_word = save;
+			else
+				dev_dbg(&spi->dev, "%d bits per word\n", tmp);
+		}
+		break;
+	case SPI_IOC_WR_MAX_SPEED_HZ:
+		retval = get_user(tmp, (__u32 __user *)arg);
+		if (retval == 0) {
+			u32	save = spi->max_speed_hz;
+
+			spi->max_speed_hz = tmp;
+			retval = spi_setup(spi);
+			if (retval == 0) {
+				elbasr->speed_hz = tmp;
+				dev_dbg(&spi->dev, "%d Hz (max)\n",
+					elbasr->speed_hz);
+			}
+			spi->max_speed_hz = save;
+		}
+		break;
+
+	default:
+		/* segmented and/or full-duplex I/O request */
+		/* Check message and copy into scratch area */
+		ioc = elbasr_spi_get_ioc_message(cmd,
+				(struct spi_ioc_transfer __user *)arg, &n_ioc);
+		if (IS_ERR(ioc)) {
+			retval = PTR_ERR(ioc);
+			break;
+		}
+		if (!ioc)
+			break;	/* n_ioc is also 0 */
+
+		/* translate to spi_message, execute */
+		retval = elbasr_spi_message(elbasr, ioc, n_ioc);
+		kfree(ioc);
+		break;
+	}
+
+	mutex_unlock(&elbasr->buf_lock);
+	spi_dev_put(spi);
+	return retval;
+}
+
+#ifdef CONFIG_COMPAT
+static long
+elbasr_spi_compat_ioc_message(struct file *filp, unsigned int cmd,
+			      unsigned long arg)
+{
+	struct spi_ioc_transfer __user *u_ioc;
+	int retval = 0;
+	struct elbasr_data *elbasr;
+	struct spi_device *spi;
+	unsigned int n_ioc, n;
+	struct spi_ioc_transfer *ioc;
+
+	u_ioc = (struct spi_ioc_transfer __user *) compat_ptr(arg);
+
+	/* guard against device removal before, or while,
+	 * we issue this ioctl.
+	 */
+	elbasr = filp->private_data;
+	spin_lock_irq(&elbasr->spi_lock);
+	spi = spi_dev_get(elbasr->spi);
+	spin_unlock_irq(&elbasr->spi_lock);
+
+	if (spi == NULL)
+		return -ESHUTDOWN;
+
+	/* SPI_IOC_MESSAGE needs the buffer locked "normally" */
+	mutex_lock(&elbasr->buf_lock);
+
+	/* Check message and copy into scratch area */
+	ioc = elbasr_spi_get_ioc_message(cmd, u_ioc, &n_ioc);
+	if (IS_ERR(ioc)) {
+		retval = PTR_ERR(ioc);
+		goto done;
+	}
+	if (!ioc)
+		goto done;	/* n_ioc is also 0 */
+
+	/* Convert buffer pointers */
+	for (n = 0; n < n_ioc; n++) {
+		ioc[n].rx_buf = (uintptr_t) compat_ptr(ioc[n].rx_buf);
+		ioc[n].tx_buf = (uintptr_t) compat_ptr(ioc[n].tx_buf);
+	}
+
+	/* translate to spi_message, execute */
+	retval = elbasr_spi_message(elbasr, ioc, n_ioc);
+	kfree(ioc);
+
+done:
+	mutex_unlock(&elbasr->buf_lock);
+	spi_dev_put(spi);
+	return retval;
+}
+
+static long
+elbasr_spi_compat_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+	if (_IOC_TYPE(cmd) == SPI_IOC_MAGIC
+			&& _IOC_NR(cmd) == _IOC_NR(SPI_IOC_MESSAGE(0))
+			&& _IOC_DIR(cmd) == _IOC_WRITE)
+		return elbasr_spi_compat_ioc_message(filp, cmd, arg);
+
+	return elbasr_spi_ioctl(filp, cmd, (unsigned long)compat_ptr(arg));
+}
+#else
+#define elbasr_spi_compat_ioctl NULL
+#endif /* CONFIG_COMPAT */
+
+static int elbasr_spi_open(struct inode *inode, struct file *filp)
+{
+	struct elbasr_data *elbasr;
+	int status = -ENXIO;
+
+	mutex_lock(&device_list_lock);
+
+	list_for_each_entry(elbasr, &device_list, device_entry) {
+		if (elbasr->devt == inode->i_rdev) {
+			status = 0;
+			break;
+		}
+	}
+
+	if (status) {
+		pr_debug("elbasr_spi: nothing for minor %d\n", iminor(inode));
+		goto err_find_dev;
+	}
+
+	if (!elbasr->tx_buffer) {
+		elbasr->tx_buffer = kmalloc(bufsiz, GFP_KERNEL);
+		if (!elbasr->tx_buffer) {
+			status = -ENOMEM;
+			goto err_find_dev;
+		}
+	}
+
+	if (!elbasr->rx_buffer) {
+		elbasr->rx_buffer = kmalloc(bufsiz, GFP_KERNEL);
+		if (!elbasr->rx_buffer) {
+			status = -ENOMEM;
+			goto err_alloc_rx_buf;
+		}
+	}
+
+	elbasr->users++;
+	filp->private_data = elbasr;
+	stream_open(inode, filp);
+
+	mutex_unlock(&device_list_lock);
+	return 0;
+
+err_alloc_rx_buf:
+	kfree(elbasr->tx_buffer);
+	elbasr->tx_buffer = NULL;
+err_find_dev:
+	mutex_unlock(&device_list_lock);
+	return status;
+}
+
+static int elbasr_spi_release(struct inode *inode, struct file *filp)
+{
+	struct elbasr_data *elbasr;
+	int dofree;
+
+	mutex_lock(&device_list_lock);
+	elbasr = filp->private_data;
+	filp->private_data = NULL;
+
+	spin_lock_irq(&elbasr->spi_lock);
+	/* ... after we unbound from the underlying device? */
+	dofree = (elbasr->spi == NULL);
+	spin_unlock_irq(&elbasr->spi_lock);
+
+	/* last close? */
+	elbasr->users--;
+	if (!elbasr->users) {
+
+		kfree(elbasr->tx_buffer);
+		elbasr->tx_buffer = NULL;
+
+		kfree(elbasr->rx_buffer);
+		elbasr->rx_buffer = NULL;
+
+		if (dofree)
+			kfree(elbasr);
+		else
+			elbasr->speed_hz = elbasr->spi->max_speed_hz;
+	}
+#ifdef CONFIG_SPI_SLAVE
+	if (!dofree)
+		spi_slave_abort(elbasr->spi);
+#endif
+	mutex_unlock(&device_list_lock);
+
+	return 0;
+}
+
+static const struct file_operations elbasr_spi_fops = {
+	.owner =	THIS_MODULE,
+	.write =	elbasr_spi_write,
+	.read =		elbasr_spi_read,
+	.unlocked_ioctl = elbasr_spi_ioctl,
+	.compat_ioctl = elbasr_spi_compat_ioctl,
+	.open =		elbasr_spi_open,
+	.release =	elbasr_spi_release,
+	.llseek =	no_llseek,
+};
+
+static bool
+elbasr_reg_readable(struct device *dev, unsigned int reg)
+{
+	return reg <= ELBASR_MAX_REG;
+}
+
+static bool
+elbasr_reg_writeable(struct device *dev, unsigned int reg)
+{
+	return reg <= ELBASR_MAX_REG;
+}
+
+static int
+elbasr_regs_read(void *ctx, u32 reg, u32 *val)
+{
+	struct elbasr_data *elbasr = dev_get_drvdata(ctx);
+	struct spi_message m;
+	struct spi_transfer t[2] = { { 0 } };
+	int ret;
+	u8 txbuf[3];
+	u8 rxbuf[1];
+
+	spi_message_init(&m);
+
+	txbuf[0] = ELBASR_SPI_CMD_REGRD;
+	txbuf[1] = reg;
+	txbuf[2] = 0x0;
+	t[0].tx_buf = (u8 *)txbuf;
+	t[0].len = 3;
+
+	rxbuf[0] = 0x0;
+	t[1].rx_buf = rxbuf;
+	t[1].len = 1;
+
+	spi_message_add_tail(&t[0], &m);
+	spi_message_add_tail(&t[1], &m);
+
+	ret = elbasr_spi_sync(elbasr, &m);
+	if (ret == 4) {
+		// 3 Tx + 1 Rx = 4
+		*val = rxbuf[0];
+		return 0;
+	}
+	return -EIO;
+}
+
+static int
+elbasr_regs_write(void *ctx, u32 reg, u32 val)
+{
+	struct elbasr_data *elbasr = dev_get_drvdata(ctx);
+	struct spi_message m;
+	struct spi_transfer t[1] = { { 0 } };
+	u8 txbuf[4];
+
+	spi_message_init(&m);
+	txbuf[0] = ELBASR_SPI_CMD_REGWR;
+	txbuf[1] = reg;
+	txbuf[2] = val;
+	txbuf[3] = 0;
+
+	t[0].tx_buf = txbuf;
+	t[0].len = 4;
+
+	spi_message_add_tail(&t[0], &m);
+
+	return elbasr_spi_sync(elbasr, &m);
+}
+
+static const struct regmap_config pensando_elbasr_regmap_config = {
+	.reg_bits = 8,
+	.val_bits = 8,
+	.cache_type = REGCACHE_NONE,
+	.readable_reg = elbasr_reg_readable,
+	.writeable_reg = elbasr_reg_writeable,
+	.reg_read = elbasr_regs_read,
+	.reg_write = elbasr_regs_write,
+	.max_register = ELBASR_MAX_REG
+};
+
+/*
+ * Setup Elba SPI access to System Resource Chip registers on CS0
+ */
+static int
+elbasr_regs_setup(struct spi_device *spi, struct elbasr_data *elbasr)
+{
+	int ret;
+
+	spi->bits_per_word = 8;
+	spi_setup(spi);
+	spi->dev.dma_mask = &spi->dev.coherent_dma_mask;
+	elbasr->elbasr_regs = devm_regmap_init(&spi->dev, NULL, spi,
+					       &pensando_elbasr_regmap_config);
+	if (IS_ERR(elbasr->elbasr_regs)) {
+		ret = PTR_ERR(elbasr->elbasr_regs);
+		dev_err(&spi->dev, "Failed to allocate register map: %d\n", ret);
+		return ret;
+	}
+
+	ret = devm_mfd_add_devices(&spi->dev, PLATFORM_DEVID_NONE,
+				   pensando_elbasr_subdev_info,
+				   ARRAY_SIZE(pensando_elbasr_subdev_info),
+				   NULL, 0, NULL);
+	if (ret)
+		dev_err(&spi->dev, "Failed to register sub-devices: %d\n", ret);
+
+	return ret;
+}
+
+static int elbasr_spi_probe(struct spi_device *spi)
+{
+	struct elbasr_data *elbasr;
+	unsigned long minor;
+	int status;
+
+	if (spi->chip_select == 0) {
+		status = alloc_chrdev_region(&elbasr_devt, 0, ELBASR_MAX_DEVS,
+					     "elbasr");
+		if (status < 0)
+			return status;
+
+		elbasr_class = class_create(THIS_MODULE, "elbasr");
+		if (IS_ERR(elbasr_class)) {
+			unregister_chrdev(MAJOR(elbasr_devt), "elbasr");
+			return PTR_ERR(elbasr_class);
+		}
+	}
+
+	/* Allocate driver data */
+	elbasr = kzalloc(sizeof(*elbasr), GFP_KERNEL);
+	if (!elbasr) {
+		if (spi->chip_select == 0)
+			unregister_chrdev(MAJOR(elbasr_devt), "elbasr");
+		return -ENOMEM;
+	}
+
+	/* Initialize the driver data */
+	elbasr->spi = spi;
+	elbasr->speed_hz = spi->max_speed_hz;
+	spin_lock_init(&elbasr->spi_lock);
+	mutex_init(&elbasr->buf_lock);
+
+	INIT_LIST_HEAD(&elbasr->device_entry);
+
+	mutex_lock(&device_list_lock);
+	minor = find_first_zero_bit(minors, ELBASR_MAX_DEVS);
+	if (minor < ELBASR_MAX_DEVS) {
+		struct device *dev;
+
+		elbasr->devt = MKDEV(MAJOR(elbasr_devt), minor);
+		dev = device_create(elbasr_class,
+				    &spi->dev,
+				    elbasr->devt,
+				    elbasr,
+				    "spidev%d.%d",
+				    spi->master->bus_num,
+				    spi->chip_select);
+
+		status = PTR_ERR_OR_ZERO(dev);
+	} else {
+		dev_dbg(&spi->dev, "no minor number available\n");
+		status = -ENODEV;
+		mutex_unlock(&device_list_lock);
+		goto minor_failed;
+	}
+
+	set_bit(minor, minors);
+	list_add(&elbasr->device_entry, &device_list);
+	dev_dbg(&spi->dev,
+		"created device for major %d, minor %lu\n",
+		MAJOR(elbasr_devt), minor);
+	mutex_unlock(&device_list_lock);
+
+	/* Create cdev */
+	elbasr->cdev = cdev_alloc();
+	if (!elbasr->cdev) {
+		dev_err(elbasr->dev, "allocation of cdev failed");
+		status = -ENOMEM;
+		goto cdev_failed;
+	}
+	elbasr->cdev->owner = THIS_MODULE;
+	cdev_init(elbasr->cdev, &elbasr_spi_fops);
+
+	status = cdev_add(elbasr->cdev, elbasr->devt, 1);
+	if (status) {
+		dev_err(elbasr->dev, "register of cdev failed");
+		goto cdev_delete;
+	}
+	spi_set_drvdata(spi, elbasr);
+
+	/* Add Elba reset driver sub-device */
+	if (spi->chip_select == 0)
+		elbasr_regs_setup(spi, elbasr);
+
+	return 0;
+
+cdev_delete:
+	if (spi->chip_select == 0)
+		cdev_del(elbasr->cdev);
+cdev_failed:
+	if (spi->chip_select == 0)
+		device_destroy(elbasr_class, elbasr->devt);
+minor_failed:
+	kfree(elbasr);
+
+	return status;
+}
+
+static const struct of_device_id elbasr_spi_of_match[] = {
+	{ .compatible = "amd,pensando-elbasr" },
+	{ /* sentinel */ },
+};
+
+static struct spi_driver elbasr_spi_driver = {
+	.probe = elbasr_spi_probe,
+	.driver = {
+		.name = "elbasr",
+		.of_match_table = of_match_ptr(elbasr_spi_of_match),
+	},
+};
+builtin_driver(elbasr_spi_driver, spi_register_driver)
diff --git a/drivers/mmc/host/Kconfig b/drivers/mmc/host/Kconfig
index 30ff42f..6aa5d1c 100644
--- a/drivers/mmc/host/Kconfig
+++ b/drivers/mmc/host/Kconfig
@@ -229,6 +229,7 @@ config MMC_SDHCI_CADENCE
 	tristate "SDHCI support for the Cadence SD/SDIO/eMMC controller"
 	depends on MMC_SDHCI_PLTFM
 	depends on OF
+	select MMC_SDHCI_IO_ACCESSORS
 	help
 	  This selects the Cadence SD/SDIO/eMMC driver.
 
diff --git a/drivers/mmc/host/sdhci-cadence.c b/drivers/mmc/host/sdhci-cadence.c
index 6f2de54..9b096c5 100644
--- a/drivers/mmc/host/sdhci-cadence.c
+++ b/drivers/mmc/host/sdhci-cadence.c
@@ -12,6 +12,7 @@
 #include <linux/mmc/mmc.h>
 #include <linux/of.h>
 #include <linux/of_device.h>
+#include <linux/reset.h>
 
 #include "sdhci-pltfm.h"
 
@@ -66,7 +67,12 @@ struct sdhci_cdns_phy_param {
 
 struct sdhci_cdns_priv {
 	void __iomem *hrs_addr;
+	void __iomem *ctl_addr;	/* write control */
+	spinlock_t wrlock;	/* write lock */
 	bool enhanced_strobe;
+	void (*priv_write_l)(struct sdhci_cdns_priv *priv, u32 val,
+			     void __iomem *reg);
+	struct reset_control *rst_hw;
 	unsigned int nr_phy_params;
 	struct sdhci_cdns_phy_param phy_params[];
 };
@@ -76,6 +82,11 @@ struct sdhci_cdns_phy_cfg {
 	u8 addr;
 };
 
+struct sdhci_cdns_drv_data {
+	int (*init)(struct platform_device *pdev);
+	const struct sdhci_pltfm_data pltfm_data;
+};
+
 static const struct sdhci_cdns_phy_cfg sdhci_cdns_phy_cfgs[] = {
 	{ "cdns,phy-input-delay-sd-highspeed", SDHCI_CDNS_PHY_DLY_SD_HS, },
 	{ "cdns,phy-input-delay-legacy", SDHCI_CDNS_PHY_DLY_SD_DEFAULT, },
@@ -90,6 +101,15 @@ struct sdhci_cdns_phy_cfg {
 	{ "cdns,phy-dll-delay-strobe", SDHCI_CDNS_PHY_DLY_STROBE, },
 };
 
+static inline void sdhci_cdns_priv_writel(struct sdhci_cdns_priv *priv,
+					  u32 val, void __iomem *reg)
+{
+	if (unlikely(priv->priv_write_l))
+		priv->priv_write_l(priv, val, reg);
+	else
+		writel(val, reg);
+}
+
 static int sdhci_cdns_write_phy_reg(struct sdhci_cdns_priv *priv,
 				    u8 addr, u8 data)
 {
@@ -104,17 +124,17 @@ static int sdhci_cdns_write_phy_reg(struct sdhci_cdns_priv *priv,
 
 	tmp = FIELD_PREP(SDHCI_CDNS_HRS04_WDATA, data) |
 	      FIELD_PREP(SDHCI_CDNS_HRS04_ADDR, addr);
-	writel(tmp, reg);
+	sdhci_cdns_priv_writel(priv, tmp, reg);
 
 	tmp |= SDHCI_CDNS_HRS04_WR;
-	writel(tmp, reg);
+	sdhci_cdns_priv_writel(priv, tmp, reg);
 
 	ret = readl_poll_timeout(reg, tmp, tmp & SDHCI_CDNS_HRS04_ACK, 0, 10);
 	if (ret)
 		return ret;
 
 	tmp &= ~SDHCI_CDNS_HRS04_WR;
-	writel(tmp, reg);
+	sdhci_cdns_priv_writel(priv, tmp, reg);
 
 	ret = readl_poll_timeout(reg, tmp, !(tmp & SDHCI_CDNS_HRS04_ACK),
 				 0, 10);
@@ -191,7 +211,7 @@ static void sdhci_cdns_set_emmc_mode(struct sdhci_cdns_priv *priv, u32 mode)
 	tmp = readl(priv->hrs_addr + SDHCI_CDNS_HRS06);
 	tmp &= ~SDHCI_CDNS_HRS06_MODE;
 	tmp |= FIELD_PREP(SDHCI_CDNS_HRS06_MODE, mode);
-	writel(tmp, priv->hrs_addr + SDHCI_CDNS_HRS06);
+	sdhci_cdns_priv_writel(priv, tmp, priv->hrs_addr + SDHCI_CDNS_HRS06);
 }
 
 static u32 sdhci_cdns_get_emmc_mode(struct sdhci_cdns_priv *priv)
@@ -223,7 +243,7 @@ static int sdhci_cdns_set_tune_val(struct sdhci_host *host, unsigned int val)
 	 */
 	for (i = 0; i < 2; i++) {
 		tmp |= SDHCI_CDNS_HRS06_TUNE_UP;
-		writel(tmp, reg);
+		sdhci_cdns_priv_writel(priv, tmp, reg);
 
 		ret = readl_poll_timeout(reg, tmp,
 					 !(tmp & SDHCI_CDNS_HRS06_TUNE_UP),
@@ -309,6 +329,88 @@ static void sdhci_cdns_set_uhs_signaling(struct sdhci_host *host,
 		sdhci_set_uhs_signaling(host, timing);
 }
 
+/*
+ * The Pensando Elba SoC explicitly controls byte-lane enables on writes
+ * which includes writes to the HRS registers.
+ */
+static void elba_priv_write_l(struct sdhci_cdns_priv *priv, u32 val,
+			      void __iomem *reg)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&priv->wrlock, flags);
+	writel(0x78, priv->ctl_addr);
+	writel(val, reg);
+	spin_unlock_irqrestore(&priv->wrlock, flags);
+}
+
+static void elba_write_l(struct sdhci_host *host, u32 val, int reg)
+{
+	elba_priv_write_l(sdhci_cdns_priv(host), val, host->ioaddr + reg);
+}
+
+static void elba_write_w(struct sdhci_host *host, u16 val, int reg)
+{
+	struct sdhci_cdns_priv *priv = sdhci_cdns_priv(host);
+	unsigned long flags;
+	u32 m = (reg & 0x3);
+	u32 msk = (0x3 << (m));
+
+	spin_lock_irqsave(&priv->wrlock, flags);
+	writel(msk << 3, priv->ctl_addr);
+	writew(val, host->ioaddr + reg);
+	spin_unlock_irqrestore(&priv->wrlock, flags);
+}
+
+static void elba_write_b(struct sdhci_host *host, u8 val, int reg)
+{
+	struct sdhci_cdns_priv *priv = sdhci_cdns_priv(host);
+	unsigned long flags;
+	u32 m = (reg & 0x3);
+	u32 msk = (0x1 << (m));
+
+	spin_lock_irqsave(&priv->wrlock, flags);
+	writel(msk << 3, priv->ctl_addr);
+	writeb(val, host->ioaddr + reg);
+	spin_unlock_irqrestore(&priv->wrlock, flags);
+}
+
+static const struct sdhci_ops sdhci_elba_ops = {
+	.write_l = elba_write_l,
+	.write_w = elba_write_w,
+	.write_b = elba_write_b,
+	.set_clock = sdhci_set_clock,
+	.get_timeout_clock = sdhci_cdns_get_timeout_clock,
+	.set_bus_width = sdhci_set_bus_width,
+	.reset = sdhci_reset,
+	.set_uhs_signaling = sdhci_cdns_set_uhs_signaling,
+};
+
+static int elba_drv_init(struct platform_device *pdev)
+{
+	struct sdhci_host *host = platform_get_drvdata(pdev);
+	struct sdhci_cdns_priv *priv = sdhci_cdns_priv(host);
+	struct resource *iomem;
+	void __iomem *ioaddr;
+
+	host->mmc->caps |= (MMC_CAP_1_8V_DDR | MMC_CAP_8_BIT_DATA);
+
+	iomem = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+	if (!iomem)
+		return -ENOMEM;
+
+	ioaddr = devm_platform_ioremap_resource(pdev, 1);
+	if (IS_ERR(ioaddr))
+		return PTR_ERR(ioaddr);
+
+	priv->ctl_addr = ioaddr;
+	priv->priv_write_l = elba_priv_write_l;
+	spin_lock_init(&priv->wrlock);
+	writel(0x78, priv->ctl_addr);
+
+	return 0;
+}
+
 static const struct sdhci_ops sdhci_cdns_ops = {
 	.set_clock = sdhci_set_clock,
 	.get_timeout_clock = sdhci_cdns_get_timeout_clock,
@@ -318,13 +420,24 @@ static void sdhci_cdns_set_uhs_signaling(struct sdhci_host *host,
 	.set_uhs_signaling = sdhci_cdns_set_uhs_signaling,
 };
 
-static const struct sdhci_pltfm_data sdhci_cdns_uniphier_pltfm_data = {
-	.ops = &sdhci_cdns_ops,
-	.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,
+static const struct sdhci_cdns_drv_data sdhci_cdns_uniphier_drv_data = {
+	.pltfm_data = {
+		.ops = &sdhci_cdns_ops,
+		.quirks2 = SDHCI_QUIRK2_PRESET_VALUE_BROKEN,
+	},
+};
+
+static const struct sdhci_cdns_drv_data sdhci_elba_drv_data = {
+	.init = elba_drv_init,
+	.pltfm_data = {
+		.ops = &sdhci_elba_ops,
+	},
 };
 
-static const struct sdhci_pltfm_data sdhci_cdns_pltfm_data = {
-	.ops = &sdhci_cdns_ops,
+static const struct sdhci_cdns_drv_data sdhci_cdns_drv_data = {
+	.pltfm_data = {
+		.ops = &sdhci_cdns_ops,
+	},
 };
 
 static void sdhci_cdns_hs400_enhanced_strobe(struct mmc_host *mmc,
@@ -347,10 +460,26 @@ static void sdhci_cdns_hs400_enhanced_strobe(struct mmc_host *mmc,
 					 SDHCI_CDNS_HRS06_MODE_MMC_HS400);
 }
 
+static void sdhci_mmc_hw_reset(struct mmc_host *mmc)
+{
+	struct sdhci_host *host = mmc_priv(mmc);
+	struct sdhci_cdns_priv *priv = sdhci_cdns_priv(host);
+
+	dev_info(mmc_dev(host->mmc), "emmc hardware reset\n");
+
+	reset_control_assert(priv->rst_hw);
+	/* For eMMC, minimum is 1us but give it 9us for good measure */
+	udelay(9);
+
+	reset_control_deassert(priv->rst_hw);
+	/* For eMMC, minimum is 200us but give it 300us for good measure */
+	usleep_range(300, 1000);
+}
+
 static int sdhci_cdns_probe(struct platform_device *pdev)
 {
 	struct sdhci_host *host;
-	const struct sdhci_pltfm_data *data;
+	const struct sdhci_cdns_drv_data *data;
 	struct sdhci_pltfm_host *pltfm_host;
 	struct sdhci_cdns_priv *priv;
 	struct clk *clk;
@@ -369,10 +498,10 @@ static int sdhci_cdns_probe(struct platform_device *pdev)
 
 	data = of_device_get_match_data(dev);
 	if (!data)
-		data = &sdhci_cdns_pltfm_data;
+		data = &sdhci_cdns_drv_data;
 
 	nr_phy_params = sdhci_cdns_phy_param_count(dev->of_node);
-	host = sdhci_pltfm_init(pdev, data,
+	host = sdhci_pltfm_init(pdev, &data->pltfm_data,
 				struct_size(priv, phy_params, nr_phy_params));
 	if (IS_ERR(host)) {
 		ret = PTR_ERR(host);
@@ -389,11 +518,18 @@ static int sdhci_cdns_probe(struct platform_device *pdev)
 	host->ioaddr += SDHCI_CDNS_SRS_BASE;
 	host->mmc_host_ops.hs400_enhanced_strobe =
 				sdhci_cdns_hs400_enhanced_strobe;
-	sdhci_enable_v4_mode(host);
-	__sdhci_read_caps(host, &version, NULL, NULL);
 
 	sdhci_get_of_property(pdev);
 
+	if (data->init) {
+		ret = data->init(pdev);
+		if (ret)
+			goto free;
+	}
+
+	sdhci_enable_v4_mode(host);
+	__sdhci_read_caps(host, &version, NULL, NULL);
+
 	ret = mmc_of_parse(host->mmc);
 	if (ret)
 		goto free;
@@ -404,6 +540,17 @@ static int sdhci_cdns_probe(struct platform_device *pdev)
 	if (ret)
 		goto free;
 
+	if (host->mmc->caps & MMC_CAP_HW_RESET) {
+		priv->rst_hw = devm_reset_control_get_optional_exclusive(dev, "hw");
+		if (IS_ERR(priv->rst_hw)) {
+			ret = PTR_ERR(priv->rst_hw);
+			if (ret == -ENOENT)
+				priv->rst_hw = NULL;
+		} else {
+			host->mmc_host_ops.hw_reset = sdhci_mmc_hw_reset;
+		}
+	}
+
 	ret = sdhci_add_host(host);
 	if (ret)
 		goto free;
@@ -453,7 +600,11 @@ static int sdhci_cdns_resume(struct device *dev)
 static const struct of_device_id sdhci_cdns_match[] = {
 	{
 		.compatible = "socionext,uniphier-sd4hc",
-		.data = &sdhci_cdns_uniphier_pltfm_data,
+		.data = &sdhci_cdns_uniphier_drv_data,
+	},
+	{
+		.compatible = "pensando,elba-emmc",
+		.data = &sdhci_elba_drv_data
 	},
 	{ .compatible = "cdns,sd4hc" },
 	{ /* sentinel */ }
diff --git a/drivers/reset/Kconfig b/drivers/reset/Kconfig
index 147543a..cded0a7 100644
--- a/drivers/reset/Kconfig
+++ b/drivers/reset/Kconfig
@@ -58,6 +58,15 @@ config RESET_BRCMSTB_RESCAL
 	  This enables the RESCAL reset controller for SATA, PCIe0, or PCIe1 on
 	  BCM7216.
 
+config RESET_ELBASR
+	tristate "Pensando Elba System Resource reset controller"
+	depends on MFD_PENSANDO_ELBASR || COMPILE_TEST
+	help
+	  This option enables support for the external reset functions
+	  on the Pensando Elba System Resource Chip.  Reset control
+	  of peripherals is accessed over SPI to the system resource
+	  chip device registers using CS0.
+
 config RESET_HSDK
 	bool "Synopsys HSDK Reset Driver"
 	depends on HAS_IOMEM
diff --git a/drivers/reset/Makefile b/drivers/reset/Makefile
index 1694761..bb86360 100644
--- a/drivers/reset/Makefile
+++ b/drivers/reset/Makefile
@@ -9,6 +9,7 @@ obj-$(CONFIG_RESET_AXS10X) += reset-axs10x.o
 obj-$(CONFIG_RESET_BERLIN) += reset-berlin.o
 obj-$(CONFIG_RESET_BRCMSTB) += reset-brcmstb.o
 obj-$(CONFIG_RESET_BRCMSTB_RESCAL) += reset-brcmstb-rescal.o
+obj-$(CONFIG_RESET_ELBASR) += reset-elbasr.o
 obj-$(CONFIG_RESET_HSDK) += reset-hsdk.o
 obj-$(CONFIG_RESET_IMX7) += reset-imx7.o
 obj-$(CONFIG_RESET_INTEL_GW) += reset-intel-gw.o
diff --git a/drivers/reset/reset-elbasr.c b/drivers/reset/reset-elbasr.c
new file mode 100644
index 00000000..4b7db6b
--- /dev/null
+++ b/drivers/reset/reset-elbasr.c
@@ -0,0 +1,106 @@
+// SPDX-License-Identifier: (GPL-2.0+ OR MIT)
+/*
+ * Copyright (c) 2022 Advanced Micro Devices, Inc.
+ */
+
+#include <linux/mfd/pensando-elbasr.h>
+#include <linux/platform_device.h>
+#include <linux/reset-controller.h>
+#include <linux/regmap.h>
+#include <linux/err.h>
+#include <linux/of.h>
+
+#include <dt-bindings/reset/amd,pensando-elba-reset.h>
+
+struct elbasr_reset {
+	struct reset_controller_dev rcdev;
+	struct regmap *regmap;
+};
+
+static inline struct elbasr_reset *to_elbasr_rst(struct reset_controller_dev *rc)
+{
+	return container_of(rc, struct elbasr_reset, rcdev);
+}
+
+static inline int elbasr_reset_shift(unsigned long id)
+{
+	switch (id) {
+	case EMMC_HW_RESET:
+		return 6;
+	default:
+		return -EINVAL;
+	}
+}
+
+static int elbasr_reset_assert(struct reset_controller_dev *rcdev,
+			       unsigned long id)
+{
+	struct elbasr_reset *elbar = to_elbasr_rst(rcdev);
+	int val;
+	u32 mask;
+
+	val = elbasr_reset_shift(id);
+	if (val < 0)
+		return val;
+	mask = 1 << val;
+
+	return regmap_update_bits(elbar->regmap, ELBASR_CTRL0_REG, mask, mask);
+}
+
+static int elbasr_reset_deassert(struct reset_controller_dev *rcdev,
+				 unsigned long id)
+{
+	struct elbasr_reset *elbar = to_elbasr_rst(rcdev);
+	int val;
+	u32 mask;
+
+	val = elbasr_reset_shift(id);
+	if (val < 0)
+		return val;
+	mask = 1 << val;
+
+	return regmap_update_bits(elbar->regmap, ELBASR_CTRL0_REG, mask, 0);
+}
+
+static const struct reset_control_ops elbasr_reset_ops = {
+	.assert	= elbasr_reset_assert,
+	.deassert = elbasr_reset_deassert,
+};
+
+static int elbasr_reset_probe(struct platform_device *pdev)
+{
+	struct elbasr_data *elbasr = dev_get_drvdata(pdev->dev.parent);
+	struct elbasr_reset *elbar;
+	int ret;
+
+	elbar = devm_kzalloc(&pdev->dev, sizeof(struct elbasr_reset),
+			     GFP_KERNEL);
+	if (!elbar)
+		return -ENOMEM;
+
+	elbar->rcdev.owner = THIS_MODULE;
+	elbar->rcdev.nr_resets = ELBASR_NR_RESETS;
+	elbar->rcdev.ops = &elbasr_reset_ops;
+	elbar->rcdev.of_node = pdev->dev.of_node;
+	elbar->regmap = elbasr->elbasr_regs;
+
+	platform_set_drvdata(pdev, elbar);
+
+	ret = devm_reset_controller_register(&pdev->dev, &elbar->rcdev);
+
+	return ret;
+}
+
+static const struct of_device_id elba_reset_dt_match[] = {
+	{ .compatible = "amd,pensando-elbasr-reset", },
+	{ /* sentinel */ },
+};
+
+static struct platform_driver elbasr_reset_driver = {
+	.probe	= elbasr_reset_probe,
+	.driver = {
+		.name = "pensando_elbasr_reset",
+		.of_match_table	= elba_reset_dt_match,
+	},
+};
+builtin_platform_driver(elbasr_reset_driver);
diff --git a/drivers/soc/Kconfig b/drivers/soc/Kconfig
index 425ab6f..8debe0b 100644
--- a/drivers/soc/Kconfig
+++ b/drivers/soc/Kconfig
@@ -10,6 +10,7 @@ source "drivers/soc/fsl/Kconfig"
 source "drivers/soc/imx/Kconfig"
 source "drivers/soc/ixp4xx/Kconfig"
 source "drivers/soc/mediatek/Kconfig"
+source "drivers/soc/pensando/Kconfig"
 source "drivers/soc/qcom/Kconfig"
 source "drivers/soc/renesas/Kconfig"
 source "drivers/soc/rockchip/Kconfig"
diff --git a/drivers/soc/Makefile b/drivers/soc/Makefile
index 36452be..4689b33 100644
--- a/drivers/soc/Makefile
+++ b/drivers/soc/Makefile
@@ -16,6 +16,7 @@ obj-$(CONFIG_ARCH_IXP4XX)	+= ixp4xx/
 obj-$(CONFIG_SOC_XWAY)		+= lantiq/
 obj-y				+= mediatek/
 obj-y				+= amlogic/
+obj-$(CONFIG_ARCH_PENSANDO)	+= pensando/
 obj-y				+= qcom/
 obj-y				+= renesas/
 obj-$(CONFIG_ARCH_ROCKCHIP)	+= rockchip/
diff --git a/drivers/soc/pensando/Kconfig b/drivers/soc/pensando/Kconfig
new file mode 100644
index 00000000..484f71d
--- /dev/null
+++ b/drivers/soc/pensando/Kconfig
@@ -0,0 +1,89 @@
+if ARCH_PENSANDO
+
+menu "Pensando SoC drivers"
+
+choice
+    prompt "SoC Select"
+    default ARCH_PENSANDO_ELBA_SOC
+
+config ARCH_PENSANDO_CAPRI_SOC
+	bool "Capri SoC"
+	help
+	  Support for the Pensando Capri SoC
+
+config ARCH_PENSANDO_ELBA_SOC
+	bool "Elba SoC"
+	help
+	  Support for the Pensando Elba SoC
+
+config ARCH_PENSANDO_GIGLIO_SOC
+	bool "Giglio SoC"
+	help
+	  Support for the Pensando Giglio SoC
+
+endchoice
+
+config PENSANDO_SOC_CAPMEM
+	tristate "/dev/capmem driver for the Pensando SoCs"
+	depends on OF
+	default y
+	help
+	  Support for the Pensando SoC memory driver
+
+config PENSANDO_SOC_CAPMEM_HUGEPAGE
+	tristate "Enable hugepage support in capmem"
+	select TRANSPARENT_HUGEPAGE
+	default n
+	help
+	  Support for Huge pages in Pensando SoC memory driver
+
+config PENSANDO_SOC_PCIE
+	tristate "PCIe driver for Pensando SoCs"
+	depends on OF
+	default y
+	help
+	  Provide a PCIe driver for pciemgr kernel assist
+
+config PENSANDO_SOC_RSTCAUSE
+	tristate "Pensando reset cause driver"
+	depends on OF
+	default y
+	help
+	  Support for the Pensando SoC reset cause driver
+
+config PENSANDO_SOC_CRASH
+	tristate "Pensando crash driver"
+	depends on OF
+	default y
+	help
+	  Support for the Pensando SoC crash driver
+
+config PENSANDO_SOC_BSM
+	bool "Pensando SoC Boot State Machine"
+	depends on OF
+	default y
+	help
+	  Support for the Pensando SoC boot state machine driver
+
+config PENSANDO_SOC_BSM_ENABLE
+	bool "Enable the Boot State Machine in the kernel"
+        depends on PENSANDO_SOC_BSM
+	help
+	  Re-enable the BSM on kernel startup
+
+config PENSANDO_SOC_PENFW
+	bool "Pensando penfw driver"
+	default n
+	help
+	  Driver module to interface secure boot config
+
+config PENSANDO_SOC_SBUS
+	tristate "Pensando sbus read/write driver"
+	depends on OF
+	default y
+	help
+	  Support for the Pensando SoC sbus read/write driver
+
+endmenu
+
+endif
diff --git a/drivers/soc/pensando/Makefile b/drivers/soc/pensando/Makefile
new file mode 100644
index 00000000..95689d3
--- /dev/null
+++ b/drivers/soc/pensando/Makefile
@@ -0,0 +1,16 @@
+#
+# Pensando SoC drivers
+#
+obj-y += cap_soc.o
+
+CFLAGS_cap_mem.o := -I$(src)
+ccflags-$(CONFIG_PENSANDO_SOC_PCIE) += -DPEN_COMPAT_V2
+
+obj-$(CONFIG_PENSANDO_SOC_CAPMEM) += cap_mem.o
+obj-$(CONFIG_PENSANDO_SOC_PCIE) += cap_pcie.o cap_reboot.o
+obj-$(CONFIG_PENSANDO_SOC_PCIE) += kpcimgr.o kpcimgr_sysfs.o
+obj-$(CONFIG_PENSANDO_SOC_RSTCAUSE) += cap_rstcause.o
+obj-$(CONFIG_PENSANDO_SOC_CRASH) += cap_crash.o
+obj-$(CONFIG_PENSANDO_SOC_BSM) += cap_bsm.o
+obj-$(CONFIG_PENSANDO_SOC_PENFW) += penfw_smc.o penfw_sysfs.o penfw_drv.o
+obj-$(CONFIG_PENSANDO_SOC_SBUS) += sbus.o
diff --git a/drivers/soc/pensando/bsm_dev.h b/drivers/soc/pensando/bsm_dev.h
new file mode 100644
index 00000000..7e31269
--- /dev/null
+++ b/drivers/soc/pensando/bsm_dev.h
@@ -0,0 +1,24 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019-2021, Pensando Systems Inc.
+ */
+
+#ifndef _BSM_DEV_H_
+#define _BSM_DEV_H_
+
+#define BSM_WDT_LSB		10
+#define BSM_WDT_MASK		0x1
+#define BSM_FWID_LSB		8
+#define BSM_FWID_MASK		0x3
+#define BSM_ATTEMPT_LSB		6
+#define BSM_ATTEMPT_MASK	0x3
+#define BSM_TRACK_LSB		4
+#define BSM_TRACK_MASK		0x3
+#define BSM_STAGE_LSB		2
+#define BSM_STAGE_MASK		0x3
+#define BSM_RUNNING_LSB		1
+#define BSM_RUNNING_MASK	0x1
+#define BSM_AUTOBOOT_LSB	0
+#define BSM_AUTOBOOT_MASK	0x1
+
+#endif
diff --git a/drivers/soc/pensando/cap_bsm.c b/drivers/soc/pensando/cap_bsm.c
new file mode 100644
index 00000000..a55039f
--- /dev/null
+++ b/drivers/soc/pensando/cap_bsm.c
@@ -0,0 +1,159 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019-2021, Pensando Systems Inc.
+ */
+
+#include <linux/export.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/io.h>
+#include "bsm_dev.h"
+
+extern struct kobject *pensando_fw_kobj_get(void);
+
+struct bsm {
+	void __iomem *base;
+	uint32_t val;
+};
+static struct bsm bsm;
+
+#define BSM_SHOW_INT(n, s) \
+	static ssize_t n##_show(struct device *dev,			\
+			struct device_attribute *attr, char *buf)	\
+	{								\
+		int val = (bsm.val >> BSM_##s##_LSB) & BSM_##s##_MASK;	\
+		return sprintf(buf, "%d\n", val);			\
+	}								\
+	static DEVICE_ATTR_RO(n);
+
+BSM_SHOW_INT(wdt,      WDT)
+BSM_SHOW_INT(attempt,  ATTEMPT)
+BSM_SHOW_INT(stage,    STAGE)
+BSM_SHOW_INT(running,  RUNNING)
+BSM_SHOW_INT(autoboot, AUTOBOOT)
+
+static const char *fwnames[4] = {
+	"mainfwa", "mainfwb", "goldfw", "diagfw"
+};
+
+#define BSM_SHOW_FWID(n, s) \
+	static ssize_t n##_show(struct device *dev,			\
+			struct device_attribute *attr, char *buf)	\
+	{								\
+		int val = (bsm.val >> BSM_##s##_LSB) & BSM_##s##_MASK;	\
+		return sprintf(buf, "%s\n", fwnames[val & 0x3]);	\
+	}								\
+	static DEVICE_ATTR_RO(n);
+
+BSM_SHOW_FWID(fwid,  FWID)
+BSM_SHOW_FWID(track, TRACK)
+
+static ssize_t success_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t count)
+{
+	long val;
+
+	if (kstrtoul(buf, 0, &val) < 0)
+		return -EINVAL;
+	if (val) {
+		bsm.val &= ~(1 << BSM_RUNNING_LSB);
+		writel(bsm.val, bsm.base);
+	}
+
+	return count;
+}
+static DEVICE_ATTR_WO(success);
+
+static const struct device_attribute *bsm_attrs[] = {
+	&dev_attr_wdt,
+	&dev_attr_fwid,
+	&dev_attr_attempt,
+	&dev_attr_track,
+	&dev_attr_stage,
+	&dev_attr_running,
+	&dev_attr_autoboot,
+	&dev_attr_success,
+};
+
+static int bsm_probe(struct platform_device *pdev)
+{
+	struct kobject *pensando_kobj;
+	int i, r = 0;
+
+	if (bsm.base == NULL) {
+		/* bsm not in device-tree */
+		return -ENODEV;
+	}
+	pensando_kobj = pensando_fw_kobj_get();
+	if (!pensando_kobj)
+		return -ENOMEM;
+	for (i = 0; i < ARRAY_SIZE(bsm_attrs); i++) {
+		r = device_create_file(&pdev->dev, bsm_attrs[i]);
+		if (r) {
+			pr_err("failed to create sysfs file\n");
+			return r;
+		}
+	}
+	r = sysfs_create_link(pensando_kobj, &pdev->dev.kobj, "bsm");
+	if (r) {
+		pr_err("failed to create sysfs symlink\n");
+		kobject_put(pensando_kobj);
+		return r;
+	}
+	return 0;
+}
+
+static const struct of_device_id bsm_of_match[] = {
+	{ .compatible = "pensando,bsm" },
+};
+
+static struct platform_driver bsm_driver = {
+	.driver = {
+		.name = "capri-bsm",
+		.of_match_table = bsm_of_match,
+		.suppress_bind_attrs = true,
+	},
+	.probe = bsm_probe,
+};
+builtin_platform_driver(bsm_driver);
+
+/*
+ * Boot State Machine init.
+ * If auto-booting, then set the BSM_RUNNING bit in the BSM register
+ * to continue BSM protection.	The bit will be cleared when userland comes up.
+ */
+static int __init cap_bsm_init(void)
+{
+	const struct of_device_id *match;
+	struct device_node *np;
+	struct resource res;
+
+	np = of_find_matching_node_and_match(NULL, bsm_of_match, &match);
+	if (!np) {
+		/* Not found in the device-tree.  Quietly resign */
+		return 0;
+	}
+	if (of_address_to_resource(np, 0, &res) < 0) {
+		pr_err("failed to get BSM registers\n");
+		of_node_put(np);
+		return -ENXIO;
+	}
+	of_node_put(np);
+
+	bsm.base = ioremap(res.start, resource_size(&res));
+	if (!bsm.base) {
+		pr_err("failed to map BSM register\n");
+		return -ENXIO;
+	}
+
+	bsm.val = readl(bsm.base);
+#ifdef CONFIG_PENSANDO_SOC_BSM_ENABLE
+	if (bsm.val & (1 << BSM_AUTOBOOT_LSB)) {
+		bsm.val |= 1 << BSM_RUNNING_LSB;
+		writel(bsm.val, bsm.base);
+	}
+#endif
+	return 0;
+}
+early_initcall(cap_bsm_init);
diff --git a/drivers/soc/pensando/cap_crash.c b/drivers/soc/pensando/cap_crash.c
new file mode 100644
index 00000000..dc2f931
--- /dev/null
+++ b/drivers/soc/pensando/cap_crash.c
@@ -0,0 +1,154 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019-2022, Pensando Systems Inc.
+ */
+
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/kmsg_dump.h>
+#include <linux/time.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include "cap_reboot.h"
+
+#define PCRASH_NAME	"pensando-crash"
+
+struct pcrash_st {
+	struct platform_device	*pdev;
+	struct kmsg_dumper	dump;
+	void __iomem		*flashbase;
+	resource_size_t		size;
+	void *panic_buf;
+};
+
+struct panicbuf_header {
+	u32 magic;
+	u32 len;
+};
+
+static struct pcrash_st *pcrash;
+static u32 PANIC_SIGNATURE = 0x9D7A7318;
+
+static void pcrash_do_dump(struct kmsg_dumper *dumper,
+			   enum kmsg_dump_reason reason)
+{
+	int idx;
+	u32 *src;
+	size_t kmsg_dump_len;
+	u32 __iomem *dst = (u32 *)pcrash->flashbase;
+	struct panicbuf_header *hdr = pcrash->flashbase;
+
+	/*
+	 * read first 32bits, if all ff then the new panic data
+	 * can be written to the panic buf.
+	 */
+	if (hdr->magic == 0xffffffff) {
+		kmsg_dump_get_buffer(dumper, false, pcrash->panic_buf,
+				pcrash->size - sizeof(struct panicbuf_header), &kmsg_dump_len);
+
+		/* write the signature to panic buf log */
+		hdr->magic = PANIC_SIGNATURE;
+		hdr->len = kmsg_dump_len;
+		src = (u32 *)pcrash->panic_buf;
+		dst = (u32 *)(hdr + 1);
+		for (idx = 0; idx < roundup(kmsg_dump_len, 4) / 4; idx++)
+			*dst++ = *src++;
+	}
+}
+
+static int cap_panic_callback(struct notifier_block *nb,
+			       unsigned long reason, void *arg)
+{
+	struct timespec64 ts;
+	struct tm tm;
+
+	ktime_get_real_ts64(&ts);
+	time64_to_tm(ts.tv_sec, 0, &tm);
+	pr_info("Panic at Boot #%lu %04ld-%02d-%02d %02d:%02d:%02d.%06ld\n",
+		cap_boot_count(),
+		tm.tm_year + 1900, tm.tm_mon + 1, tm.tm_mday,
+		tm.tm_hour, tm.tm_min, tm.tm_sec,
+		ts.tv_nsec / 1000);
+	return NOTIFY_DONE;
+}
+
+static struct notifier_block cap_panic_notifier = {
+	.notifier_call = cap_panic_callback,
+};
+
+static int pcrash_probe(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	int err;
+
+	pcrash = devm_kzalloc(dev, sizeof(*pcrash), GFP_KERNEL);
+	if (!pcrash)
+		return -ENOMEM;
+
+	pcrash->pdev = pdev;
+	platform_set_drvdata(pdev, pcrash);
+
+	pcrash->dump.max_reason = KMSG_DUMP_PANIC;
+	pcrash->dump.dump = pcrash_do_dump;
+
+	/* Obtain and remap flash address. */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	pcrash->flashbase = devm_ioremap_resource(dev, res);
+	if (IS_ERR(pcrash->flashbase)) {
+		dev_err(dev, "Cannot remap flash address.\n");
+		return PTR_ERR(pcrash->flashbase);
+	}
+	pcrash->size = resource_size(res);
+	pcrash->panic_buf = vmalloc(pcrash->size);
+	if (!pcrash->panic_buf) {
+		dev_err(dev, "failed to allocate buffer workspace\n");
+		return -ENOMEM;
+	}
+	memset(pcrash->panic_buf, 0xff, pcrash->size);
+	atomic_notifier_chain_register(&panic_notifier_list,
+				       &cap_panic_notifier);
+	err = kmsg_dump_register(&pcrash->dump);
+	if (err) {
+		vfree(pcrash->panic_buf);
+		dev_err(dev, "%s: registering kmsg dumper failed, error %d\n", __func__, err);
+		return err;
+	}
+	return 0;
+}
+
+static int pcrash_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+
+	if (kmsg_dump_unregister(&pcrash->dump) < 0)
+		dev_err(dev, "could not unregister kmsg_dumper\n");
+	atomic_notifier_chain_unregister(&panic_notifier_list,
+					 &cap_panic_notifier);
+	vfree(pcrash->panic_buf);
+	return 0;
+}
+
+static const struct of_device_id pcrash_dt_ids[] = {
+	{.compatible = "pensando,capri-crash",},
+	{ /* end of table */ }
+};
+
+MODULE_DEVICE_TABLE(of, pcrash_dt_ids);
+
+static struct platform_driver pcrash_platform_driver = {
+	.probe = pcrash_probe,
+	.remove = pcrash_remove,
+	.driver = {
+		.name = PCRASH_NAME,
+		.of_match_table = pcrash_dt_ids,
+	},
+};
+
+module_platform_driver(pcrash_platform_driver);
+
+MODULE_DESCRIPTION("Pensando Panic Crash Driver");
+MODULE_LICENSE("GPL v2");
+MODULE_ALIAS("platform:" PCRASH_NAME);
+MODULE_AUTHOR("Rahul Shekhar <rahulshekhar@pensando.io>");
diff --git a/drivers/soc/pensando/cap_mem.c b/drivers/soc/pensando/cap_mem.c
new file mode 100644
index 00000000..5a28df3
--- /dev/null
+++ b/drivers/soc/pensando/cap_mem.c
@@ -0,0 +1,484 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2018-2022, Pensando Systems Inc.
+ */
+
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/fs.h>
+#include <linux/module.h>
+#include <linux/miscdevice.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/fcntl.h>
+#include <linux/init.h>
+#include <linux/pagemap.h>
+#include <linux/pfn_t.h>
+#include "capmem_dev.h"
+
+#define DSC_MEM_ATTR_COHERENT	0x1	// Memory range is coherent
+
+#define CREATE_TRACE_POINTS
+#include "cap_tracepoint.h"
+
+#define CAPMEM_REGION_ALIGN		PMD_SIZE
+
+/*
+ * Memory range information provided by U-Boot on the kernel commandline:
+ * Syntax:
+ *	start-end:type[,start-end:type]
+ *	    start:  hex start address (no 0x prefix)
+ *	    end:    hex end address (inclusive)
+ *	    type:   address space type: coherent | noncoherent
+ * Eg:
+ *	capmem=c0000000-c3f00000:coherent,c8000000-13fffffff:noncoherent
+ *
+ * Only address ranges specified are allowed to be mapped.
+ */
+static char *ranges;
+#ifdef MODULE
+module_param(ranges, charp, 0);
+#else
+static int __init capmem_setup(char *s)
+{
+	ranges = s;
+	return 0;
+}
+__setup("capmem=", capmem_setup);
+#endif
+
+static struct capmem_range mem_range[CAPMEM_MAX_RANGES];
+static int nmem_ranges;
+
+static int capmem_add_range(uint64_t start, uint64_t len, int type)
+{
+	struct capmem_range *p = &mem_range[nmem_ranges];
+
+	if (nmem_ranges == CAPMEM_MAX_RANGES)
+		return -ENOMEM;
+	p->start = start;
+	p->len = len;
+	p->type = type;
+	++nmem_ranges;
+	return 0;
+}
+
+#ifdef CONFIG_PENSANDO_SOC_CAPMEM_HUGEPAGE
+static vm_fault_t cap_mem_pte_fault(struct vm_fault *vmf)
+{
+	struct vm_area_struct *vma = vmf->vma;
+	phys_addr_t phys;
+	pgoff_t pgoff;
+	vm_fault_t rc;
+
+	trace_cap_mem_pte_fault(vma, vmf);
+
+	pgoff = vmf->pgoff;
+	phys = PFN_PHYS(pgoff);
+
+	trace_cap_mem_vmf_insert_pfn_pte(vma, vmf, phys);
+
+	rc = vmf_insert_pfn(vma, vmf->address, PFN_DOWN(phys));
+	if (rc == -ENOMEM)
+		return VM_FAULT_OOM;
+	if (rc < 0 && rc != -EBUSY)
+		return VM_FAULT_SIGBUS;
+
+	return VM_FAULT_NOPAGE;
+}
+
+static vm_fault_t cap_mem_pmd_fault(struct vm_fault *vmf)
+{
+	unsigned long pmd_addr = vmf->address & PMD_MASK;
+	struct vm_area_struct *vma = vmf->vma;
+	phys_addr_t phys;
+	pgoff_t pgoff;
+	pfn_t pfn;
+
+	trace_cap_mem_pmd_fault(vma, vmf);
+
+	if (pmd_addr < vma->vm_start || (pmd_addr + PMD_SIZE) > vma->vm_end)
+		return VM_FAULT_FALLBACK;
+
+	pgoff = linear_page_index(vma, pmd_addr);
+	phys = PFN_PHYS(pgoff);
+
+	if (!IS_ALIGNED(phys, PMD_SIZE))
+		return VM_FAULT_FALLBACK;
+
+	trace_cap_mem_vmf_insert_pfn_pmd(vma, vmf, phys);
+
+	pfn = phys_to_pfn_t(phys, PFN_DEV|PFN_MAP);
+
+	return vmf_insert_pfn_pmd(vmf, pfn, vmf->flags & FAULT_FLAG_WRITE);
+}
+
+#ifdef CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD
+static vm_fault_t cap_mem_pud_fault(struct vm_fault *vmf)
+{
+	unsigned long pud_addr = vmf->address & PUD_MASK;
+	struct vm_area_struct *vma = vmf->vma;
+	phys_addr_t phys;
+	pgoff_t pgoff;
+	pfn_t pfn;
+
+	trace_cap_mem_pud_fault(vma, vmf);
+
+	if (pud_addr < vma->vm_start || (pud_addr + PUD_SIZE) > vma->vm_end)
+		return VM_FAULT_FALLBACK;
+
+	pgoff = linear_page_index(vma, pud_addr);
+	phys = PFN_PHYS(pgoff);
+
+	if (!IS_ALIGNED(phys, PUD_SIZE))
+		return VM_FAULT_FALLBACK;
+
+	trace_cap_mem_vmf_insert_pfn_pud(vma, vmf, phys);
+
+	pfn = phys_to_pfn_t(phys, PFN_DEV|PFN_MAP);
+
+	return vmf_insert_pfn_pud(vmf, pfn, vmf->flags & FAULT_FLAG_WRITE);
+}
+#else
+static vm_fault_t cap_mem_pud_fault(struct vm_fault *vmf)
+{
+	return VM_FAULT_FALLBACK;
+}
+#endif /* !CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD */
+
+static vm_fault_t cap_mem_huge_fault(struct vm_fault *vmf,
+		enum page_entry_size pe_size)
+{
+	vm_fault_t rc;
+
+	trace_cap_mem_fault_enter(vmf->vma, vmf);
+
+	switch (pe_size) {
+	case PE_SIZE_PTE:
+		rc = cap_mem_pte_fault(vmf);
+		break;
+	case PE_SIZE_PMD:
+		rc = cap_mem_pmd_fault(vmf);
+		break;
+	case PE_SIZE_PUD:
+		rc = cap_mem_pud_fault(vmf);
+		break;
+	default:
+		rc = VM_FAULT_SIGBUS;
+	}
+
+	trace_cap_mem_fault_exit(vmf->vma, vmf);
+
+	return rc;
+}
+
+static vm_fault_t cap_mem_fault(struct vm_fault *vmf)
+{
+	return cap_mem_huge_fault(vmf, PE_SIZE_PTE);
+}
+
+static int cap_mem_split(struct vm_area_struct *vma, unsigned long addr)
+{
+	return -EINVAL;
+}
+
+static const struct vm_operations_struct cap_mem_vm_ops = {
+	.fault = cap_mem_fault,
+	.huge_fault = cap_mem_huge_fault,
+	.split = cap_mem_split,
+};
+
+static unsigned long cap_mem_get_unmapped_area(struct file *filp,
+		unsigned long addr, unsigned long len, unsigned long pgoff,
+		unsigned long flags)
+{
+	unsigned long off, len_align, addr_align, align;
+
+	align = PAGE_SIZE;
+	off = pgoff << PAGE_SHIFT;
+
+	if (len >= PMD_SIZE && IS_ALIGNED(off, PMD_SIZE))
+		align = PMD_SIZE;
+
+#ifdef CONFIG_HAVE_ARCH_TRANSPARENT_HUGEPAGE_PUD
+	if (len >= PUD_SIZE && IS_ALIGNED(off, PUD_SIZE))
+		align = PUD_SIZE;
+#endif
+
+	trace_cap_mem_get_unmapped_area_enter(addr, len, pgoff, align);
+
+	if (align == PAGE_SIZE)
+		goto out;
+
+	len_align = len + align;
+
+	addr = current->mm->get_unmapped_area(filp, addr, len_align, pgoff, flags);
+	if (!IS_ERR_VALUE(addr)) {
+		addr_align = round_up(addr, align);
+		trace_cap_mem_get_unmapped_area_exit(addr_align, len_align, pgoff, align);
+		return addr_align;
+	}
+
+out:
+	addr = current->mm->get_unmapped_area(filp, addr, len, pgoff, flags);
+	trace_cap_mem_get_unmapped_area_exit(addr, len, pgoff, align);
+	return addr;
+}
+#endif
+
+static int cap_mem_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	size_t size = vma->vm_end - vma->vm_start;
+	phys_addr_t p_start = (phys_addr_t)vma->vm_pgoff << PAGE_SHIFT;
+	phys_addr_t p_end = p_start + size - 1;
+	pgprot_t pgprot = vma->vm_page_prot;
+	int i;
+
+	// range cannot wrap
+	if (p_end <= p_start)
+		return -EINVAL;
+
+	// must be MAP_SHARED
+	if (!(vma->vm_flags & VM_MAYSHARE))
+		return -EINVAL;
+
+	// find permitted range
+	for (i = 0; i < nmem_ranges; i++)
+		if (p_start >= mem_range[i].start &&
+		    p_end < (mem_range[i].start + mem_range[i].len))
+			break;
+	if (i == nmem_ranges)
+		return -EPERM;
+
+	switch (mem_range[i].type) {
+	case CAPMEM_TYPE_DEVICE:
+		/* register space must be device-mapped */
+		pgprot = pgprot_device(pgprot);
+		vma->vm_flags |= VM_IO;
+		break;
+
+	case CAPMEM_TYPE_NONCOHERENT:
+		/*
+		 * An inner shareable cached mapping on a noncoherence range
+		 * is invalid, so only accept non-cached mapping requests.
+		 */
+		if (!(file->f_flags & O_SYNC))
+			return -EINVAL;
+		pgprot = pgprot_writecombine(pgprot);
+		break;
+
+	default:
+		// CAPMEM_TYPE_COHERENT - default inner shareable mapping
+		break;
+	}
+
+	/*
+	 * Clear the RDONLY bit and set the DIRTY bit to bypass the
+	 * kernel's clean/dirty page tracking, which uses a page fault on
+	 * first write behavior, which is undesirable for performance.
+	 */
+	if (vma->vm_flags & VM_WRITE)
+		pgprot = __pgprot_modify(pgprot, PTE_RDONLY, PTE_DIRTY);
+
+	vma->vm_page_prot = pgprot;
+
+#ifdef CONFIG_PENSANDO_SOC_CAPMEM_HUGEPAGE
+	vma->vm_ops = &cap_mem_vm_ops;
+	vma->vm_flags |= VM_PFNMAP | VM_HUGEPAGE | VM_DONTEXPAND | VM_DONTDUMP;
+#else
+	/* Remap-pfn-range will mark the range VM_IO */
+	if (remap_pfn_range(vma,
+			    vma->vm_start,
+			    vma->vm_pgoff,
+			    size,
+			    vma->vm_page_prot)) {
+		return -EAGAIN;
+	}
+#endif
+
+	return 0;
+}
+
+static long cap_mem_unlocked_ioctl(struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	void __user *p = (void __user *)arg;
+	struct capmem_range __user *rp;
+	struct capmem_ranges_args gr;
+	int i;
+
+	switch (cmd) {
+	case CAPMEM_GET_NRANGES:
+		return put_user(nmem_ranges, (int __user *)p);
+
+	case CAPMEM_GET_RANGES:
+		if (copy_from_user(&gr, p, sizeof(gr)))
+			return -EFAULT;
+		rp = (struct capmem_range __user *)gr.range;
+		for (i = 0; i < gr.nranges; i++) {
+			if (i >= nmem_ranges)
+				return i;
+			if (copy_to_user(rp, &mem_range[i], sizeof(*rp)))
+				return -EFAULT;
+			++rp;
+		}
+		return i;
+
+	default:
+		return -ENOTTY;
+	}
+}
+
+const struct file_operations cap_mem_fops = {
+	.owner		= THIS_MODULE,
+	.mmap		= cap_mem_mmap,
+	.unlocked_ioctl	= cap_mem_unlocked_ioctl,
+#ifdef CONFIG_PENSANDO_SOC_CAPMEM_HUGEPAGE
+	.get_unmapped_area = cap_mem_get_unmapped_area,
+#endif
+};
+
+static struct miscdevice cap_mem_dev = {
+	MISC_DYNAMIC_MINOR,
+	CAPMEM_NAME,
+	&cap_mem_fops
+};
+
+static int __init parse_memory_ranges(struct platform_device *pdev, char *s)
+{
+	uint64_t start, end, len;
+	char *p, *q;
+	int r, type;
+
+	if (!s)
+		return 0;
+
+	while ((p = strsep(&s, ",")) != NULL) {
+		if (nmem_ranges == CAPMEM_MAX_RANGES) {
+			dev_err(&pdev->dev, "too many ranges\n");
+			return -ENODEV;
+		}
+		q = strchr(p, ':');
+		if (!q)
+			goto syntax;
+		*q++ = '\0';
+		if (sscanf(p, "%llx-%llx", &start, &end) != 2)
+			goto syntax;
+		if (end <= start)
+			goto syntax;
+		if (strcmp(q, "coherent") == 0)
+			type = CAPMEM_TYPE_COHERENT;
+		else if (strcmp(q, "noncoherent") == 0)
+			type = CAPMEM_TYPE_NONCOHERENT;
+		else
+			goto syntax;
+		len = end - start + 1;
+		r = capmem_add_range(start, len, type);
+		if (r)
+			return r;
+	}
+	return 0;
+syntax:
+	dev_err(&pdev->dev, "invalid range syntax\n");
+	return -EINVAL;
+}
+
+/*
+ * Device space is mapped out here.
+ */
+static const struct {
+	uint64_t start;
+	uint64_t len;
+} init_device_ranges[] = {
+	{ 0x00200000, 0x6fe00000 }, // 00200000...6fffffff
+};
+
+static void load_static_entries(void)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(init_device_ranges); i++) {
+		capmem_add_range(init_device_ranges[i].start,
+				 init_device_ranges[i].len,
+				 CAPMEM_TYPE_DEVICE);
+	}
+}
+
+/*
+ * Load ranges from device-tree (installed by u-boot):
+ * The pensando,capmem-ranges parameter is a table of 5 words per row.
+ * The table format is:
+ *	<start_hi start_lo size_hi size_lo attr>
+ *	attr is { unused:30, bypass:1, coherent:1 }
+ */
+static int load_of_ranges(struct platform_device *pdev)
+{
+	u32 entries[CAPMEM_MAX_RANGES][5];
+	int r, n, i, type;
+	u64 start, len;
+
+	n = of_property_read_variable_u32_array(pdev->dev.of_node,
+		"pensando,capmem-ranges", (u32 *)entries,
+		0, sizeof (entries) / sizeof (u32));
+	if (n < 0) {
+		return -ENOENT;
+	}
+	if (n % 5 != 0) {
+		dev_err(&pdev->dev, "of pensando,capmem-ranges invalid\n");
+		return -ENODEV;
+	}
+	n /= 5;
+	for (i = 0; i < n; i++) {
+		type = (entries[i][4] & DSC_MEM_ATTR_COHERENT) ?
+			CAPMEM_TYPE_COHERENT : CAPMEM_TYPE_NONCOHERENT;
+		start = ((u64)entries[i][0] << 32) | entries[i][1];
+		len   = ((u64)entries[i][2] << 32) | entries[i][3];
+		r = capmem_add_range(start, len, type);
+		if (r)
+			return r;
+	}
+	return 0;
+}
+
+static int capmem_probe(struct platform_device *pdev)
+{
+	int r;
+	
+	dev_info(&pdev->dev, "Loading capmem driver\n");
+	load_static_entries();
+	r = load_of_ranges(pdev);
+	if (r == -ENOENT) {
+		/* fallback to the capmem= variable */
+		r = parse_memory_ranges(pdev, ranges);
+		if (r)
+			return r;
+	}
+	return misc_register(&cap_mem_dev);
+}
+
+static int capmem_remove(struct platform_device *pdev)
+{
+	dev_info(&pdev->dev, "Unloading capmem driver\n");
+	misc_deregister(&cap_mem_dev);
+	return 0;
+}
+
+static struct of_device_id capmem_of_match[] = {
+	{ .compatible = "pensando,capmem" },
+	{ /* end of table */ }
+};
+
+static struct platform_driver capmem_driver = {
+	.probe = capmem_probe,
+	.remove = capmem_remove,
+	.driver = {
+		.name = "capmem",
+		.owner = THIS_MODULE,
+		.of_match_table = capmem_of_match,
+	},
+};
+
+module_platform_driver(capmem_driver);
+MODULE_DESCRIPTION("Pensando SoC Memory Driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/soc/pensando/cap_pcie.c b/drivers/soc/pensando/cap_pcie.c
new file mode 100644
index 00000000..fec49cc
--- /dev/null
+++ b/drivers/soc/pensando/cap_pcie.c
@@ -0,0 +1,445 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2019-2022, Pensando Systems Inc.
+ */
+
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/module.h>
+#include <linux/uaccess.h>
+#include <linux/ioctl.h>
+#include <linux/platform_device.h>
+#include <linux/miscdevice.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/init.h>
+#include <linux/spinlock.h>
+#include <linux/io.h>
+#include <linux/fs.h>
+#include <asm/traps.h>
+#include "cap_reboot.h"
+#include "cap_rstcause.h"
+#include "penpcie_dev.h"
+#ifdef CONFIG_ARCH_PENSANDO_CAPRI_SOC
+#include "cap_pcie_capri.h"
+#endif
+#ifdef CONFIG_ARCH_PENSANDO_ELBA_SOC
+#include "cap_pcie_elba.h"
+#endif
+#ifdef CONFIG_ARCH_PENSANDO_GIGLIO_SOC
+#include "cap_pcie_giglio.h"
+#endif
+
+#define DRV_NAME	"cap_pcie"
+#define PFX		DRV_NAME ": "
+
+/* device resource indexes */
+#define MS_CFG_WDT_IDX  0
+#define WDT_IDX         1
+#define PCIE_IDX	2
+
+struct pciedev_info {
+	u32 __iomem *ms_cfg_wdt;
+	u32 __iomem *wdt;
+	void __iomem *pcieva;
+	u64 pcie_base;
+	u64 pcie_size;
+	u64 pciep_access_address;
+	int pciep_access_error;
+	spinlock_t pciep_access_lock;
+	long (*saved_panic_blink)(int state);
+};
+
+static struct pciedev_info pciedev_info;
+
+static void *pcie_ptov(const u64 pciepa)
+{
+	struct pciedev_info *pi = &pciedev_info;
+	const u64 pcieoff = pciepa - pi->pcie_base;
+
+	return pi->pcieva + pcieoff;
+}
+
+static u32 pcie_readl(const u64 pciepa)
+{
+	return readl(pcie_ptov(pciepa));
+}
+
+static void pcie_writel(const u32 val, const u64 pciepa)
+{
+	writel(val, pcie_ptov(pciepa));
+}
+
+static int pciep_access_in_progress(void)
+{
+	struct pciedev_info *pi = &pciedev_info;
+
+	if (pi->pciep_access_address) {
+		pi->pciep_access_error++;
+		return 1;
+	}
+	return 0;
+}
+
+int platform_serror(struct pt_regs *regs, unsigned int esr)
+{
+	if (pciep_access_in_progress())
+		return 1;
+
+	if ((esr >> 26) == 0x2f && (esr & 0x3) == 0x0) { /* Decode Error */
+		if (user_mode(regs)) {
+			struct task_struct *tsk = current;
+
+			pr_info("%s[%d]: serror converted to bus error\n",
+				tsk->comm, task_pid_nr(tsk));
+			force_signal_inject(SIGBUS, BUS_ADRERR, regs->pc, esr);
+		} else {
+			/* ignore */
+			pr_info("ignoring serror decode-error in kernel mode\n");
+		}
+		return 1;
+	}
+
+	return 0;
+}
+
+static void pciep_access_begin(const u64 pciepa)
+{
+	struct pciedev_info *pi = &pciedev_info;
+
+	pi->pciep_access_address = pciepa;
+	pi->pciep_access_error = 0;
+}
+
+static int pciep_access_end(void)
+{
+	struct pciedev_info *pi = &pciedev_info;
+
+	if (pi->pciep_access_error) {
+		pr_info_ratelimited("pcie access serror: address 0x%llx\n",
+				    pi->pciep_access_address);
+	}
+	pi->pciep_access_address = 0;
+	return pi->pciep_access_error;
+}
+
+static int pciep_valid_pa(const uint64_t pciepa, const uint32_t size)
+{
+	struct pciedev_info *pi = &pciedev_info;
+
+	if (!pi->pcieva)
+		return -ENXIO;
+	if (pciepa < pi->pcie_base ||
+	    pciepa > pi->pcie_base + pi->pcie_size ||
+	    size > pi->pcie_size ||
+	    pciepa + size > pi->pcie_base + pi->pcie_size)
+		return -ERANGE;
+	return 0;
+}
+
+/*
+ * Protect reads to pcie registers in the pcie clock domain.
+ * The pcie refclock can be removed by the system without warning,
+ * and outstanding read requests to these registers will generate
+ * an AXI read error response.  ARM will treat this as an asynchronous
+ * System Error (SError) event.  The default handling of SError is to
+ * send SIGILL if SError arrives while in user space, or panic if the
+ * SError arrives when not in process context.  Neither of these responses
+ * is desireable for our case where a pcie register might be accessed
+ * just as the pcie refclock gets removed.  Here we detect the SError
+ * event during our pcie register access and return failure to the
+ * caller, but the system continues.
+ */
+int pciep_regrd32(const uint64_t pciepa, uint32_t *val)
+{
+	struct pciedev_info *pi = &pciedev_info;
+	int r;
+	unsigned long flags;
+
+	r = pciep_valid_pa(pciepa, sizeof(u32));
+	if (r)
+		return r;
+
+	spin_lock_irqsave(&pi->pciep_access_lock, flags);
+	pciep_access_begin(pciepa);
+
+	*val = pcie_readl(pciepa);
+	asm volatile("msr daifclr, #4" ::: "memory"); /* unmask async SError */
+	dsb(sy);		/* sync in-flight ld/st */
+	isb();
+
+	r = pciep_access_end();
+	spin_unlock_irqrestore(&pi->pciep_access_lock, flags);
+	if (r)
+		return -EIO;
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(pciep_regrd32);
+
+static long pcie_unlocked_ioctl(struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	void __user *p = (void __user *)arg;
+	struct pcie_rw rw;
+	uint32_t val;
+	int r;
+
+	switch (cmd) {
+
+	case PCIE_PCIEP_REGRD:
+		if (copy_from_user(&rw, p, sizeof(rw)))
+			return -EFAULT;
+		if (rw.size != sizeof(u32))
+			return -EINVAL;
+		r = pciep_regrd32(rw.pciepa, &val);
+		if (r)
+			return r;
+		return copy_to_user(rw.rdvalp, &val, sizeof(val));
+
+	default:
+		return -ENOTTY;
+	}
+}
+
+const struct file_operations pcie_fops = {
+	.owner		= THIS_MODULE,
+	.unlocked_ioctl	= pcie_unlocked_ioctl,
+};
+
+static struct miscdevice pcie_dev = {
+	MISC_DYNAMIC_MINOR,
+	PENPCIE_NAME,
+	&pcie_fops
+};
+
+static int pcieport_get_ltssm_en(const int port)
+{
+	const u32 val = pcie_readl(PXC_(CFG_C_PORT_MAC, port));
+
+	return (val & CFG_MACF_(0_2_LTSSM_EN)) != 0;
+}
+
+static int pcie_get_ltssm_en(void)
+{
+	int port;
+
+	for (port = 0; port < PCIEPORT_NPORTS; port++)
+		if (pcieport_get_ltssm_en(port))
+			return port;
+	return -1;
+}
+
+static void pcieport_set_crs(const int port, const int on)
+{
+	u32 val;
+
+	val = pcie_readl(PXC_(CFG_C_PORT_MAC, port));
+	if (on)
+		val |= CFG_MACF_(0_2_CFG_RETRY_EN);
+	else
+		val &= ~CFG_MACF_(0_2_CFG_RETRY_EN);
+	pcie_writel(val, PXC_(CFG_C_PORT_MAC, port));
+}
+
+static void pcie_set_crs(const int on)
+{
+	int port;
+
+	for (port = 0; port < PCIEPORT_NPORTS; port++)
+		pcieport_set_crs(port, on);
+}
+
+static int pcieport_poll_for_hostdn(const int port)
+{
+	const u32 val = pcie_readl(PXC_(INT_C_MAC_INTREG, port));
+
+	return (val & MAC_INTREGF_(RST_DN2UP)) != 0;
+}
+
+/*
+ * Detect if the host is rebooting by watching the pcie mac
+ * for an interrupt indicating the link went into reset.
+ */
+static int pcie_poll_for_hostdn(void)
+{
+	int port;
+
+	for (port = 0; port < PCIEPORT_NPORTS; port++)
+		if (pcieport_poll_for_hostdn(port))
+			return port;
+	return -1;
+}
+
+/*
+ * Asic reset using the WDT0 configured to reset immediately.
+ * Note that we do NOT touch the WDT config here until *after*
+ * we are in the panic handling.  The WDT might be used by the
+ * watchdog driver while the system is up, but here after a panic
+ * we take ownership of the WDT to reset the system.
+ *
+ * Note also this function never returns.
+ */
+static void cap_reset(void)
+{
+	struct pciedev_info *pi = &pciedev_info;
+	u32 val;
+
+	pr_info(PFX "pensando reset!\n");
+
+	/* Enable WDT0 to reset the system */
+	val = ioread32(pi->ms_cfg_wdt);
+	val |= (1 << CFG_WDT_RST_EN);
+	iowrite32(val, pi->ms_cfg_wdt);
+
+	/* Configure WDT to immediately reset */
+	iowrite32(0, pi->wdt + WDT_TORR);
+	iowrite32(WDT_KICK_VAL, pi->wdt + WDT_CRR);
+	iowrite32(WDT_CR_PCLK_256, pi->wdt + WDT_CR);
+	iowrite32(WDT_CR_PCLK_256 | WDT_CR_ENABLE, pi->wdt + WDT_CR);
+	for (;;)
+		asm volatile("wfi");
+	/* NOTREACHED */
+}
+
+/*
+ * This function is called by the spin loop at the end of a
+ * system panic.  We'll watch for the host to reset and
+ * reset ourselves at the same time.
+ *
+ * If we haven't yet initialized the link (ltssm_en=0) then the
+ * host side hasn't come up yet.  In that case just reset immediately.
+ */
+static long pcie_panic_blink(int state)
+{
+	int port;
+
+	/* Check sysfs for immediate reboot */
+	if (cap_panic_reboot())
+		cap_reset();
+
+	port = pcie_get_ltssm_en();
+	if (port >= 0) {
+		pr_info(PFX "port %d enabled\n", port);
+		pcie_set_crs(0);
+		while ((port = pcie_poll_for_hostdn()) < 0)
+			continue;
+		pr_info(PFX "port %d hostdn\n", port);
+#ifdef CONFIG_PENSANDO_SOC_RSTCAUSE
+		/* reflect the pcie reset state in the reset cause */
+		cap_rstcause_set(CAP_RSTCAUSE_EV_PCIE_RESET);
+#endif
+	}
+	cap_reset();
+
+	/* NOTREACHED */
+	return 0;
+}
+
+static int map_resources(struct platform_device *pd)
+{
+	struct pciedev_info *pi = &pciedev_info;
+	struct device_node *dn = pd->dev.of_node;
+
+	pi->ms_cfg_wdt = of_iomap(dn, MS_CFG_WDT_IDX);
+	pi->wdt = of_iomap(dn, WDT_IDX);
+	pi->pcieva = of_iomap(dn, PCIE_IDX);
+
+	if (IS_ERR(pi->ms_cfg_wdt) ||
+		IS_ERR(pi->wdt) ||
+		IS_ERR(pi->pcieva)) {
+		pr_err(PFX "iomap resources failed\n");
+		goto errout;
+	}
+	return 0;
+
+ errout:
+	if (pi->ms_cfg_wdt != NULL)
+		iounmap(pi->ms_cfg_wdt);
+	if (pi->wdt != NULL)
+		iounmap(pi->wdt);
+	if (pi->pcieva != NULL)
+		iounmap(pi->pcieva);
+	return -ENOMEM;
+}
+
+static void unmap_resources(struct platform_device *pd)
+{
+	struct pciedev_info *pi = &pciedev_info;
+
+	if (pi->ms_cfg_wdt != NULL)
+		iounmap(pi->ms_cfg_wdt);
+	if (pi->wdt != NULL)
+		iounmap(pi->wdt);
+	if (pi->pcieva != NULL)
+		iounmap(pi->pcieva);
+}
+
+static int pcie_probe(struct platform_device *pd)
+{
+	struct pciedev_info *pi = &pciedev_info;
+	struct device_node *dn = pd->dev.of_node;
+	struct resource res;
+	int err;
+
+	spin_lock_init(&pi->pciep_access_lock);
+
+	err = map_resources(pd);
+	if (err)
+		goto errout;
+
+	err = of_address_to_resource(dn, PCIE_IDX, &res);
+	if (err) {
+		pr_err(PFX "can't find PCIE_IDX res: %d\n", err);
+		goto errout_unmap;
+	}
+	pi->pcie_base = res.start;
+	pi->pcie_size = resource_size(&res);
+
+	err = misc_register(&pcie_dev);
+	if (err) {
+		pr_err(PFX "register pcie_dev failed: %d\n", err);
+		goto errout_unmap;
+	}
+
+	/*
+	 * Hook the panic_blink handler so we run after
+	 * all the panic notifiers and after all the
+	 * console msgs have been flushed.
+	 */
+	pi->saved_panic_blink = panic_blink;
+	panic_blink = pcie_panic_blink;
+	return 0;
+
+ errout_unmap:
+	unmap_resources(pd);
+ errout:
+	return err;
+}
+
+static int pcie_remove(struct platform_device *pd)
+{
+	struct pciedev_info *pi = &pciedev_info;
+
+	misc_deregister(&pcie_dev);
+	panic_blink = pi->saved_panic_blink;
+	unmap_resources(pd);
+	return 0;
+}
+
+static const struct of_device_id pcie_of_match[] = {
+	{ .compatible = "pensando,pcie" },
+	{ /* end of table */ }
+};
+
+static struct platform_driver pcie_driver = {
+	.probe = pcie_probe,
+	.remove = pcie_remove,
+	.driver = {
+		.name = "pensando-pcie",
+		.owner = THIS_MODULE,
+		.of_match_table = pcie_of_match,
+	},
+};
+module_platform_driver(pcie_driver);
diff --git a/drivers/soc/pensando/cap_pcie_common.h b/drivers/soc/pensando/cap_pcie_common.h
new file mode 100644
index 00000000..e54a0fd
--- /dev/null
+++ b/drivers/soc/pensando/cap_pcie_common.h
@@ -0,0 +1,52 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2022, Pensando Systems Inc.
+ */
+
+#ifndef __CAP_PCIE_COMMON_H__
+#define __CAP_PCIE_COMMON_H__
+
+#define ELB_ADDR_BASE_PP_PXC_0_OFFSET 0x20100000
+#define ELB_ADDR_BASE_PP_PXC_0_SIZE 0x40000
+#define ELB_ADDR_BASE_PP_PP_0_OFFSET 0x20300000
+#define ELB_ADDR_BASE_PP_PP_0_SIZE 0x40000
+
+#define ELB_PXC_CSR_CFG_C_PORT_MAC_BYTE_ADDRESS 0x20f8
+#define ELB_PXC_CSR_CFG_C_PORT_MAC_CFG_C_PORT_MAC_0_2_LTSSM_EN_FIELD_MASK 0x00000002
+#define ELB_PXC_CSR_CFG_C_PORT_MAC_CFG_C_PORT_MAC_0_2_CFG_RETRY_EN_FIELD_MASK 0x00000008
+
+#define ELB_PXC_CSR_INT_C_MAC_INTREG_BYTE_ADDRESS 0x2220
+#define ELB_PXC_CSR_INT_C_MAC_INTREG_RST_DN2UP_INTERRUPT_FIELD_MASK 0x00000010
+
+#define _PP_BASE(pn) \
+	(ELB_ADDR_BASE_PP_PP_0_OFFSET + \
+	(((pn) >> 2) * ELB_ADDR_BASE_PP_PP_0_SIZE))
+
+#define PP_(REG, pn) \
+	(_PP_BASE(pn) + ELB_PP_CSR_ ##REG## _BYTE_ADDRESS)
+
+#define _PXC_BASE(pn) \
+	(ELB_ADDR_BASE_PP_PXC_0_OFFSET + \
+	((pn) * ELB_ADDR_BASE_PP_PXC_0_SIZE))
+
+#define PXC_(REG, pn) \
+	(_PXC_BASE(pn) + ELB_PXC_CSR_ ##REG## _BYTE_ADDRESS)
+
+#define CFG_MACF_(REG) \
+	(ELB_PXC_CSR_CFG_C_PORT_MAC_CFG_C_PORT_MAC_ ##REG## _FIELD_MASK)
+#define MAC_INTREGF_(REG) \
+	(ELB_PXC_CSR_INT_C_MAC_INTREG_ ##REG## _INTERRUPT_FIELD_MASK)
+
+#define ELB_SOC_CSR_CFG_WDT_RST_EN_LSB 0
+#define CFG_WDT_RST_EN  ELB_SOC_CSR_CFG_WDT_RST_EN_LSB
+
+#define WDT_CR          0x00
+#define WDT_TORR        0x01
+#define WDT_CRR         0x03
+
+#define WDT_CR_ENABLE   0x1
+#define WDT_CR_PCLK_256 (0x7 << 2)
+
+#define WDT_KICK_VAL    0x76
+
+#endif /* __CAP_PCIE_COMMON_H__ */
diff --git a/drivers/soc/pensando/cap_pcie_elba.h b/drivers/soc/pensando/cap_pcie_elba.h
new file mode 100644
index 00000000..e23ca25
--- /dev/null
+++ b/drivers/soc/pensando/cap_pcie_elba.h
@@ -0,0 +1,13 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021-2022, Pensando Systems Inc.
+ */
+
+#ifndef __CAP_PCIE_ELBA_H__
+#define __CAP_PCIE_ELBA_H__
+
+#include "cap_pcie_common.h"
+
+#define PCIEPORT_NPORTS		8
+
+#endif /* __CAP_PCIE_ELBA_H__ */
diff --git a/drivers/soc/pensando/cap_reboot.c b/drivers/soc/pensando/cap_reboot.c
new file mode 100644
index 00000000..6bc8632
--- /dev/null
+++ b/drivers/soc/pensando/cap_reboot.c
@@ -0,0 +1,110 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Pensando reboot control via sysfs
+ *
+ * Copyright (c) 2020-2022, Pensando Systems Inc.
+ */
+
+#include <linux/kobject.h>
+#include <linux/string.h>
+#include <linux/sysfs.h>
+#include <linux/module.h>
+#include <linux/init.h>
+#include "cap_reboot.h"
+
+/*
+ * This module provides userspace control of reboot behavior
+ * after a panic.  Naples25 SWM and OCP cards will use this
+ * to enable immediate reboot after panic handling.
+ */
+static int panic_reboot;	/* default=0, no reboot */
+
+/* value of system "boot_count" for panic logging */
+static unsigned long boot_count;
+
+bool cap_panic_reboot(void)
+{
+	if (panic_reboot)
+		return true;
+	return false;
+}
+
+unsigned long cap_boot_count(void)
+{
+	return boot_count;
+}
+
+struct kobject *reboot_kobj;
+
+static ssize_t panic_reboot_show(struct kobject *kobj,
+		struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", panic_reboot);
+}
+
+static ssize_t panic_reboot_store(struct kobject *kobj,
+		struct kobj_attribute *attr, const char *buf, size_t count)
+{
+	int ret;
+
+	ret = kstrtoint(buf, 10, &panic_reboot);
+	if (ret < 0)
+		return ret;
+	return count;
+}
+
+static ssize_t boot_count_show(struct kobject *kobj,
+			       struct kobj_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%lu\n", boot_count);
+}
+
+static ssize_t boot_count_store(struct kobject *kobj,
+				struct kobj_attribute *attr,
+				const char *buf, size_t count)
+{
+	int ret;
+
+	ret = kstrtoul(buf, 0, &boot_count);
+	if (ret)
+		return ret;
+	return count;
+}
+
+static struct kobj_attribute panic_reboot_attribute =
+	__ATTR(panic_reboot, 0644, panic_reboot_show, panic_reboot_store);
+static struct kobj_attribute boot_count_attribute =
+	__ATTR(boot_count, 0644, boot_count_show, boot_count_store);
+
+static struct attribute *attrs[] = {
+	&panic_reboot_attribute.attr,
+	&boot_count_attribute.attr,
+	NULL,
+};
+
+/* Put all attributes in the kobject directory */
+static struct attribute_group attr_group = {
+	.attrs = attrs,
+};
+
+static int __init capri_reboot_init(void)
+{
+	int ret;
+
+	reboot_kobj = kobject_create_and_add("reboot", kernel_kobj);
+	if (!reboot_kobj)
+		return -ENOMEM;
+
+	ret = sysfs_create_group(reboot_kobj, &attr_group);
+	if (ret)
+		kobject_put(reboot_kobj);
+	return ret;
+}
+
+static void __exit capri_reboot_exit(void)
+{
+	kobject_put(reboot_kobj);
+}
+
+module_init(capri_reboot_init);
+module_exit(capri_reboot_exit);
diff --git a/drivers/soc/pensando/cap_reboot.h b/drivers/soc/pensando/cap_reboot.h
new file mode 100644
index 00000000..e4bd89a
--- /dev/null
+++ b/drivers/soc/pensando/cap_reboot.h
@@ -0,0 +1,12 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020-2022, Pensando Systems Inc.
+ */
+
+#ifndef __CAP_REBOOT_H__
+#define __CAP_REBOOT_H__
+
+bool cap_panic_reboot(void);
+unsigned long cap_boot_count(void);
+
+#endif
diff --git a/drivers/soc/pensando/cap_rstcause.c b/drivers/soc/pensando/cap_rstcause.c
new file mode 100644
index 00000000..05ad173
--- /dev/null
+++ b/drivers/soc/pensando/cap_rstcause.c
@@ -0,0 +1,218 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Pensando restart cause driver
+ *
+ * Copyright (c) 2021, Pensando Systems Inc.
+ */
+
+#include <linux/kobject.h>
+#include <linux/string.h>
+#include <linux/kernel.h>
+#include <linux/sysfs.h>
+#include <linux/export.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/init.h>
+#include <linux/reboot.h>
+#include <linux/mfd/syscon.h>
+#include <linux/regmap.h>
+#include "cap_rstcause.h"
+
+struct kobject *pensando_fw_kobj_get(void);
+
+struct cap_rstdev {
+	struct platform_device *pdev;
+	struct regmap *regs;
+	unsigned int regs_offset;
+	u32 this_cause;
+	struct notifier_block panic_nb;
+	struct notifier_block reboot_nb;
+	struct kobject *pensando_kobj;
+};
+
+static struct cap_rstdev *g_rdev;
+
+static inline u32 read_cause_reg(struct cap_rstdev *rdev)
+{
+	u32 val;
+
+	regmap_read(rdev->regs, rdev->regs_offset, &val);
+	return val;
+}
+
+static inline u32 read_next_cause_reg(struct cap_rstdev *rdev)
+{
+	u32 val;
+
+	regmap_read(rdev->regs, rdev->regs_offset + 4, &val);
+	return val;
+}
+
+static inline void set_next_cause_reg(struct cap_rstdev *rdev, u32 mask)
+{
+	regmap_update_bits(rdev->regs, rdev->regs_offset + 4, mask, ~0U);
+}
+
+void cap_rstcause_set(u32 mask)
+{
+	if (g_rdev)
+		set_next_cause_reg(g_rdev, mask);
+}
+
+EXPORT_SYMBOL_GPL(cap_rstcause_set);
+
+static int rstcause_reboot_handler(struct notifier_block *this,
+				   unsigned long code, void *unused)
+{
+	cap_rstcause_set(CAP_RSTCAUSE_EV_REBOOT);
+	return NOTIFY_OK;
+}
+
+static int rstcause_panic_handler(struct notifier_block *this,
+				  unsigned long code, void *unused)
+{
+	cap_rstcause_set(CAP_RSTCAUSE_EV_PANIC);
+	return NOTIFY_OK;
+}
+
+static ssize_t this_cause_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct cap_rstdev *rdev;
+
+	rdev = platform_get_drvdata(to_platform_device(dev));
+	return sprintf(buf, "0x%08x\n", rdev->this_cause);
+}
+
+static DEVICE_ATTR_RO(this_cause);
+
+static ssize_t next_cause_show(struct device *dev,
+			       struct device_attribute *attr, char *buf)
+{
+	struct cap_rstdev *rdev;
+
+	rdev = platform_get_drvdata(to_platform_device(dev));
+	return sprintf(buf, "0x%08x\n", read_next_cause_reg(rdev));
+}
+
+static ssize_t next_cause_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t count)
+{
+	struct cap_rstdev *rdev;
+	unsigned long val;
+
+	rdev = platform_get_drvdata(to_platform_device(dev));
+	if (kstrtoul(buf, 0, &val) < 0)
+		return -EINVAL;
+	if (val)
+		set_next_cause_reg(rdev, val);
+
+	return count;
+}
+
+static DEVICE_ATTR_RW(next_cause);
+
+static const struct device_attribute *rstcause_attrs[] = {
+	&dev_attr_this_cause,
+	&dev_attr_next_cause,
+};
+
+static int rstcause_probe(struct platform_device *pdev)
+{
+	struct of_phandle_args args;
+	struct cap_rstdev *rdev;
+	struct regmap *regs;
+	int r, i;
+
+	if (g_rdev)
+		return -ENODEV;
+
+	r = of_parse_phandle_with_fixed_args(pdev->dev.of_node,
+					     "pensando,causeregs", 1, 0, &args);
+	if (r) {
+		dev_err(&pdev->dev, "could not find causeregs\n");
+		return r;
+	}
+
+	regs = syscon_node_to_regmap(args.np);
+	if (IS_ERR(regs)) {
+		dev_err(&pdev->dev, "could not map causeregs\n");
+		return PTR_ERR(regs);
+	}
+
+	rdev = devm_kzalloc(&pdev->dev, sizeof(*rdev), GFP_KERNEL);
+	if (!rdev)
+		return -ENOMEM;
+	rdev->pdev = pdev;
+	platform_set_drvdata(pdev, rdev);
+
+	rdev->regs = regs;
+	rdev->regs_offset = args.args[0];
+	rdev->reboot_nb.notifier_call = rstcause_reboot_handler;
+	register_reboot_notifier(&rdev->reboot_nb);
+
+	rdev->panic_nb.notifier_call = rstcause_panic_handler;
+	atomic_notifier_chain_register(&panic_notifier_list, &rdev->panic_nb);
+
+	rdev->this_cause = read_cause_reg(rdev);
+
+	g_rdev = rdev;
+
+	rdev->pensando_kobj = pensando_fw_kobj_get();
+	if (rdev->pensando_kobj) {
+		for (i = 0; i < ARRAY_SIZE(rstcause_attrs); i++) {
+			r = device_create_file(&pdev->dev, rstcause_attrs[i]);
+			if (r) {
+				dev_err(&pdev->dev,
+					"failed to create sysfs file\n");
+				return r;
+			}
+		}
+		r = sysfs_create_link(rdev->pensando_kobj,
+				      &pdev->dev.kobj, "rstcause");
+		if (r) {
+			dev_err(&pdev->dev, "failed to create sysfs symlink\n");
+			kobject_put(rdev->pensando_kobj);
+			rdev->pensando_kobj = NULL;
+		}
+	}
+	return 0;
+}
+
+static int rstcause_remove(struct platform_device *pdev)
+{
+	struct cap_rstdev *rdev = platform_get_drvdata(pdev);
+
+	unregister_reboot_notifier(&rdev->reboot_nb);
+	atomic_notifier_chain_unregister(&panic_notifier_list,
+					 &rdev->panic_nb);
+	if (g_rdev == rdev) {
+		g_rdev = NULL;
+		if (rdev->pensando_kobj)
+			kobject_put(rdev->pensando_kobj);
+	}
+
+	return 0;
+}
+
+static const struct of_device_id rstcause_of_match[] = {
+	{.compatible = "pensando,rstcause"},
+	{ /* end of table */ }
+};
+
+static struct platform_driver rstcause_driver = {
+	.probe = rstcause_probe,
+	.remove = rstcause_remove,
+	.driver = {
+		   .name = "pensando-rstcause",
+		   .owner = THIS_MODULE,
+		   .of_match_table = rstcause_of_match,
+		   },
+};
+
+module_platform_driver(rstcause_driver);
+MODULE_DESCRIPTION("Pensando SoC Reset Cause Driver");
+MODULE_LICENSE("GPL");
+
diff --git a/drivers/soc/pensando/cap_rstcause.h b/drivers/soc/pensando/cap_rstcause.h
new file mode 100644
index 00000000..12fe871
--- /dev/null
+++ b/drivers/soc/pensando/cap_rstcause.h
@@ -0,0 +1,15 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021, Pensando Systems Inc.
+ */
+
+#ifndef __CAP_RSTCAUSE_H__
+#define __CAP_RSTCAUSE_H__
+
+#define CAP_RSTCAUSE_EV_REBOOT		BIT(0)
+#define CAP_RSTCAUSE_EV_PANIC		BIT(1)
+#define CAP_RSTCAUSE_EV_PCIE_RESET	BIT(2)
+
+void cap_rstcause_set(u32 mask);
+
+#endif
diff --git a/drivers/soc/pensando/cap_soc.c b/drivers/soc/pensando/cap_soc.c
new file mode 100644
index 00000000..102b161
--- /dev/null
+++ b/drivers/soc/pensando/cap_soc.c
@@ -0,0 +1,31 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2021, Pensando Systems Inc.
+ */
+
+#include <linux/spinlock.h>
+#include <linux/export.h>
+#include <linux/kobject.h>
+
+#ifdef CONFIG_ARCH_PENSANDO_CAPRI_SOC
+DEFINE_SPINLOCK(apb_bus_spinlock);
+EXPORT_SYMBOL_GPL(apb_bus_spinlock);
+#endif
+
+static struct kobject *pensando_fw_kobj;
+
+/*
+ * Creates a new pensando sysfs node if it does not exists. The kobj is
+ * returned after incrementing the refcnt, so a module should use kobject_put()
+ * when it is done using this koject.
+ */
+struct kobject *pensando_fw_kobj_get(void)
+{
+	if (!pensando_fw_kobj) {
+		pensando_fw_kobj = kobject_create_and_add("pensando", firmware_kobj);
+		if (!pensando_fw_kobj)
+			return NULL;
+	}
+	return kobject_get(pensando_fw_kobj);
+}
+EXPORT_SYMBOL_GPL(pensando_fw_kobj_get);
diff --git a/drivers/soc/pensando/cap_tracepoint.h b/drivers/soc/pensando/cap_tracepoint.h
new file mode 100644
index 00000000..2fbdde7
--- /dev/null
+++ b/drivers/soc/pensando/cap_tracepoint.h
@@ -0,0 +1,172 @@
+/*
+ * Copyright (c) 2021, Pensando Systems Inc.
+ */
+
+#undef TRACE_SYSTEM
+#define TRACE_SYSTEM pensando
+
+#if !defined(_CAP_TRACEPOINT_H_) || defined(TRACE_HEADER_MULTI_READ)
+#define _CAP_TRACEPOINT_H_
+
+#include <linux/tracepoint.h>
+#include <linux/mm_types.h>
+
+DECLARE_EVENT_CLASS(cap_mem_fault,
+
+    TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf),
+
+    TP_ARGS(vma, vmf),
+
+    TP_STRUCT__entry(
+        __field(unsigned long, vm_start)
+        __field(unsigned long, vm_end)
+        __field(unsigned long, va)
+        __field(unsigned long, pa)
+    ),
+
+    TP_fast_assign(
+        __entry->vm_start = vma->vm_start;
+        __entry->vm_end = vma->vm_end;
+        __entry->va = vmf->address;
+        __entry->pa = vmf->pgoff << PAGE_SHIFT;
+    ),
+
+    TP_printk("vm_start 0x%lx vm_end 0x%lx va 0x%lx pa 0x%lx",
+        __entry->vm_start,
+        __entry->vm_end,
+        __entry->va,
+        __entry->pa)
+);
+
+DEFINE_EVENT(cap_mem_fault, cap_mem_fault_enter,
+
+    TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf),
+
+    TP_ARGS(vma, vmf)
+);
+
+DEFINE_EVENT(cap_mem_fault, cap_mem_fault_exit,
+
+    TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf),
+
+    TP_ARGS(vma, vmf)
+);
+
+DEFINE_EVENT(cap_mem_fault, cap_mem_pte_fault,
+
+    TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf),
+
+    TP_ARGS(vma, vmf)
+);
+
+DEFINE_EVENT(cap_mem_fault, cap_mem_pmd_fault,
+
+    TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf),
+
+    TP_ARGS(vma, vmf)
+);
+
+DEFINE_EVENT(cap_mem_fault, cap_mem_pud_fault,
+
+    TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf),
+
+    TP_ARGS(vma, vmf)
+);
+
+DECLARE_EVENT_CLASS(cap_mem_get_unmapped_area,
+
+    TP_PROTO(unsigned long va, unsigned long len, unsigned long pgoff, unsigned long align),
+
+    TP_ARGS(va, len, pgoff, align),
+
+    TP_STRUCT__entry(
+        __field(unsigned long, va)
+        __field(unsigned long, len)
+        __field(unsigned long, pa)
+        __field(unsigned long, align)
+    ),
+
+    TP_fast_assign(
+        __entry->va = va;
+        __entry->len = len;
+        __entry->pa = pgoff << PAGE_SHIFT;
+        __entry->align = align;
+    ),
+
+    TP_printk("vm_start 0x%lx vm_end 0x%lx pa 0x%lx align 0x%lx",
+        __entry->va,
+        __entry->va + __entry->len,
+        __entry->pa,
+        __entry->align
+    )
+);
+
+DEFINE_EVENT(cap_mem_get_unmapped_area, cap_mem_get_unmapped_area_enter,
+
+    TP_PROTO(unsigned long va, unsigned long len, unsigned long pgoff, unsigned long align),
+
+    TP_ARGS(va, len, pgoff, align)
+);
+
+DEFINE_EVENT(cap_mem_get_unmapped_area, cap_mem_get_unmapped_area_exit,
+
+    TP_PROTO(unsigned long va, unsigned long len, unsigned long pgoff, unsigned long align),
+
+    TP_ARGS(va, len, pgoff, align)
+);
+
+DECLARE_EVENT_CLASS(cap_mem_vmf_insert_pfn,
+
+    TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf, unsigned long pa),
+
+    TP_ARGS(vma, vmf, pa),
+
+    TP_STRUCT__entry(
+        __field(unsigned long, vm_start)
+        __field(unsigned long, vm_end)
+        __field(unsigned long, va)
+        __field(unsigned long, pa)
+    ),
+
+    TP_fast_assign(
+        __entry->vm_start = vma->vm_start;
+        __entry->vm_end = vma->vm_end;
+        __entry->va = vmf->address;
+        __entry->pa = pa;
+    ),
+
+    TP_printk("vm_start 0x%lx vm_end 0x%lx va 0x%lx pa 0x%lx",
+        __entry->vm_start,
+        __entry->vm_end,
+        __entry->va,
+        __entry->pa)
+);
+
+DEFINE_EVENT(cap_mem_vmf_insert_pfn, cap_mem_vmf_insert_pfn_pte,
+
+    TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf, unsigned long pa),
+
+    TP_ARGS(vma, vmf, pa)
+);
+
+DEFINE_EVENT(cap_mem_vmf_insert_pfn, cap_mem_vmf_insert_pfn_pmd,
+
+    TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf, unsigned long pa),
+
+    TP_ARGS(vma, vmf, pa)
+);
+
+DEFINE_EVENT(cap_mem_vmf_insert_pfn, cap_mem_vmf_insert_pfn_pud,
+
+    TP_PROTO(struct vm_area_struct *vma, struct vm_fault *vmf, unsigned long pa),
+
+    TP_ARGS(vma, vmf, pa)
+);
+
+#endif  /* !defined(_CAP_TRACEPOINT_H_) || defined(TRACE_HEADER_MULTI_READ) */
+
+#undef TRACE_INCLUDE_PATH
+#undef TRACE_INCLUDE_FILE
+#define TRACE_INCLUDE_PATH .
+#define TRACE_INCLUDE_FILE cap_tracepoint
+#include <trace/define_trace.h>
diff --git a/drivers/soc/pensando/capmem_dev.h b/drivers/soc/pensando/capmem_dev.h
new file mode 100644
index 00000000..ac8547e
--- /dev/null
+++ b/drivers/soc/pensando/capmem_dev.h
@@ -0,0 +1,34 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2018-2021, Pensando Systems Inc.
+ */
+
+#ifndef __CAPMEM_H__
+#define __CAPMEM_H__
+
+#define CAPMEM_NAME		"capmem"
+#define CAPMEM_DEV		"/dev/capmem"
+#define CAPMEM_IOCTL_NUM	0xcc
+
+struct capmem_range {
+	uint64_t	start;
+	uint64_t	len;
+	int		type;
+};
+enum {
+	CAPMEM_TYPE_DEVICE,
+	CAPMEM_TYPE_COHERENT,
+	CAPMEM_TYPE_NONCOHERENT
+};
+
+struct capmem_ranges_args {
+	struct capmem_range *range;
+	int nranges;
+};
+
+#define CAPMEM_MAX_RANGES	64
+
+#define CAPMEM_GET_NRANGES	_IOR(CAPMEM_IOCTL_NUM, 1, int)
+#define CAPMEM_GET_RANGES	_IOWR(CAPMEM_IOCTL_NUM, 2, struct capmem_ranges_args)
+
+#endif
diff --git a/drivers/soc/pensando/kpci_constants.h b/drivers/soc/pensando/kpci_constants.h
new file mode 100644
index 00000000..c0c0133
--- /dev/null
+++ b/drivers/soc/pensando/kpci_constants.h
@@ -0,0 +1,42 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021, 2022, Oracle and/or its affiliates.
+ */
+/*
+ * Layout of non-Linux Memory:
+ *  (base address provided in device tree and may change)
+ *  C500 0000  SHMEM segment (pciehw_shmem_t) [0x942440 bytes ~9.25Mb]
+ *  C5F0 0000  kpcimgr state (kstate_t)       [3 * 64k]
+ *  C5F3 0000  relocated code                 [Allow 256k]
+ *  C5F7 0000  available for stack when in nommu mode (64k)
+ *  C5F8 0000  top of stack
+ *  C5FF FFFF  end of 1M allotted range
+ */
+#define SHMEM_KSTATE_OFFSET       0xF00000
+#define SHMEM_KSTATE_SIZE          0x30000
+#define KSTATE_STACK_OFFSET        0x80000
+#define KSTATE_CODE_OFFSET      (SHMEM_KSTATE_OFFSET + SHMEM_KSTATE_SIZE)
+#define KSTATE_CODE_SIZE        (256 * 1024)
+#define KSTATE_MAGIC            0x1743BA1F
+
+/* size of trace data arrays */
+#define DATA_SIZE 100
+#define MSG_BUF_SIZE 32768
+
+/* uart and time related constants */
+#define PEN_UART 0x4800
+#define UART_THR 0
+#define UART_LSR 0x14
+#define DATA_READY 1
+#define OK_TO_WRITE 0x20
+#define UART_THRE_BIT 5
+
+/* phases */
+#define NOMMU 0
+#define NORMAL 1
+#define NUM_PHASES 2
+
+#define MSI_INDIRECT_IDX	0	/* indirect vector */
+#define MSI_NOTIFY_IDX		1	/* notify vector */
+#define MSI_NVECTORS		2
+
diff --git a/drivers/soc/pensando/kpcimgr.c b/drivers/soc/pensando/kpcimgr.c
new file mode 100644
index 00000000..b7f559a
--- /dev/null
+++ b/drivers/soc/pensando/kpcimgr.c
@@ -0,0 +1,886 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Kernel PCIE Manager Infrastructure
+ *
+ * This driver enables the relocation of module code to handle
+ * Pensando/Elba indirect PCIe transactions. The purpose is to allow
+ * code to persist and run during a kexec reboot. The loaded code runs
+ * in physical mode during arm64_relocate_new_kernel and also during
+ * the early boot phase before traditional driver code can run. This
+ * is all to provide extremely low latency response to indirect
+ * transactions, which must be serviced within 200ms.
+ *
+ * Copyright (c) 2021, 2022, Oracle and/or its affiliates.
+ */
+
+#include "kpcimgr_api.h"
+#include "penpcie_dev.h"
+
+MODULE_LICENSE("GPL");
+
+kstate_t *kstate;
+DEFINE_SPINLOCK(kpcimgr_lock);
+static DECLARE_WAIT_QUEUE_HEAD(event_queue);
+
+void wake_up_event_queue(void)
+{
+	wake_up_interruptible(&event_queue);
+}
+
+/*
+ * We need our own memset/memcpy to avoid using
+ * any arm instructions that affect the memory cache.
+ * The memory used for kstate/code/etc is uncached.
+ */
+void *kpci_memset(void *s, int c, size_t n)
+{
+	if (((uintptr_t)s & 0x3) == 0 && (n & 0x3) == 0) {
+		u32 *p;
+		int i;
+
+		c &= 0xff;
+		c = ((c << 0) |
+		     (c << 8) |
+		     (c << 16) |
+		     (c << 24));
+		for (p = s, i = 0; i < n >> 2; i++, p++)
+			*p = c;
+	} else {
+		u8 *p;
+		int i;
+
+		for (p = s, i = 0; i < n; i++, p++)
+			*p = c;
+	}
+
+	return s;
+}
+
+void *kpci_memcpy(void *dst, const void *src, size_t n)
+{
+	u8 *d = dst;
+	const u8 *s = src;
+	int i;
+
+	for (i = 0; i < n; i++)
+		*d++ = *s++;
+
+	return dst;
+}
+
+/*
+ * Normal poll
+ */
+void kpcimgr_normal_poll(void)
+{
+	void (*poll_fn)(kstate_t *, int, int);
+	kstate_t *ks = get_kstate();
+	unsigned long flags;
+
+	spin_lock_irqsave(&kpcimgr_lock, flags);
+	if (ks->valid == KSTATE_MAGIC) {
+		poll_fn = ks->code_base + ks->code_offsets[K_ENTRY_POLL];
+		poll_fn(ks, 0, NORMAL);
+	}
+	spin_unlock_irqrestore(&kpcimgr_lock, flags);
+}
+
+void kpcimgr_start_running(void)
+{
+	kstate_t *ks = get_kstate();
+	void (*init_fn)(kstate_t *ks);
+	unsigned long flags;
+
+	spin_lock_irqsave(&kpcimgr_lock, flags);
+	if (ks->valid == KSTATE_MAGIC) {
+		init_fn = ks->code_base + ks->code_offsets[K_ENTRY_INIT_INTR];
+		ks->running = 1;
+		init_fn(ks);
+	}
+	spin_unlock_irqrestore(&kpcimgr_lock, flags);
+}
+
+void kpcimgr_stop_running(void)
+{
+	kstate_t *ks = get_kstate();
+	void (*shut_fn)(int n);
+	unsigned long flags;
+
+	spin_lock_irqsave(&kpcimgr_lock, flags);
+	if (ks->valid == KSTATE_MAGIC) {
+		shut_fn = ks->code_base + ks->code_offsets[K_ENTRY_SHUT];
+		shut_fn(ks->active_port);
+	}
+	spin_unlock_irqrestore(&kpcimgr_lock, flags);
+
+	ks->running = 0;
+}
+
+/*
+ * Read event(s) from the event queue. Used by pciemgrd to find out
+ * about h/w event notifications that arrived during times when
+ * pciemgrd is not running (ie, during a kexec).
+ *
+ * Standard event queue semantics:
+ *  evq_head = index of slot used for next insertion
+ *  evq_tail = index of slot used for next removal
+ *  queue is empty when head == tail
+ *  queue is full when (head + 1) % queue_size == tail
+ *  queue is nearly full when (head + 2) % queue_size == tail
+ *
+ * Only tail is modified here, and the event handler only
+ * modifies head, so theoretically no race can exist between
+ * queue insertion/removal. The mutex is here only to
+ * cover the case of multiple readers.
+ */
+static ssize_t
+read_kpcimgr(struct file *file, char __user *buf, size_t nbytes, loff_t *ppos)
+{
+	static DEFINE_MUTEX(evq_lock);
+	kstate_t *ks = get_kstate();
+	char localmem[EVENT_SIZE];
+	ssize_t n = 0;
+	int tail;
+
+	mutex_lock(&evq_lock);
+	tail = ks->evq_tail;
+
+	while (nbytes >= EVENT_SIZE && ks->evq_head != tail) {
+		/*
+		 * intermediate copy since we cannot prevent copy_to_user
+		 * from doing cache operations
+		 */
+		kpci_memcpy(localmem, (void *)ks->evq[tail], EVENT_SIZE);
+
+		if (copy_to_user(buf + n, localmem, EVENT_SIZE)) {
+			mutex_unlock(&evq_lock);
+			return -EFAULT;
+		}
+
+		tail = (tail + 1) % EVENT_QUEUE_LENGTH;
+		n = n + EVENT_SIZE;
+		nbytes = nbytes - EVENT_SIZE;
+	}
+	ks->evq_tail = tail;
+	mutex_unlock(&evq_lock);
+
+	return n;
+}
+
+/*
+ * pciemgrd wants to select() on /dev/kpcimgr to discover
+ * if there are events in the event queue.
+ */
+static unsigned int
+poll_kpcimgr(struct file *file, poll_table *wait)
+{
+	kstate_t *ks = get_kstate();
+
+	poll_wait(file, &event_queue, wait);
+	if (ks->evq_head != ks->evq_tail)
+		return POLLIN | POLLRDNORM;
+	else
+		return 0;
+}
+
+static int mmap_kpcimgr(struct file *file, struct vm_area_struct *vma)
+{
+	phys_addr_t offset = (phys_addr_t)vma->vm_pgoff << PAGE_SHIFT;
+	size_t size = vma->vm_end - vma->vm_start;
+	pgprot_t pgprot = vma->vm_page_prot;
+	kstate_t *ks = get_kstate();
+	unsigned long pfn, start;
+	void *pos;
+
+	if (offset + size > ks->shmem_size)
+		return -EINVAL;
+
+	if (ks->shmembase) {
+		pfn = (ks->shmembase + offset) >> PAGE_SHIFT;
+		pgprot = pgprot_device(pgprot);
+
+		if (!(file->f_flags & O_SYNC))
+			return -EINVAL;
+
+		pgprot = pgprot_writecombine(pgprot);
+		vma->vm_page_prot = pgprot;
+		if (remap_pfn_range(vma, vma->vm_start, pfn,
+				    size, vma->vm_page_prot))
+			return -EINVAL;
+	} else {
+		for (start = vma->vm_start, pos = ks->shmemva + offset;
+		     size > 0;
+		     start += PAGE_SIZE, pos += PAGE_SIZE, size -= PAGE_SIZE) {
+			pfn = vmalloc_to_pfn(pos);
+			if (remap_pfn_range(vma, start, pfn,
+					    PAGE_SIZE, vma->vm_page_prot))
+				return -EINVAL;
+		}
+	}
+
+	return 0;
+}
+
+/*
+ * Semantics of open(): if no code is loaded then open fails.
+ */
+static int open_kpcimgr(struct inode *inode, struct file *filp)
+{
+	kstate_t *ks = get_kstate();
+
+	if (ks->valid == KSTATE_MAGIC)
+		return 0;
+	else
+		return -ENODEV;
+}
+
+/*
+ * Examine code and look for calls (BL insn) and data references
+ * (ADRP) to memory addresses outside of the bounds of the module. If
+ * any are found, report them and return an error.
+ */
+int contains_external_refs(struct module *mod, void *code_end)
+{
+	unsigned long start = (unsigned long)mod->core_layout.base;
+	char code_loc[KSYM_SYMBOL_LEN], target_ref[KSYM_SYMBOL_LEN];
+	int insn_count, call_count, adrp_count;
+	unsigned long size, target, insn_addr;
+	s32 offset;
+	u32 insn;
+
+	size = (unsigned long)code_end - start;
+
+	for (insn_addr = start, insn_count = 0, call_count = 0, adrp_count = 0;
+	     insn_addr < start + size;
+	     insn_addr += sizeof(u32)) {
+		if (aarch64_insn_read((void *)insn_addr, &insn)) {
+			pr_err("Failed to read insn @ %lx\n", insn_addr);
+			return 1;
+		}
+		insn_count++;
+
+		if (aarch64_insn_is_bl(insn)) {
+			offset = aarch64_get_branch_offset(insn);
+			target = insn_addr + offset;
+
+			if (within_module(target, mod))
+				continue;
+
+			sprint_symbol(code_loc, insn_addr);
+			sprint_symbol(target_ref, target);
+			pr_err("Found call to %s at %s\n",
+			       target_ref, code_loc);
+
+			call_count++;
+		}
+
+		if (aarch64_insn_is_adrp(insn)) {
+			offset = aarch64_insn_adrp_get_offset(insn);
+			target = (insn_addr & PAGE_MASK) + offset;
+
+			if (within_module(target, mod))
+				continue;
+
+			sprint_symbol(code_loc, insn_addr);
+			sprint_symbol(target_ref, target);
+			pr_err("Found approximate reference to %s at %s\n",
+			       target_ref, code_loc);
+			pr_err(" (Please check object file for exact reference)\n");
+			adrp_count++;
+		}
+	}
+	pr_info("processed %d insns, %d extern calls, %d extern adrps\n",
+		insn_count, call_count, adrp_count);
+
+	if (call_count > 0 || adrp_count > 0)
+		return 1;
+	else
+		return 0;
+}
+
+/*
+ * module_register
+ *
+ * Register module code/data to be used with kpcimgr. If requested, we
+ * relocate module code to "non-linux memory". The struct module
+ * pointer is not quite enough to do this, and we require a pointer
+ * to the end of the module code section. This is because we need to
+ * examine the code for certain instructions, and we don't want to
+ * look beyond the end of the code since that will be data which
+ * might contain values which just look like instructions.
+ *
+ * If the code contains no external references, then we can freely
+ * relocate the code repeatedly without relinking.
+ *
+ * We shut down service and then copy the module in its entirety to
+ * non-linux memory which we have previously mapped executable.
+ *
+ * We can also run with the module code unrelocated, but this is only
+ * for debugging, as it preserves the modules symbols in kallsyms, so
+ * any stack trace will show useful function names instead of raw hex
+ * addresses.
+ *
+ * After the copy, we restart the service if necessary.
+ */
+int kpcimgr_module_register(struct module *mod,
+			    struct kpcimgr_entry_points_t *ep, int relocate)
+{
+	void *code_end = ep->code_end;
+	kstate_t *ks = get_kstate();
+	unsigned long start_addr, iflags;
+	void (*init_fn)(kstate_t *ks);
+	void (*version_fn)(char **);
+	char *mod_buildtime;
+	int i, was_running, nentries;
+
+	start_addr = (unsigned long)mod->core_layout.base;
+
+	if (ep->expected_mgr_version != KPCIMGR_KERNEL_VERSION
+#ifdef PEN_COMPAT_V2
+	    && ep->expected_mgr_version != 2
+#endif
+	   ) {
+		pr_info("KPCIMGR: '%s' expects kernel version %d, incompatible with version %d\n",
+			mod->name, ep->expected_mgr_version, KPCIMGR_KERNEL_VERSION);
+		return -EINVAL;
+	}
+
+	if (contains_external_refs(mod, code_end)) {
+		pr_err("KPCIMGR: relocation failed for '%s'\n", mod->name);
+		return -ENXIO;
+	}
+
+	if (mod->core_layout.size > KSTATE_CODE_SIZE) {
+		pr_err("KPCIMGR: module '%s' too large\n", mod->name);
+		return -EFBIG;
+	}
+
+	was_running = ks->running;
+	if (was_running) {
+		pr_info("%s: kpcimgr has stopped running\n", __func__);
+		kpcimgr_stop_running();
+	}
+	spin_lock_irqsave(&kpcimgr_lock, iflags);
+	ks->valid = 0;
+
+	if (ks->mod) {
+		module_put(ks->mod);
+		ks->mod = NULL;
+		ks->code_base = NULL;
+	}
+
+	if (ks->code_base)
+		module_memfree(ks->code_base);
+
+	if (relocate) {
+		ks->code_base = module_alloc(mod->core_layout.size);
+
+		if (ks->code_base == NULL) {
+			pr_err("KPCIMGR: module_alloc(%x)\n",
+			       mod->core_layout.size);
+			return -ENOMEM;
+		}
+		kpci_memcpy(ks->code_base, mod->core_layout.base,
+			    mod->core_layout.size);
+		set_memory_x((unsigned long)ks->code_base,
+			     mod->core_layout.size >> PAGE_SHIFT);
+	} else {
+		try_module_get(mod);
+		ks->mod = mod;
+		ks->code_base = mod->core_layout.base;
+	}
+	ks->code_size = mod->core_layout.size;
+
+#ifdef PEN_COMPAT_V2
+	nentries = ep->expected_mgr_version == 2 ? 7 : K_NUM_ENTRIES;
+#else
+	nentries = K_NUM_ENTRIES;
+#endif
+	for (i = 0; i < nentries; i++)
+		ks->code_offsets[i] = (unsigned long)ep->entry_point[i]
+			- start_addr;
+	for (; i < K_NUM_ENTRIES; i++)
+		ks->code_offsets[i] = 0;
+
+	if (ks->code_offsets[K_ENTRY_INIT_FN]) {
+		init_fn = ks->code_base + ks->code_offsets[K_ENTRY_INIT_FN];
+		init_fn(ks);
+	}
+
+	mod_buildtime = "";
+	if (ks->code_offsets[K_ENTRY_GET_VERSION]) {
+		version_fn = ks->code_base + ks->code_offsets[K_ENTRY_GET_VERSION];
+		version_fn(&mod_buildtime);
+	}
+
+	pr_info("KPCIMGR: module '%s: %s', start=%lx, end=%lx, size=%d\n",
+		mod->name, mod_buildtime, start_addr,
+		start_addr + mod->core_layout.size, mod->core_layout.size);
+
+	set_init_state(ks);
+	ks->valid = KSTATE_MAGIC;
+	ks->lib_version_major = ep->lib_version_major;
+	ks->lib_version_minor = ep->lib_version_minor;
+
+	spin_unlock_irqrestore(&kpcimgr_lock, iflags);
+	if (was_running) {
+		kpcimgr_start_running();
+		pr_info("%s: kpcimgr will begin running\n", __func__);
+	} else {
+		reset_stats(ks);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(kpcimgr_module_register);
+
+static void unmap_resources(void)
+{
+	kstate_t *ks = get_kstate();
+
+	int i;
+
+	for (i = 0; i < ks->nranges; i++) {
+		if (ks->mem_ranges[i].vaddr)
+			iounmap(ks->mem_ranges[i].vaddr);
+	}
+
+	if (ks->uart_addr)
+		iounmap(ks->uart_addr);
+
+	if (ks->have_persistent_mem) {
+		if (ks->persistent_base)
+			iounmap(ks->persistent_base);
+		if (ks->shmemva)
+			iounmap(ks->shmemva);
+		iounmap(ks);
+	} else {
+		vfree(ks->shmemva);
+		vfree((void *)ks);
+	}
+}
+
+static int map_resources(struct platform_device *pfdev)
+{
+	struct device_node *dn = pfdev->dev.of_node;
+	u32 shmem_idx, hwmem_idx;
+	struct resource res;
+	kstate_t *ks;
+	void *shmem;
+	int i, err;
+
+	err = of_property_read_u32(dn, "hwmem-index", &hwmem_idx);
+	if (err) {
+		pr_err("KPCIMGR: no hwmem-index value found\n");
+		return -ENOMEM;
+	}
+
+	err = of_property_read_u32(dn, "shmem-index", &shmem_idx);
+	if (err) {
+		pr_err("KPCIMGR: no shmem-index value found\n");
+		return -ENOMEM;
+	}
+
+	err = of_address_to_resource(dn, shmem_idx, &res);
+	if (err) {
+		pr_err("KPCIMGR: no resource found for shmem-index=%d\n",
+		       shmem_idx);
+		return -ENOMEM;
+	}
+
+	if (res.start == 0) {
+		/* indicates no persistent memory */
+		pr_info("KPCIMGR: no persistent memory\n");
+		ks = vmalloc(sizeof(kstate_t));
+		if (ks == NULL)
+			return -ENOMEM;
+		memset((void *)ks, 0, sizeof(kstate_t));
+		ks->active_port = -1;
+		ks->have_persistent_mem = 0;
+		shmem = vmalloc(resource_size(&res));
+		if (shmem == NULL) {
+			vfree((void *)ks);
+			return -ENOMEM;
+		}
+		ks->shmembase = 0;
+		ks->shmem_size = resource_size(&res);
+	} else {
+		if (resource_size(&res) > SHMEM_KSTATE_OFFSET) {
+			pr_err("KPCIMGR: shmem size overlaps kstate\n");
+			return -ENODEV;
+		}
+		shmem = ioremap(res.start, resource_size(&res));
+		if (shmem == NULL) {
+			pr_err("KPCIMGR: failed to map shmem\n");
+			return -ENODEV;
+		}
+
+		ks = ioremap(res.start + SHMEM_KSTATE_OFFSET, sizeof(kstate_t));
+		if (ks == NULL) {
+			pr_err("KPCIMGR: failed to map kstate\n");
+			iounmap(shmem);
+			return -ENOMEM;
+		}
+		if (ks->valid != KSTATE_MAGIC) {
+			kpci_memset((void *)ks, 0, sizeof(kstate_t));
+			ks->active_port = -1;
+		}
+
+		ks->have_persistent_mem = 1;
+		ks->shmembase = res.start;
+		ks->shmem_size = resource_size(&res);
+		pr_info("KPCIMGR: kstate mapped %llx at %lx\n",
+			res.start + SHMEM_KSTATE_OFFSET, (long)ks);
+
+		ks->persistent_base = ioremap(res.start + KSTATE_CODE_OFFSET,
+					      KSTATE_CODE_SIZE);
+		if (ks->persistent_base == NULL) {
+			pr_err("KPCIMGR: failed to map shmem code space\n");
+			goto errout;
+		}
+
+		if (ks->valid == KSTATE_MAGIC) {
+			ks->code_base = module_alloc(ks->code_size);
+			if (ks->code_base == NULL) {
+				pr_err("KPCIMGR: module_alloc(%lx) failed\n",
+				       ks->code_size);
+				goto errout;
+			}
+			kpci_memcpy(ks->code_base, ks->persistent_base,
+				    ks->code_size);
+			set_memory_x((unsigned long)ks->code_base,
+				     ks->code_size >> PAGE_SHIFT);
+		}
+	}
+
+	kstate = ks;
+	ks->shmemva = shmem;
+
+	ks->uart_addr = ioremap(PEN_UART, 0x1000);
+	if (ks->uart_addr == NULL) {
+		pr_err("KPCIMGR: failed to map elba uart\n");
+		goto errout;
+	}
+	ks->driver_start_time = read_sysreg(cntvct_el0);
+
+	ks->nranges = 0;
+	for (i = 0; i < NUM_MEMRANGES; i++) {
+		struct mem_range_t *mr = &ks->mem_ranges[ks->nranges];
+
+		if (i == shmem_idx)
+			continue;
+
+		err = of_address_to_resource(dn, i, &res);
+		if (err)
+			break;
+
+		mr->base = res.start;
+		mr->end = res.start + resource_size(&res);
+		mr->vaddr = ioremap(res.start, resource_size(&res));
+		if (IS_ERR(mr->vaddr)) {
+			pr_err(PFX "iomap resource %d failed\n", i);
+			goto errout;
+		}
+		if (i == hwmem_idx)
+			ks->hwmem_idx = ks->nranges;
+		ks->nranges++;
+	}
+	return 0;
+
+ errout:
+	unmap_resources();
+	return -ENOMEM;
+}
+
+/*
+ * ISR for indirect transaction
+ */
+static irqreturn_t kpcimgr_indirect_intr(int irq, void *arg)
+{
+	int (*intr_fn)(kstate_t *, int);
+	kstate_t *ks = (kstate_t *)arg;
+	int port, r = 0;
+
+	spin_lock(&kpcimgr_lock);
+	if (ks->valid == KSTATE_MAGIC) {
+		ks->ind_intr++;
+		intr_fn = ks->code_base +
+			ks->code_offsets[K_ENTRY_INDIRECT_INTR];
+
+		port = ks->active_port;
+		if (port >= 0)
+			r = intr_fn(ks, port);
+	}
+	spin_unlock(&kpcimgr_lock);
+
+	return r ? IRQ_HANDLED : IRQ_NONE;
+}
+
+/*
+ * ISR for notify transaction
+ */
+static irqreturn_t kpcimgr_notify_intr(int irq, void *arg)
+{
+	int (*intr_fn)(kstate_t *, int);
+	kstate_t *ks = (kstate_t *)arg;
+	int port, r = 0;
+
+	spin_lock(&kpcimgr_lock);
+	if (ks->valid == KSTATE_MAGIC) {
+		ks->not_intr++;
+		intr_fn = ks->code_base + ks->code_offsets[K_ENTRY_NOTIFY_INTR];
+
+		port = ks->active_port;
+		if (port >= 0)
+			r = intr_fn(ks, port);
+	}
+	spin_unlock(&kpcimgr_lock);
+
+	return r ? IRQ_HANDLED : IRQ_NONE;
+}
+
+u64 kpcimgr_preg_read(u64 pa)
+{
+	u32 val;
+
+	pciep_regrd32((uint64_t)pa, &val);
+	return (u64)val;
+}
+
+static u64 kpcimgr_upcall(int req, u64 arg1, u64 arg2, u64 arg3)
+{
+	kstate_t *ks = get_kstate();
+
+	if (ks->valid != KSTATE_MAGIC)		/* no code loaded */
+		return 1;
+
+	switch (req) {
+	case WAKE_UP_EVENT_QUEUE:
+		ks->event_intr++;
+		wake_up_event_queue();
+		break;
+	case PRINT_LOG_MSG:
+		printk((char *)arg1); /* KERN_LEVEL provided by arg1 */
+		break;
+	case PREG_READ:
+		return kpcimgr_preg_read(arg1);
+	default:
+		return 1;
+	}
+	return 0;
+}
+
+static void set_msi_msg(struct msi_desc *desc, struct msi_msg *msg)
+{
+	kstate_t *ks = get_kstate();
+	struct msi_info *msi = &ks->msi[desc->platform.msi_index];
+
+	msi->msgaddr = ((u64)msg->address_hi << 32) | msg->address_lo;
+	msi->msgdata = msg->data;
+}
+
+static void free_intrs(struct platform_device *pfdev)
+{
+	kstate_t *ks = get_kstate();
+	struct device *dev = &pfdev->dev;
+	struct msi_desc *desc;
+
+	for_each_msi_entry(desc, dev)
+		free_irq(desc->irq, (void *)ks);
+
+	platform_msi_domain_free_irqs(&pfdev->dev);
+}
+
+struct {
+	irqreturn_t (*isr)(int irq, void *arg);
+	char *name;
+} kpcimgr_irq_table[] = {
+	{ kpcimgr_indirect_intr, "kpcimgr-indirect"},
+	{ kpcimgr_notify_intr,   "kpcimgr-notify"  },
+};
+
+static int alloc_intrs(struct platform_device *pfdev)
+{
+	irqreturn_t (*isr)(int irq, void *arg);
+	struct device *dev = &pfdev->dev;
+	kstate_t *ks = get_kstate();
+	struct msi_desc *desc;
+	char *name;
+	int r;
+
+	r = platform_msi_domain_alloc_irqs(dev, MSI_NVECTORS, set_msi_msg);
+	if (r)
+		return r;
+
+	for_each_msi_entry(desc, dev) {
+		isr = kpcimgr_irq_table[desc->platform.msi_index].isr;
+		name = kpcimgr_irq_table[desc->platform.msi_index].name;
+		r = devm_request_irq(dev, desc->irq, isr, 0, name, (void *)ks);
+		if (r)
+			goto err_out;
+	}
+	return 0;
+
+ err_out:
+	free_intrs(pfdev);
+	return r;
+}
+
+/*
+ * Called when a kexec is about to happen
+ */
+static int kpcimgr_notify_reboot(struct notifier_block *this,
+				 unsigned long code,
+				 void *unused)
+{
+	kstate_t *ks = get_kstate();
+	int was_running = ks->running;
+
+	/* stop running regardless of why a reboot is happening */
+	free_intrs(ks->pfdev);
+	if (was_running)
+		kpcimgr_stop_running();
+
+	if (!ks->code_base) {
+		pr_err("KPCIMGR: halting since no code is loaded\n");
+		ks->valid = 0;
+		return NOTIFY_DONE;
+	}
+
+	if (!ks->have_persistent_mem) {
+		pr_err("KPCIMGR: halting since code is not persistent\n");
+		ks->valid = 0;
+		return NOTIFY_DONE;
+	}
+
+	/* relocate code to "persistent" memory */
+	kpci_memcpy(ks->persistent_base, ks->code_base, ks->code_size);
+
+	if (code == SYS_DOWN) {
+		pr_err("KPCIMGR: going down at tick %lld\n",
+		       read_sysreg(cntvct_el0));
+
+		if (was_running)
+			ks->running = 1;
+
+		reset_stats(ks);
+		ks->ncalls = 0;
+		ks->kexec_time = read_sysreg(cntvct_el0);
+	}
+	return NOTIFY_DONE;
+}
+
+/*
+ * Driver Initialization
+ */
+static const struct file_operations __maybe_unused kpcimgr_fops = {
+	.owner          = THIS_MODULE,
+	.read           = read_kpcimgr,
+	.poll           = poll_kpcimgr,
+	.open           = open_kpcimgr,
+	.mmap           = mmap_kpcimgr,
+};
+
+static struct miscdevice kpcimgr_dev = {
+	MISC_DYNAMIC_MINOR,
+	KPCIMGR_NAME,
+	&kpcimgr_fops
+};
+
+static int kpcimgr_probe(struct platform_device *pfdev)
+{
+	kstate_t *ks;
+	int err;
+
+	err = map_resources(pfdev);
+	if (err)
+		goto errout;
+
+	ks = get_kstate();
+	ks->pfdev = pfdev;
+
+	err = alloc_intrs(ks->pfdev);
+	if (err) {
+		pr_err(PFX "alloc intrs: %d\n", err);
+		goto errout_unmap;
+	}
+
+	err = misc_register(&kpcimgr_dev);
+	if (err) {
+		pr_err(PFX "register pciemgr_dev failed: %d\n", err);
+		goto errout_free_intrs;
+	}
+
+	ks->upcall = (void *)kpcimgr_upcall;
+	if (ks->valid == KSTATE_MAGIC && ks->running) {
+		ks->mod = NULL;
+		kpcimgr_start_running();
+		kpcimgr_normal_poll();
+		pr_err("KPCIMGR: initialized and running.\n");
+	}
+	if (ks->have_persistent_mem) {
+		static struct notifier_block kpcimgr_nb = {
+			.notifier_call = kpcimgr_notify_reboot,
+			.next = NULL,
+			.priority = 0,
+		};
+		register_reboot_notifier(&kpcimgr_nb);
+	}
+
+	pr_info("KPCIMGR: kstate mapped at %lx, code at %lx\n",
+		(long)ks, (long)ks->code_base);
+
+	kpcimgr_sysfs_setup(pfdev);
+	return 0;
+
+ errout_free_intrs:
+	free_intrs(pfdev);
+
+ errout_unmap:
+	unmap_resources();
+
+ errout:
+	return err;
+}
+
+static const struct of_device_id kpcimgr_of_match[] = {
+	{ .compatible = "pensando,kpcimgr" },
+	{ /* end of table */ }
+};
+
+static struct platform_driver kpcimgr_driver = {
+	.probe = kpcimgr_probe,
+	.driver = {
+		.name = "pensando-kpcimgr",
+		.owner = THIS_MODULE,
+		.of_match_table = kpcimgr_of_match,
+	},
+};
+builtin_platform_driver(kpcimgr_driver);
+
+/*
+ * Get entry point for pciesvc specific secondary cpu holding pen.
+ * Called from arch/arm64/kernel/smp_spin_table.c
+ * We choose the first cpu to arrive here. They will all try
+ * concurrently, but only one will be hijacked and the rest
+ * will go to their default holding pens.
+ */
+unsigned long kpcimgr_get_entry(unsigned long old_entry, unsigned int cpu)
+{
+	unsigned long (*entry_fn)(unsigned long entry, unsigned int cpu);
+	static DEFINE_SPINLOCK(choose_cpu_lock);
+	kstate_t *ks = get_kstate();
+	unsigned long entry;
+
+	if (ks == NULL || ks->valid != KSTATE_MAGIC ||
+	    !ks->running || !ks->have_persistent_mem)
+		return old_entry;
+
+	entry_fn = ks->code_base + ks->code_offsets[K_ENTRY_HOLDING_PEN];
+
+	spin_lock(&choose_cpu_lock);
+	entry = entry_fn(old_entry, cpu);
+	spin_unlock(&choose_cpu_lock);
+
+	return entry;
+}
diff --git a/drivers/soc/pensando/kpcimgr_api.h b/drivers/soc/pensando/kpcimgr_api.h
new file mode 100644
index 00000000..8bfcda1
--- /dev/null
+++ b/drivers/soc/pensando/kpcimgr_api.h
@@ -0,0 +1,172 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2021, 2022, Oracle and/or its affiliates.
+ */
+#ifndef __KPCIMGR_API_H__
+#define __KPCIMGR_API_H__
+
+#ifdef __KERNEL__
+#include <linux/miscdevice.h>
+#include <linux/io.h>
+#include <linux/module.h>
+#include <linux/cdev.h>
+#include <linux/reboot.h>
+#include <linux/poll.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/interrupt.h>
+#include <linux/msi.h>
+#include <linux/mm.h>
+#include <linux/kallsyms.h>
+#include <linux/moduleloader.h>
+#include <linux/set_memory.h>
+#include <asm/insn.h>
+#endif
+
+#include "kpci_constants.h"
+
+#define K_ENTRY_INIT_INTR 0
+#define K_ENTRY_INIT_POLL 1
+#define K_ENTRY_SHUT 2
+#define K_ENTRY_POLL 3
+#define K_ENTRY_HOLDING_PEN 4
+#define K_ENTRY_INDIRECT_INTR 5
+#define K_ENTRY_NOTIFY_INTR 6
+#define K_ENTRY_INIT_FN 7
+#define K_ENTRY_CMD_READ 8
+#define K_ENTRY_CMD_WRITE 9
+#define K_ENTRY_GET_VERSION 10
+#define K_NUM_ENTRIES 16
+
+struct kpcimgr_entry_points_t {
+	int expected_mgr_version;
+	int lib_version_major;
+	int lib_version_minor;
+	void *code_end;
+	void *entry_point[K_NUM_ENTRIES];
+};
+
+/* upcalls */
+#define WAKE_UP_EVENT_QUEUE 1
+#define PRINT_LOG_MSG 2
+#define PREG_READ 3
+
+/* event queue sizing */
+#define EVENT_QUEUE_LENGTH 1024
+#define EVENT_SIZE 128
+
+/* max command size for sysfs cmd node */
+#define CMD_SIZE 4096
+
+/* max number of memory ranges from device tree */
+#define NUM_MEMRANGES 32
+
+struct kpcimgr_state_t {
+	/* essential state */
+	int valid;
+	int debug;
+	int running;
+	int active_port;
+	int have_persistent_mem;
+	int lib_version_major;
+	int lib_version_minor;
+
+	/* timestamps and general trace data */
+	long kexec_time;
+	long driver_start_time;
+	unsigned long trace_data[NUM_PHASES][DATA_SIZE];
+
+	/* virtual addresses */
+	void *uart_addr;
+	void *code_base;
+	void *persistent_base;
+	void *upcall;
+	void *pfdev;
+	void *shmemva;
+
+	unsigned long shmembase, shmem_size, code_size;
+	struct mem_range_t {
+		unsigned long base, end;
+		void *vaddr;
+	} mem_ranges[NUM_MEMRANGES];
+	int nranges;
+	int hwmem_idx;
+
+	/* interrupt vectors */
+	struct msi_info {
+		unsigned long msgaddr;
+		unsigned int msgdata;
+	} msi[MSI_NVECTORS];
+
+	/* stats for work done */
+	int ind_cfgrd, ind_cfgwr;
+	int ind_memrd, ind_memwr;
+	int ncalls;
+	int ind_intr, not_intr, event_intr;
+
+	int unused1[7];	/* was version=2 code_offsets[], keep evq* compat */
+
+	/* Event queue handling */
+	int evq_head, evq_tail;
+	char evq[EVENT_QUEUE_LENGTH][EVENT_SIZE];
+
+	/* debugging */
+	void *mod;
+	int msg_idx;
+	int cfgval;
+
+	/* offsets into relocated library code */
+	int code_offsets[K_NUM_ENTRIES];
+};
+
+typedef struct kpcimgr_state_t kstate_t;
+_Static_assert(sizeof(kstate_t) < SHMEM_KSTATE_SIZE,
+	       "kstate size insufficient");
+
+/* trace_data[] elements */
+#define FIRST_CALL_TIME 0
+#define FIRST_SEQNUM 1
+#define LAST_SEQNUM 2
+#define TAG 3
+#define PA_BAD_CNT 4
+#define NUM_CHECKS 5
+#define NUM_CALLS 6
+#define NUM_PENDINGS 7
+#define LAST_CALL_TIME 8
+#define EARLY_POLL 9
+#define MAX_DATA 10
+
+#define KPCIMGR_DEV "/dev/kpcimgr"
+#define KPCIMGR_NAME "kpcimgr"
+#define PFX KPCIMGR_NAME ": "
+#define KPCIMGR_KERNEL_VERSION 3
+
+#ifdef __KERNEL__
+int kpcimgr_module_register(struct module *mod,
+			    struct kpcimgr_entry_points_t *ep, int relocate);
+void kpcimgr_start_running(void);
+void kpcimgr_stop_running(void);
+void kpcimgr_sysfs_setup(struct platform_device *pfdev);
+void *kpci_memcpy(void *dst, const void *src, size_t n);
+void wake_up_event_queue(void);
+int aarch64_insn_read(void *addr, u32 *insnp);
+extern spinlock_t kpcimgr_lock;
+
+#define reset_stats(k) \
+	kpci_memset((void *)&(k)->trace_data[0][0], 0, sizeof((k)->trace_data))
+
+static inline void set_init_state(kstate_t *k)
+{
+	k->trace_data[NORMAL][FIRST_CALL_TIME] = 0;
+	k->ncalls = 0;
+}
+
+static inline kstate_t *get_kstate(void)
+{
+	extern kstate_t *kstate;
+	return kstate;
+}
+#endif
+
+#endif
diff --git a/drivers/soc/pensando/kpcimgr_sysfs.c b/drivers/soc/pensando/kpcimgr_sysfs.c
new file mode 100644
index 00000000..fcee544a
--- /dev/null
+++ b/drivers/soc/pensando/kpcimgr_sysfs.c
@@ -0,0 +1,277 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Kernel PCIE Manager SYSFS functions
+ *
+ * Copyright (c) 2021, 2022, Oracle and/or its affiliates.
+ */
+
+#include "kpcimgr_api.h"
+
+int kpcimgr_active_port;
+
+/* 'valid' read returns value of valid field */
+static ssize_t valid_show(struct device *dev,
+			  struct device_attribute *attr,
+			  char *buf)
+{
+	kstate_t *ks = get_kstate();
+
+	return sprintf(buf, "%x\n", ks->valid);
+}
+
+/* 'valid' write causes invalidation, regardless of value written */
+static ssize_t valid_store(struct device *dev,
+			   struct device_attribute *attr,
+			   const char *buf,
+			   size_t count)
+{
+	kstate_t *ks = get_kstate();
+
+	if (ks->running) {
+		kpcimgr_stop_running();
+		pr_info("%s: kpcimgr has stopped running\n", __func__);
+	}
+	ks->valid = 0;
+	ks->debug = 0;
+	if (ks->mod) {
+		module_put(ks->mod);
+		ks->mod = NULL;
+		ks->code_base = NULL;
+	}
+
+	pr_info("%s: code unloaded\n", __func__);
+	return count;
+}
+
+static ssize_t running_show(struct device *dev,
+			    struct device_attribute *attr,
+			    char *buf)
+{
+	kstate_t *ks = get_kstate();
+
+	return sprintf(buf, "%x\n", ks->running | ks->debug);
+}
+
+static ssize_t running_store(struct device *dev,
+			     struct device_attribute *attr,
+			     const char *buf,
+			     size_t count)
+{
+	kstate_t *ks = get_kstate();
+	ssize_t rc;
+	long val;
+
+	rc = kstrtol(buf, 0, &val);
+	if (rc)
+		return rc;
+
+	if (!ks->valid)
+		return -EINVAL;
+
+	if (val == 0) {
+		if (ks->running) {
+			kpcimgr_stop_running();
+			pr_info("%s: kpcimgr has stopped polling\n", __func__);
+		}
+	} else {
+		if (ks->running) {
+			pr_info("%s: kpcimgr is already running\n", __func__);
+		} else {
+			ks->active_port = ffs(kpcimgr_active_port) - 1;
+			pr_info("%s: kpcimgr will begin running on port %d\n",
+				__func__, ks->active_port);
+			kpcimgr_start_running();
+		}
+		ks->debug = val & 0xfff0;
+	}
+
+	return count;
+}
+
+static ssize_t cfgval_show(struct device *dev,
+			   struct device_attribute *attr,
+			   char *buf)
+{
+	kstate_t *ks = get_kstate();
+
+	return sprintf(buf, "%x\n", ks->cfgval);
+}
+
+static ssize_t cfgval_store(struct device *dev,
+			    struct device_attribute *attr,
+			    const char *buf,
+			    size_t count)
+{
+	kstate_t *ks = get_kstate();
+	ssize_t rc;
+	long val;
+
+	rc = kstrtol(buf, 0, &val);
+	if (rc)
+		return rc;
+
+	if (!ks->valid)
+		return -EINVAL;
+
+	ks->cfgval = val;
+	return count;
+}
+
+static ssize_t lib_version_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	kstate_t *ks = get_kstate();
+
+	if (!ks->valid)
+		return -ENODEV;
+
+	return sprintf(buf, "%d.%d\n", ks->lib_version_major,
+		       ks->lib_version_minor);
+}
+
+static ssize_t mgr_version_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	return sprintf(buf, "%d\n", KPCIMGR_KERNEL_VERSION);
+}
+
+static ssize_t command_read(struct file *file, struct kobject *kobj,
+			    struct bin_attribute *attr, char *out,
+			    loff_t off, size_t count)
+{
+	int (*cmd_read)(kstate_t *, char *, loff_t, size_t, int *);
+	kstate_t *ks = get_kstate();
+	int ret, success = 0;
+	unsigned long flags;
+
+	if (!ks->valid)
+		return -ENODEV;
+	if (ks->code_offsets[K_ENTRY_CMD_READ]) {
+		cmd_read = ks->code_base + ks->code_offsets[K_ENTRY_CMD_READ];
+		spin_lock_irqsave(&kpcimgr_lock, flags);
+		ret = cmd_read(ks, out, off, count, &success);
+		spin_unlock_irqrestore(&kpcimgr_lock, flags);
+	}
+	if (success)
+		return ret;
+	else
+		return 0;
+}
+
+static ssize_t command_write(struct file *filp, struct kobject *kobj,
+			     struct bin_attribute *bin_attr, char *buf,
+			     loff_t off, size_t count)
+{
+	int (*cmd_write)(kstate_t *, const char *, loff_t, size_t, int *);
+	kstate_t *ks = get_kstate();
+	int ret, success = 0;
+	unsigned long flags;
+
+	if (!ks->valid)
+		return -ENODEV;
+	if (ks->code_offsets[K_ENTRY_CMD_WRITE]) {
+		cmd_write = ks->code_base + ks->code_offsets[K_ENTRY_CMD_WRITE];
+		spin_lock_irqsave(&kpcimgr_lock, flags);
+		ret = cmd_write(ks, buf, off, count, &success);
+		spin_unlock_irqrestore(&kpcimgr_lock, flags);
+	}
+	if (success)
+		return ret;
+	else
+		return count;
+}
+
+/* event queue peek */
+static ssize_t event_queue_read(struct file *file, struct kobject *kobj,
+				struct bin_attribute *attr, char *out,
+				loff_t off, size_t count)
+{
+	kstate_t *ks = get_kstate();
+
+	/* is queue empty? */
+	if (ks->evq_head == ks->evq_tail)
+		return 0;
+
+	kpci_memcpy(out, (void *)ks->evq[ks->evq_tail], EVENT_SIZE);
+	return EVENT_SIZE;
+}
+
+/*
+ * This function is for testing. It injects an event onto the
+ * event queue, simulating an event notification from h/w.
+ */
+static ssize_t event_queue_write(struct file *filp, struct kobject *kobj,
+				 struct bin_attribute *bin_attr, char *buf,
+				 loff_t off, size_t count)
+{
+	kstate_t *ks = get_kstate();
+
+	if (count != EVENT_SIZE)
+		return -EINVAL;
+
+	if ((ks->evq_head + 1) % EVENT_QUEUE_LENGTH == ks->evq_tail)
+		return -ENOSPC;
+
+	kpci_memcpy((void *)ks->evq[ks->evq_head], buf, EVENT_SIZE);
+	ks->evq_head = (ks->evq_head + 1) % EVENT_QUEUE_LENGTH;
+	wake_up_event_queue();
+
+	return EVENT_SIZE;
+}
+
+static ssize_t kstate_read(struct file *file, struct kobject *kobj,
+			   struct bin_attribute *attr, char *out,
+			   loff_t off, size_t count)
+{
+	kstate_t *ks = get_kstate();
+
+	kpci_memcpy(out, (void *)ks + off, count);
+	return count;
+}
+
+static DEVICE_ATTR_RW(valid);
+static DEVICE_ATTR_RW(running);
+static DEVICE_ATTR_RW(cfgval);
+static DEVICE_ATTR_RO(lib_version);
+static DEVICE_ATTR_RO(mgr_version);
+static DEVICE_INT_ATTR(active_port, 0644, kpcimgr_active_port);
+static BIN_ATTR_RO(kstate, sizeof(kstate_t));
+static BIN_ATTR_RW(event_queue, EVENT_SIZE);
+static BIN_ATTR_RW(command, CMD_SIZE);
+
+static struct attribute *dev_attrs[] = {
+	&dev_attr_valid.attr,
+	&dev_attr_running.attr,
+	&dev_attr_cfgval.attr,
+	&dev_attr_active_port.attr.attr,
+	&dev_attr_lib_version.attr,
+	&dev_attr_mgr_version.attr,
+	NULL,
+};
+
+static struct bin_attribute *dev_bin_attrs[] = {
+	&bin_attr_kstate,
+	&bin_attr_event_queue,
+	&bin_attr_command,
+	NULL,
+};
+
+const struct attribute_group kpci_attr_group = {
+	.attrs = dev_attrs,
+	.bin_attrs = dev_bin_attrs,
+};
+
+void kpcimgr_sysfs_setup(struct platform_device *pfdev)
+{
+	if (sysfs_create_group(&pfdev->dev.kobj, &kpci_attr_group)) {
+		pr_err("KPCIMGR:sysfs_create_group failed\n");
+		return;
+	}
+
+	if (sysfs_create_link(kernel_kobj, &pfdev->dev.kobj, "kpcimgr")) {
+		pr_err("KPCIMGR: failed top create sysfs link\n");
+		return;
+	}
+}
diff --git a/drivers/soc/pensando/penfw.h b/drivers/soc/pensando/penfw.h
new file mode 100644
index 00000000..429f80d
--- /dev/null
+++ b/drivers/soc/pensando/penfw.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (c) 2021, Pensando Systems Inc.
+ */
+
+#ifndef __PENFW_H__
+#define __PENFW_H__
+
+enum penfw_opcodes {
+	PENFW_OP_GET_API_VER = 0,
+	PENFW_OP_GET_PENTRUST_STA,
+	PENFW_OP_SET_PENTRUST_UPG,
+	PENFW_OP_GET_BL1_STA,
+	PENFW_OP_SET_BL1_UPG,
+	PENFW_OP_GET_BL1_AR_NVCNTR,
+	PENFW_OP_COMMIT_BL1_AR_NVCNTR,
+	PENFW_OP_GET_BL31_SW_VER,
+	PENFW_OP_GET_BOOT_LCS,
+	PENFW_OP_GET_NEXT_LCS,
+	PENFW_OP_COMMIT_LCS_PROD,
+	PENFW_OPCODE_MAX,
+};
+
+struct penfw_call_args {
+	int64_t a0;
+	uint64_t a1;
+	uint64_t a2;
+	uint64_t a3;
+};
+
+#define PENFW_IOCTL_NUM  0xcd
+#define PENFW_FWCALL     _IOWR(PENFW_IOCTL_NUM, 1, struct penfw_call_args)
+
+void penfw_smc(struct penfw_call_args *args);
+
+#endif /* __PENFW_H__ */
diff --git a/drivers/soc/pensando/penfw_drv.c b/drivers/soc/pensando/penfw_drv.c
new file mode 100644
index 00000000..da718c9
--- /dev/null
+++ b/drivers/soc/pensando/penfw_drv.c
@@ -0,0 +1,145 @@
+/*
+ * Copyright (c) 2021, Pensando Systems Inc.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/types.h>
+#include <linux/mutex.h>
+#include <linux/platform_device.h>
+#include <linux/of.h>
+#include <linux/arm-smccc.h>
+
+#include "penfw.h"
+#include "penfw_sysfs.h"
+
+#define  DEVICE_NAME "penfw"
+#define  CLASS_NAME  "penfw"
+
+static int    majorNumber;
+static struct class *penfw_class;
+static struct device *penfw_dev;
+static DEFINE_MUTEX(penfw_mutex);
+
+static int penfw_open(struct inode *inodep, struct file *filep)
+{
+	return 0;
+}
+
+static long penfw_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+{
+	long ret = 0;
+	void __user *argp = (void __user *)arg;
+	struct penfw_call_args penfw_args_ob;
+
+	mutex_lock(&penfw_mutex);
+
+	if (copy_from_user(&penfw_args_ob, argp, sizeof(penfw_args_ob))) {
+		dev_err(penfw_dev, "copy from user failed\n");
+		ret = -EFAULT;
+		goto err;
+	}
+
+	if (cmd != PENFW_FWCALL) {
+		dev_err(penfw_dev, "received unsupported ioctl %u\n", cmd);
+		ret = -EOPNOTSUPP;
+		goto err;
+	}
+
+	penfw_smc(&penfw_args_ob);
+
+	// copy back data to user space struct
+	if (copy_to_user(argp, &penfw_args_ob, sizeof(penfw_args_ob))) {
+		dev_err(penfw_dev, "copy to user failed\n");
+		ret = -EFAULT;
+		goto err;
+	}
+
+err:
+	mutex_unlock(&penfw_mutex);
+
+	return ret;
+}
+
+static struct file_operations fops = {
+	.open = penfw_open,
+	.unlocked_ioctl = penfw_ioctl
+};
+
+static int penfw_probe(struct platform_device *pdev)
+{
+	int ret;
+
+	printk(KERN_INFO "penfw: initializing the device\n");
+	mutex_init(&penfw_mutex);
+	majorNumber = register_chrdev(0, DEVICE_NAME, &fops);
+	if (majorNumber < 0) {
+		printk(KERN_ERR "penfw: failed to register a major number\n");
+		return majorNumber;
+	}
+	printk(KERN_INFO "penfw: registered correctly with major number %d\n",
+			 majorNumber);
+
+	// register the device class
+	penfw_class = class_create(THIS_MODULE, CLASS_NAME);
+	if (IS_ERR(penfw_class)) {
+		unregister_chrdev(majorNumber, DEVICE_NAME);
+		printk(KERN_ERR "penfw: failed to register device class\n");
+		return PTR_ERR(penfw_class);
+	}
+	printk(KERN_INFO "penfw: device class registered correctly\n");
+
+	// register the device driver
+	penfw_dev = device_create(penfw_class, NULL, MKDEV(majorNumber, 0),
+				  NULL, DEVICE_NAME);
+	if (IS_ERR(penfw_dev)) {
+		class_destroy(penfw_class);
+		unregister_chrdev(majorNumber, DEVICE_NAME);
+		dev_err(penfw_dev, "failed to create the device\n");
+		return PTR_ERR(penfw_dev);
+	}
+	dev_info(penfw_dev, "device class created correctly\n");
+
+	ret = penfw_sysfs_init(penfw_dev);
+	if (ret != 0) {
+		dev_err(penfw_dev, "penfw sys initialization failed\n");
+		return -1;
+	}
+	dev_info(penfw_dev, "penfw sys initialization success\n");
+
+	return 0;
+}
+
+static int penfw_remove(struct platform_device *pd)
+{
+	mutex_destroy(&penfw_mutex);
+	device_destroy(penfw_class, MKDEV(majorNumber, 0));
+	class_unregister(penfw_class);
+	class_destroy(penfw_class);
+	unregister_chrdev(majorNumber, DEVICE_NAME);
+	penfw_sysfs_deinit();
+	printk(KERN_INFO "penfw: Exiting!\n");
+
+	return 0;
+}
+
+static struct of_device_id penfw_of_match[] = {
+	{ .compatible = "pensando,penfw" },
+	{ /* end of table */ }
+};
+
+static struct platform_driver penfw_driver = {
+	.probe = penfw_probe,
+	.remove = penfw_remove,
+	.driver = {
+		.name = "penfw",
+		.owner = THIS_MODULE,
+		.of_match_table = penfw_of_match,
+	},
+};
+
+module_platform_driver(penfw_driver);
diff --git a/drivers/soc/pensando/penfw_smc.c b/drivers/soc/pensando/penfw_smc.c
new file mode 100644
index 00000000..a95abf4
--- /dev/null
+++ b/drivers/soc/pensando/penfw_smc.c
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2021, Pensando Systems Inc.
+ */
+
+#include <linux/string.h>
+#include <linux/arm-smccc.h>
+#include <linux/printk.h>
+#include <linux/types.h>
+
+#include "penfw.h"
+
+#define PENFW_CALL_FID			    0xC2000002
+
+static const char* _opcode_to_str(uint8_t opcode)
+{
+	 switch (opcode) {
+	case PENFW_OP_GET_API_VER:
+		return "PENFW_OP_GET_API_VER";
+	case PENFW_OP_GET_PENTRUST_STA:
+		return "PENFW_OP_GET_PENTRUST_STA";
+	case PENFW_OP_SET_PENTRUST_UPG:
+		return "PENFW_OP_SET_PENTRUST_UPG";
+	case PENFW_OP_GET_BL1_STA:
+		return "PENFW_OP_GET_BL1_STA";
+	case PENFW_OP_SET_BL1_UPG:
+		return "PENFW_OP_SET_BL1_UPG";
+	case PENFW_OP_GET_BL1_AR_NVCNTR:
+		return "PENFW_OP_GET_BL1_AR_NVCNTR";
+	case PENFW_OP_COMMIT_BL1_AR_NVCNTR:
+		return "PENFW_OP_COMMIT_BL1_AR_NVCNTR";
+	case PENFW_OP_GET_BL31_SW_VER:
+		return "PENFW_OP_GET_BL31_SW_VER";
+	case PENFW_OP_GET_BOOT_LCS:
+		return "PENFW_OP_GET_BOOT_LCS";
+	case PENFW_OP_GET_NEXT_LCS:
+		return "PENFW_OP_GET_NEXT_LCS";
+	case PENFW_OP_COMMIT_LCS_PROD:
+		return "PENFW_OP_COMMIT_LCS_PROD";
+	default:
+		return "PENFW_OP_UNKNOWN";
+	}
+}
+
+void penfw_smc(struct penfw_call_args *args)
+{
+	struct arm_smccc_res res = {0};
+
+	printk(KERN_DEBUG "penfw: smc call for fn: %s\n",
+		_opcode_to_str(args->a1));
+
+	arm_smccc_smc(PENFW_CALL_FID, args->a1, args->a2, args->a3, 0, 0,
+		      0, 0, &res);
+
+	// copy return vals
+	args->a0 = res.a0;
+	args->a1 = res.a1;
+	args->a2 = res.a2;
+	args->a3 = res.a3;
+
+	printk(KERN_DEBUG "penfw: smc return a0: 0x%llx a1: 0x%llx "\
+		"a2: 0x%llx a3: 0x%llx\n", args->a0, args->a1,
+					   args->a2, args->a3);
+}
diff --git a/drivers/soc/pensando/penfw_sysfs.c b/drivers/soc/pensando/penfw_sysfs.c
new file mode 100644
index 00000000..36091a2
--- /dev/null
+++ b/drivers/soc/pensando/penfw_sysfs.c
@@ -0,0 +1,421 @@
+/*
+ * Copyright (c) 2021, Pensando Systems Inc.
+ */
+
+#include <linux/kobject.h>
+#include <linux/sysfs.h>
+#include <linux/fs.h>
+#include <linux/types.h>
+#include <linux/device.h>
+#include <linux/device.h>
+#include <linux/types.h>
+#include <linux/string.h>
+
+#include "penfw_sysfs.h"
+#include "penfw.h"
+
+extern struct kobject *pensando_fw_kobj_get(void);
+
+static struct kobject *pensando_kobj;
+static struct kobject *penfw_kobject;
+static struct kobject *pentrust_kobject;
+static struct kobject *bl1_kobject;
+static struct kobject *bl31_kobject;
+static struct kobject *lifecycle_kobject;
+
+static ssize_t pentrust_show(struct kobject *kobj, struct kobj_attribute *attr,
+			     char *buf)
+{
+	struct penfw_call_args args = {0};
+
+	args.a1 = PENFW_OP_GET_PENTRUST_STA;
+	penfw_smc(&args);
+
+	if (args.a0 < 0) {
+		return sprintf(buf, "Error\n");
+	}
+
+	if (!strcmp(attr->attr.name, "version")) {
+		return sprintf(buf, "%llu\n", (args.a0 & 0xffffffff));
+	} else if (!strcmp(attr->attr.name, "upgrade")) {
+		return sprintf(buf, "%llu\n", (args.a1 >> 1) & 1);
+	} else if (!strcmp(attr->attr.name, "image_slot")) {
+		return sprintf(buf, "%llu\n", (args.a1 & 1));
+	} else {
+		return sprintf(buf, "\n");
+	}
+}
+
+static ssize_t pentrust_store(struct kobject *kobj, struct kobj_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct penfw_call_args args = {0};
+
+	if (strcmp(attr->attr.name, "upgrade") != 0) {
+		return -1;
+	}
+	args.a1 = PENFW_OP_SET_PENTRUST_UPG;
+	penfw_smc(&args);
+	if (args.a0 < 0) {
+		return -EIO;
+	}
+
+	return count;
+}
+
+static ssize_t bl1_show(struct kobject *kobj, struct kobj_attribute *attr,
+			char *buf)
+{
+	struct penfw_call_args args = {0};
+
+	args.a1 = PENFW_OP_GET_BL1_STA;
+	penfw_smc(&args);
+
+	if (args.a0 < 0) {
+		return sprintf(buf, "Error\n");
+	}
+
+	if (!strcmp(attr->attr.name, "version")) {
+		return sprintf(buf, "%llu\n", (args.a0 & 0xffffffff));
+	} else if (!strcmp(attr->attr.name, "ar_version")) {
+		return sprintf(buf, "%llu\n", ((args.a0 >> 32) & 0xff));
+	} else if (!strcmp(attr->attr.name, "upgrade")) {
+		return sprintf(buf, "%llu\n", (args.a1 >> 1) & 1);
+	} else if (!strcmp(attr->attr.name, "image_slot")) {
+		return sprintf(buf, "%llu\n", (args.a1 & 1));
+	} else {
+		return sprintf(buf, "\n");
+	}
+}
+
+static ssize_t bl1_ar_nvcntr_show(struct kobject *kobj,
+				  struct kobj_attribute *attr, char *buf)
+{
+	struct penfw_call_args args = {0};
+
+	args.a1 = PENFW_OP_GET_BL1_AR_NVCNTR;
+	penfw_smc(&args);
+
+	if (args.a0 < 0) {
+		return sprintf(buf, "Error\n");
+	}
+
+	if (!strcmp(attr->attr.name, "ar_nv_cntr")) {
+		return sprintf(buf, "%llu\n", (args.a0 & 0xffffffff));
+	} else {
+		return sprintf(buf, "\n");
+	}
+}
+
+static ssize_t bl1_store(struct kobject *kobj, struct kobj_attribute *attr,
+			 const char *buf, size_t count)
+{
+	struct penfw_call_args args = {0};
+
+	if (strcmp(attr->attr.name, "upgrade") != 0) {
+		return -1;
+	}
+	args.a1 = PENFW_OP_SET_BL1_UPG;
+	penfw_smc(&args);
+	if (args.a0 < 0) {
+		return -EIO;
+	}
+
+	return count;
+}
+
+static ssize_t bl31_show(struct kobject *kobj, struct kobj_attribute *attr,
+			 char *buf)
+{
+	struct penfw_call_args args = {0};
+	char vers[256];
+	uint64_t val;
+	int byte, shift;
+
+	args.a1 = PENFW_OP_GET_BL31_SW_VER;
+	penfw_smc(&args);
+
+	if (args.a0 < 0) {
+		return -EIO;
+	}
+
+	for (byte = 0; byte < 256 - 1; byte++) {
+		if ((byte / 8) == 0)
+			val = args.a0;
+		else if ((byte / 8) == 1)
+			val = args.a1;
+		else if ((byte / 8) == 2)
+			val = args.a2;
+		else
+			val = args.a3;
+
+		shift = (byte * 8) % 64;
+		vers[byte] = (val >> (shift)) & 0x7f;
+		if (vers[byte] == 0)
+			break;
+	}
+	vers[255] = 0;
+
+	return sprintf(buf, "%s\n", vers);
+}
+
+static const char *_lcs_to_str(int lcs_state)
+{
+	switch (lcs_state) {
+	case 0:
+		return "disabled";
+	case 1:
+		return "open";
+	case 2:
+		return "soft_prod";
+	case 3:
+		return "prod";
+	case 4:
+		return "rip";
+	default:
+		return "unknown";
+	}
+}
+
+static ssize_t boot_lcs_show(struct kobject *kobj, struct kobj_attribute *attr,
+			     char *buf)
+{
+	struct penfw_call_args args = {0};
+
+	args.a1 = PENFW_OP_GET_BOOT_LCS;
+	penfw_smc(&args);
+
+	if (args.a0 < 0) {
+		return sprintf(buf, "Error\n");
+	}
+
+	if (!strcmp(attr->attr.name, "boot_state")) {
+		return sprintf(buf, "%s\n", _lcs_to_str(args.a0));
+	} else {
+		return sprintf(buf, "\n");
+	}
+}
+
+static ssize_t next_lcs_show(struct kobject *kobj, struct kobj_attribute *attr,
+			     char *buf)
+{
+	struct penfw_call_args args = {0};
+
+	args.a1 = PENFW_OP_GET_NEXT_LCS;
+	penfw_smc(&args);
+
+	if (args.a0 < 0) {
+		return sprintf(buf, "Error\n");
+	}
+
+	if (!strcmp(attr->attr.name, "next_state")) {
+		return sprintf(buf, "%s\n", _lcs_to_str(args.a0));
+	} else {
+		return sprintf(buf, "\n");
+	}
+}
+
+// pentrust attributes
+static struct kobj_attribute pentrust_attr_ver = __ATTR(version, 0400,
+							pentrust_show, NULL);
+static struct kobj_attribute pentrust_attr_img_slot = __ATTR(image_slot, 0400,
+							     pentrust_show,
+							     NULL);
+static struct kobj_attribute pentrust_attr_upg = __ATTR(upgrade, 0600,
+							pentrust_show,
+							pentrust_store);
+
+static struct attribute *pentrust_attrs[] = {
+	&pentrust_attr_ver.attr,
+	&pentrust_attr_img_slot.attr,
+	&pentrust_attr_upg.attr,
+	NULL
+};
+
+static struct attribute_group pentrust_attr_group = {
+	.attrs = pentrust_attrs,
+};
+
+// bl1 attributes
+static struct kobj_attribute bl1_attr_ver = __ATTR(version, 0400, bl1_show,
+						   NULL);
+static struct kobj_attribute bl1_attr_ar_version = __ATTR(ar_version, 0400,
+							  bl1_show, NULL);
+static struct kobj_attribute bl1_attr_img_slot = __ATTR(image_slot, 0400,
+							bl1_show, NULL);
+static struct kobj_attribute bl1_attr_upg = __ATTR(upgrade, 0600, bl1_show,
+						   bl1_store);
+static struct kobj_attribute bl1_attr_ar_nv_cntr = __ATTR(ar_nv_cntr, 0400,
+							  bl1_ar_nvcntr_show,
+							  NULL);
+
+static struct attribute *bl1_attrs[] = {
+	&bl1_attr_ver.attr,
+	&bl1_attr_ar_version.attr,
+	&bl1_attr_img_slot.attr,
+	&bl1_attr_upg.attr,
+	&bl1_attr_ar_nv_cntr.attr,
+	NULL
+};
+
+static struct attribute_group bl1_attr_group = {
+	.attrs = bl1_attrs,
+};
+
+// bl31 attributes
+static struct kobj_attribute bl31_attr_sw_ver = __ATTR(sw_version, 0400,
+						       bl31_show, NULL);
+
+static struct attribute *bl31_attrs[] = {
+	&bl31_attr_sw_ver.attr,
+	NULL
+};
+
+static struct attribute_group bl31_attr_group = {
+	.attrs = bl31_attrs,
+};
+
+// lifecycle attributes
+static struct kobj_attribute lifecycle_attr_boot_state = __ATTR(boot_state,
+								0400,
+								boot_lcs_show,
+								NULL);
+static struct kobj_attribute lifecycle_attr_next_state = __ATTR(next_state,
+								0400,
+								next_lcs_show,
+								NULL);
+
+static struct attribute *lifecycle_attrs[] = {
+	&lifecycle_attr_boot_state.attr,
+	&lifecycle_attr_next_state.attr,
+	NULL
+};
+
+static struct attribute_group lifecycle_attr_group = {
+	.attrs = lifecycle_attrs,
+};
+
+
+int penfw_sysfs_init(struct device *penfwDevice)
+{
+	int ret = 0;
+
+	// /sys/firmware/pensando
+	pensando_kobj = pensando_fw_kobj_get();
+	if (!pensando_kobj) {
+		dev_err(penfwDevice, "Unable to create /sys/firmware/pensando"
+				     " node\n");
+		return -ENOMEM;
+	}
+
+	// /sys/firmware/pensando/penfw
+	penfw_kobject = kobject_create_and_add("penfw", pensando_kobj);
+	if (!penfw_kobject) {
+		dev_err(penfwDevice, "Unable to create "
+				     "/sys/firmware/pensando/penfw node\n");
+		ret = -ENOMEM;
+		goto penfw_err;
+	}
+
+	// /sys/firmware/pensando/penfw/pentrust
+	pentrust_kobject = kobject_create_and_add("pentrust", penfw_kobject);
+	if (!pentrust_kobject) {
+		dev_err(penfwDevice, "Unable to create "
+				     "/sys/firmware/pensando/penfw/pentrust "
+				     "node\n");
+		ret = -ENOMEM;
+		goto pentrust_err;
+	}
+
+	if (sysfs_create_group(pentrust_kobject, &pentrust_attr_group)) {
+		dev_err(penfwDevice, "Unable to create pentrust atrributes "
+				     "group\n");
+		ret = -1;
+		goto bl1_err;
+	}
+
+	// /sys/firmware/pensando/penfw/bl1
+	bl1_kobject = kobject_create_and_add("bl1", penfw_kobject);
+	if (!bl1_kobject) {
+		dev_err(penfwDevice, "Unable to create "
+				     "/sys/firmware/pensando/penfw/bl1 node\n");
+		ret = -ENOMEM;
+		goto bl1_err;
+	}
+
+	if (sysfs_create_group(bl1_kobject, &bl1_attr_group)) {
+		dev_err(penfwDevice, "Unable to create bl1 atrributes group\n");
+		ret = -1;
+		goto bl31_err;
+	}
+
+	// /sys/firmware/pensando/penfw/bl31
+	bl31_kobject = kobject_create_and_add("bl31", penfw_kobject);
+	if (!bl31_kobject) {
+		dev_err(penfwDevice, "Unable to create "
+				     "/sys/firmware/pensando/penfw/bl31 "
+				     "node\n");
+		ret = -ENOMEM;
+		goto bl31_err;
+	}
+
+	if (sysfs_create_group(bl31_kobject, &bl31_attr_group)) {
+		dev_err(penfwDevice, "Unable to create bl31 atrributes "
+				     "group\n");
+		ret = -1;
+		goto lifecycle_err;
+	}
+
+	// /sys/firmware/pensando/penfw/lifecycle
+	lifecycle_kobject = kobject_create_and_add("lifecycle", penfw_kobject);
+	if (!lifecycle_kobject) {
+		dev_err(penfwDevice, "Unable to create "
+				     "/sys/firmware/pensando/penfw/lifecycle "
+				     "node\n");
+		ret = -ENOMEM;
+		goto lifecycle_err;
+	}
+
+	if (sysfs_create_group(lifecycle_kobject, &lifecycle_attr_group)) {
+		dev_err(penfwDevice, "Unable to create lifecycle atrributes "
+				     "group\n");
+		ret = -1;
+		goto lifecycle_attr_err;
+	}
+
+return ret;
+
+lifecycle_attr_err:
+	kobject_put(lifecycle_kobject);
+lifecycle_err:
+	kobject_put(bl31_kobject);
+bl31_err:
+	kobject_put(bl1_kobject);
+bl1_err:
+	kobject_put(pentrust_kobject);
+pentrust_err:
+	kobject_put(penfw_kobject);
+penfw_err:
+	kobject_put(pensando_kobj);
+
+	return ret;
+}
+
+int penfw_sysfs_deinit(void)
+{
+	if (lifecycle_kobject)
+		kobject_put(lifecycle_kobject);
+	if (bl31_kobject)
+		kobject_put(bl31_kobject);
+	if (bl1_kobject)
+		kobject_put(bl1_kobject);
+	if (pentrust_kobject)
+		kobject_put(penfw_kobject);
+	if (penfw_kobject)
+		kobject_put(penfw_kobject);
+	if (pensando_kobj)
+		kobject_put(pensando_kobj);
+
+	return 0;
+}
+
diff --git a/drivers/soc/pensando/penfw_sysfs.h b/drivers/soc/pensando/penfw_sysfs.h
new file mode 100644
index 00000000..12ac779
--- /dev/null
+++ b/drivers/soc/pensando/penfw_sysfs.h
@@ -0,0 +1,11 @@
+/*
+* Copyright (c) 2021, Pensando Systems Inc.
+*/
+
+#ifndef __PENFW_SYSFS_H__
+#define __PENFW_SYSFS_H__
+
+int penfw_sysfs_init(struct device* penfwDevice);
+int penfw_sysfs_deinit(void);
+
+#endif /* __PENFW_SYSFS_H__ */
\ No newline at end of file
diff --git a/drivers/soc/pensando/penpcie_dev.h b/drivers/soc/pensando/penpcie_dev.h
new file mode 100644
index 00000000..5426d2e
--- /dev/null
+++ b/drivers/soc/pensando/penpcie_dev.h
@@ -0,0 +1,26 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020-2022, Pensando Systems Inc.
+ */
+
+#ifndef __PENPCIE_DEV_H__
+#define __PENPCIE_DEV_H__
+
+#define PENPCIE_NAME		"penpcie"
+#define PENPCIE_DEV		"/dev/penpcie"
+
+struct pcie_rw {
+	uint64_t pciepa;
+	size_t size;
+	union {
+		void *rdvalp;
+		uint64_t wrval;
+	};
+};
+
+#define PCIE_IOCTL_NUM		'P'
+#define PCIE_PCIEP_REGRD	_IOWR(PCIE_IOCTL_NUM, 1, struct pcie_rw)
+
+int pciep_regrd32(const uint64_t pciepa, uint32_t *val);
+
+#endif
diff --git a/drivers/soc/pensando/sbus.c b/drivers/soc/pensando/sbus.c
new file mode 100644
index 00000000..2940f8c
--- /dev/null
+++ b/drivers/soc/pensando/sbus.c
@@ -0,0 +1,303 @@
+/*
+ * Copyright (c) 2022, Pensando Systems Inc.
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kdev_t.h>
+#include <linux/fs.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/slab.h>
+#include <linux/uaccess.h>
+#include <linux/ioctl.h>
+#include <linux/io.h>
+#include <linux/spinlock.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_platform.h>
+#include <linux/delay.h>
+
+#define MAX_DEVICES			4
+#define SBUS_SBUS_RST			0x20
+#define SBUS_SBUS_WR			0x21
+#define SBUS_SBUS_RD			0x22
+#define SBUS_INDIR_DATA_ADDR_LSB	8
+#define SBUS_INDIR_DATA_COMMAND_LSB	16
+
+static dev_t sbus_dev = 0;
+static struct class *dev_class;
+static int dev_inst = 0;
+
+struct sbus_ioctl_args {
+	u32 sbus_rcvr_addr;
+	u32 sbus_data_addr;
+	u32 sbus_data;
+};
+
+struct sbusdev_info {
+	struct platform_device *pdev;
+	void __iomem *sbus_indir;
+	void __iomem *sbus_dhs;
+	spinlock_t sbus_lock;
+	struct cdev cdev;
+};
+
+#define SBUS_WRITE	_IOW('a', 'a', struct sbus_ioctl_args)
+#define SBUS_READ	_IOWR('a', 'b', struct sbus_ioctl_args)
+#define SBUS_RESET	_IOW('a', 'c', struct sbus_ioctl_args)
+
+static int sbus_drv_open(struct inode *inode, struct file *file)
+{
+	struct sbusdev_info *sbus_ring;	/* device information */
+
+	sbus_ring = container_of(inode->i_cdev, struct sbusdev_info, cdev);
+	file->private_data = sbus_ring;
+	pr_debug("Device File Opened...!!\n");
+	return 0;
+}
+
+static void sbus_write(struct sbus_ioctl_args param,
+				struct sbusdev_info *sbus_ring)
+{
+	uint32_t sbus_val;
+
+	sbus_val = param.sbus_rcvr_addr |
+		(param.sbus_data_addr << SBUS_INDIR_DATA_ADDR_LSB) |
+		(SBUS_SBUS_WR << SBUS_INDIR_DATA_COMMAND_LSB);
+
+	pr_debug("sbus_rcvr_addr %d sbus_data_addr %d sbus_data %d\n",
+	param.sbus_rcvr_addr, param.sbus_data_addr, param.sbus_data);
+
+	spin_lock(&sbus_ring->sbus_lock);
+
+	iowrite32(sbus_val, sbus_ring->sbus_indir);
+	iowrite32(param.sbus_data, sbus_ring->sbus_dhs);
+
+	spin_unlock(&sbus_ring->sbus_lock);
+}
+
+static uint32_t sbus_read(struct sbus_ioctl_args param,
+				struct sbusdev_info * sbus_ring)
+{
+	uint32_t sbus_val, val;
+
+	sbus_val = param.sbus_rcvr_addr |
+		(param.sbus_data_addr << SBUS_INDIR_DATA_ADDR_LSB) |
+		(SBUS_SBUS_RD << SBUS_INDIR_DATA_COMMAND_LSB);
+
+	pr_debug("sbus_rcvr_addr %d sbus_data_addr %d\n",
+		param.sbus_rcvr_addr, param.sbus_data_addr);
+
+	spin_lock(&sbus_ring->sbus_lock);
+
+	iowrite32(sbus_val, sbus_ring->sbus_indir);
+	val = ioread32(sbus_ring->sbus_dhs);
+
+	spin_unlock(&sbus_ring->sbus_lock);
+
+	return val;
+}
+
+static void sbus_reset(struct sbus_ioctl_args param,
+		struct sbusdev_info *sbus_ring)
+{
+	uint32_t sbus_val;
+
+	sbus_val = param.sbus_rcvr_addr |
+		(param.sbus_data_addr << SBUS_INDIR_DATA_ADDR_LSB) |
+		(SBUS_SBUS_RST << SBUS_INDIR_DATA_COMMAND_LSB);
+
+	pr_debug("sbus_rcvr_addr %d sbus_data_addr %d\n",
+		param.sbus_rcvr_addr, param.sbus_data_addr);
+
+	spin_lock(&sbus_ring->sbus_lock);
+
+	iowrite32(sbus_val, sbus_ring->sbus_indir);
+	iowrite32(0, sbus_ring->sbus_dhs);
+
+	spin_unlock(&sbus_ring->sbus_lock);
+}
+
+/*
+ * This function will be called when we write IOCTL on the Device file
+ */
+static long sbus_drv_ioctl(struct file *file, unsigned int cmd,
+			unsigned long arg)
+{
+	struct sbusdev_info *sbus_ring = file->private_data;
+	struct sbus_ioctl_args param_ioctl;
+
+	switch (cmd) {
+	case SBUS_WRITE:
+		if (copy_from_user
+			(&param_ioctl, (struct sbus_ioctl_args *)arg,
+			sizeof(struct sbus_ioctl_args))) {
+			return -EFAULT;
+		}
+		sbus_write(param_ioctl, sbus_ring);
+		break;
+	case SBUS_READ:
+		if (copy_from_user
+			(&param_ioctl, (struct sbus_ioctl_args *)arg,
+			sizeof(struct sbus_ioctl_args))) {
+			return -EFAULT;
+		}
+		param_ioctl.sbus_data = sbus_read(param_ioctl, sbus_ring);
+		if (copy_to_user
+			((struct sbus_ioctl_args *)arg, &param_ioctl,
+			sizeof(struct sbus_ioctl_args))) {
+			return -EFAULT;
+		}
+		break;
+	case SBUS_RESET:
+		if (copy_from_user
+			(&param_ioctl, (struct sbus_ioctl_args *)arg,
+			sizeof(struct sbus_ioctl_args))) {
+			return -EFAULT;
+		}
+		sbus_reset(param_ioctl, sbus_ring);
+		break;
+	default:
+		return -ENOTTY;
+		break;
+	}
+
+	return 0;
+}
+
+/*
+ * File operation structure
+ */
+static struct file_operations fops = {
+	.open = sbus_drv_open,
+	.owner = THIS_MODULE,
+	.unlocked_ioctl = sbus_drv_ioctl,
+};
+
+/*
+ * Module Init function
+ */
+static int sbus_probe(struct platform_device *pdev)
+{
+	int major, sbus_ring_num;
+	dev_t device;
+	struct device *dev = &pdev->dev;
+	struct resource *res;
+	struct sbusdev_info *sbus_ring;
+
+	if (dev_inst > MAX_DEVICES-1)
+		return -ENODEV;
+
+	if (of_property_read_u32(pdev->dev.of_node, "sbus-ring-num",
+				&sbus_ring_num)) {
+		pr_debug("missing sbus-ring-num in device tree\n");
+		return -EINVAL;
+	}
+
+	sbus_ring = devm_kzalloc(dev, sizeof(*sbus_ring), GFP_KERNEL);
+	if (!sbus_ring)
+		return -ENOMEM;
+
+	sbus_ring->pdev = pdev;
+	platform_set_drvdata(pdev, sbus_ring);
+
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	sbus_ring->sbus_indir = devm_ioremap_resource(dev, res);
+	if (IS_ERR(sbus_ring->sbus_indir)) {
+		dev_err(dev, "Cannot remap sbus reg addresses.\n");
+		return PTR_ERR(sbus_ring->sbus_indir);
+	}
+	sbus_ring->sbus_dhs = sbus_ring->sbus_indir + 0x4;
+
+	spin_lock_init(&sbus_ring->sbus_lock);
+
+	pr_debug("sbus_indir %p sbus_dhs %p\n",
+			sbus_ring->sbus_indir, sbus_ring->sbus_dhs);
+
+	if (dev_inst == 0) {
+		/* Allocating Major number & reserving minor numbers */
+		if ((alloc_chrdev_region
+			(&sbus_dev, 0, MAX_DEVICES, "pensbus_dev")) < 0) {
+			pr_err("Cannot allocate major number\n");
+			return -1;
+		}
+		pr_debug("Major = %d Minor = %d \n", MAJOR(sbus_dev),
+				MINOR(sbus_dev));
+
+		/* Creating struct class */
+		if ((dev_class =
+			class_create(THIS_MODULE, "sbus_class")) == NULL) {
+			pr_err("Cannot create the struct class\n");
+			goto r_class;
+		}
+	}
+
+	major = MAJOR(sbus_dev);
+
+	/* Creating cdev structure */
+	cdev_init(&sbus_ring->cdev, &fops);
+	sbus_ring->cdev.owner = THIS_MODULE;
+	sbus_ring->cdev.ops = &fops;
+
+	/* Adding character device to the system */
+	device = MKDEV(major, dev_inst);
+	if ((cdev_add(&sbus_ring->cdev, device, 1)) < 0) {
+		pr_err("Cannot add the device to the system\n");
+		goto r_device;
+	}
+
+	/* Creating device */
+	if ((device_create(dev_class, NULL, device, NULL, "sbus%d",
+					sbus_ring_num)) == NULL) {
+		pr_err("Cannot create the Device 1\n");
+		goto r_device;
+	}
+	dev_inst++;
+
+	return 0;
+
+r_device:
+	if (dev_inst == 0)
+		class_destroy(dev_class);
+r_class:
+	if (dev_inst == 0)
+		unregister_chrdev_region(sbus_dev, MAX_DEVICES);
+
+	return -1;
+}
+
+/*
+ * Module exit function
+ */
+static int sbus_remove(struct platform_device *pdev)
+{
+	dev_inst--;
+
+	if (dev_inst == 0) {
+		device_destroy(dev_class, sbus_dev);
+		class_destroy(dev_class);
+		unregister_chrdev_region(sbus_dev, MAX_DEVICES);
+		pr_debug("Device Driver Remove...Done!!!\n");
+	}
+
+	return 0;
+}
+
+static const struct of_device_id sbus_of_match[] = {
+	{ .compatible = "pensando,sbus" },
+	{ /* end of table */ }
+};
+
+static struct platform_driver sbus_driver = {
+	.probe = sbus_probe,
+	.remove = sbus_remove,
+	.driver = {
+		.name = "pensando-sbus",
+		.owner = THIS_MODULE,
+		.of_match_table = sbus_of_match,
+	},
+};
+
+module_platform_driver(sbus_driver);
diff --git a/drivers/spi/spi-cadence-quadspi.c b/drivers/spi/spi-cadence-quadspi.c
index 2e1255b..30974cc 100644
--- a/drivers/spi/spi-cadence-quadspi.c
+++ b/drivers/spi/spi-cadence-quadspi.c
@@ -35,6 +35,7 @@
 /* Quirks */
 #define CQSPI_NEEDS_WR_DELAY		BIT(0)
 #define CQSPI_DISABLE_DAC_MODE		BIT(1)
+#define CQSPI_NEEDS_APB_AHB_HAZARD_WAR	BIT(2)
 
 /* Capabilities */
 #define CQSPI_SUPPORTS_OCTAL		BIT(0)
@@ -73,6 +74,7 @@ struct cqspi_st {
 	int			current_cs;
 	unsigned long		master_ref_clk_hz;
 	bool			is_decoded_cs;
+	bool			apb_ahb_hazard;
 	u32			fifo_depth;
 	u32			fifo_width;
 	bool			rclk_en;
@@ -621,6 +623,13 @@ static int cqspi_indirect_write_execute(struct cqspi_flash_pdata *f_pdata,
 	if (cqspi->wr_delay)
 		ndelay(cqspi->wr_delay);
 
+	/*
+	 * If a hazard exists between the APB and AHB interfaces, perform a
+	 * dummy readback from the controller to ensure synchronization.
+	 */
+	if (cqspi->apb_ahb_hazard)
+		(void)readl(reg_base + CQSPI_REG_INDIRECTWR);
+
 	while (remaining > 0) {
 		size_t write_words, mod_bytes;
 
@@ -1285,6 +1294,8 @@ static int cqspi_probe(struct platform_device *pdev)
 		if (ddata->quirks & CQSPI_NEEDS_WR_DELAY)
 			cqspi->wr_delay = 5 * DIV_ROUND_UP(NSEC_PER_SEC,
 						cqspi->master_ref_clk_hz);
+		if (ddata->quirks & CQSPI_NEEDS_APB_AHB_HAZARD_WAR)
+			cqspi->apb_ahb_hazard = true;
 		if (ddata->hwcaps_mask & CQSPI_SUPPORTS_OCTAL)
 			master->mode_bits |= SPI_RX_OCTAL;
 		if (!(ddata->quirks & CQSPI_DISABLE_DAC_MODE))
@@ -1391,6 +1402,10 @@ static int cqspi_resume(struct device *dev)
 	.quirks = CQSPI_NEEDS_WR_DELAY,
 };
 
+static const struct cqspi_driver_platdata pen_cdns_qspi = {
+	.quirks = CQSPI_NEEDS_APB_AHB_HAZARD_WAR | CQSPI_DISABLE_DAC_MODE,
+};
+
 static const struct of_device_id cqspi_dt_ids[] = {
 	{
 		.compatible = "cdns,qspi-nor",
@@ -1404,6 +1419,10 @@ static int cqspi_resume(struct device *dev)
 		.compatible = "ti,am654-ospi",
 		.data = &am654_ospi,
 	},
+	{
+		.compatible = "pensando,elba-qspi",
+		.data = &pen_cdns_qspi,
+	},
 	{ /* end of table */ }
 };
 
diff --git a/drivers/spi/spi-dw-mmio.c b/drivers/spi/spi-dw-mmio.c
index d0cc5bf..ae3d460 100644
--- a/drivers/spi/spi-dw-mmio.c
+++ b/drivers/spi/spi-dw-mmio.c
@@ -16,6 +16,7 @@
 #include <linux/module.h>
 #include <linux/of.h>
 #include <linux/of_platform.h>
+#include <linux/gpio.h>
 #include <linux/acpi.h>
 #include <linux/property.h>
 #include <linux/regmap.h>
@@ -53,10 +54,28 @@ struct dw_spi_mscc {
 	void __iomem        *spi_mst; /* Not sparx5 */
 };
 
+struct dw_spi_elba {
+	struct regmap *regmap;
+	unsigned int reg;
+	unsigned int ctl;
+};
+
+/*
+ * ctl:              1               |               0
+ * cs:       1               0       |       1               0
+ * bit:  7-------6-------5-------4---|---3-------2-------1-------0
+ *      cs1   cs1_ovr   cs0   cs0_ovr|  cs1   cs1_ovr   cs0   cs0_ovr
+ *                  ssi1             |            ssi0
+ */
+#define ELBA_SPICS_SHIFT(ctl, cs)	(4 * (ctl) + 2 * (cs))
+#define ELBA_SPICS_MASK(ctl, cs)	(0x3 << ELBA_SPICS_SHIFT(ctl, cs))
+#define ELBA_SPICS_SET(ctl, cs, val)	\
+			((((val) << 1) | 0x1) << ELBA_SPICS_SHIFT(ctl, cs))
+
 /*
  * The Designware SPI controller (referred to as master in the documentation)
  * automatically deasserts chip select when the tx fifo is empty. The chip
- * selects then needs to be either driven as GPIOs or, for the first 4 using the
+ * selects then needs to be either driven as GPIOs or, for the first 4 using
  * the SPI boot controller registers. the final chip select is an OR gate
  * between the Designware SPI controller and the SPI boot controller.
  */
@@ -222,6 +241,74 @@ static int dw_spi_keembay_init(struct platform_device *pdev,
 	return 0;
 }
 
+static void elba_spics_set_cs(struct dw_spi_elba *dwselba, int cs, int enable)
+{
+	regmap_update_bits(dwselba->regmap, dwselba->reg,
+		ELBA_SPICS_MASK(dwselba->ctl, cs),
+		ELBA_SPICS_SET(dwselba->ctl, cs, enable));
+}
+
+static void dw_spi_elba_set_cs(struct spi_device *spi, bool enable)
+{
+	struct dw_spi *dws = spi_master_get_devdata(spi->master);
+	struct dw_spi_mmio *dwsmmio = container_of(dws, struct dw_spi_mmio, dws);
+	struct dw_spi_elba *dwselba = dwsmmio->priv;
+	u8 cs = spi->chip_select;
+
+	if (cs < 2) {
+		/* overridden native chip-select */
+		elba_spics_set_cs(dwselba, spi->chip_select, enable);
+	}
+
+	/*
+	 * The DW SPI controller needs a native CS bit selected to start
+	 * the serial engine, and we have fewer native CSs than we need, so
+	 * use CS0 always.
+	 */
+	spi->chip_select = 0;
+	dw_spi_set_cs(spi, enable);
+	spi->chip_select = cs;
+}
+
+static int dw_spi_elba_init(struct platform_device *pdev,
+			    struct dw_spi_mmio *dwsmmio)
+{
+	struct of_phandle_args args;
+	struct dw_spi_elba *dwselba;
+	struct regmap *regmap;
+	int rc;
+
+	rc = of_parse_phandle_with_fixed_args(pdev->dev.of_node,
+					      "pensando,spics", 2, 0, &args);
+	if (rc) {
+		dev_err(&pdev->dev, "could not find pensando,spics\n");
+		return rc;
+	}
+
+	regmap = syscon_node_to_regmap(args.np);
+	if (IS_ERR(regmap)) {
+		dev_err(&pdev->dev, "could not map pensando,spics\n");
+		return PTR_ERR(regmap);
+	}
+
+	dwselba = devm_kzalloc(&pdev->dev, sizeof(*dwselba), GFP_KERNEL);
+	if (!dwselba)
+		return -ENOMEM;
+
+	dwselba->regmap = regmap;
+	dwselba->reg = args.args[0];
+	dwselba->ctl = args.args[1];
+
+	/* deassert cs */
+	elba_spics_set_cs(dwselba, 0, 1);
+	elba_spics_set_cs(dwselba, 1, 1);
+
+	dwsmmio->priv = dwselba;
+	dwsmmio->dws.set_cs = dw_spi_elba_set_cs;
+
+	return 0;
+}
+
 static int dw_spi_mmio_probe(struct platform_device *pdev)
 {
 	int (*init_func)(struct platform_device *pdev,
@@ -335,6 +422,7 @@ static int dw_spi_mmio_remove(struct platform_device *pdev)
 	{ .compatible = "snps,dwc-ssi-1.01a", .data = dw_spi_dwc_ssi_init},
 	{ .compatible = "intel,keembay-ssi", .data = dw_spi_keembay_init},
 	{ .compatible = "microchip,sparx5-spi", dw_spi_mscc_sparx5_init},
+	{ .compatible = "pensando,elba-spi", .data = dw_spi_elba_init },
 	{ /* end of table */}
 };
 MODULE_DEVICE_TABLE(of, dw_spi_mmio_of_match);
diff --git a/drivers/spi/spidev.c b/drivers/spi/spidev.c
index 859910e..6d36402 100644
--- a/drivers/spi/spidev.c
+++ b/drivers/spi/spidev.c
@@ -682,6 +682,7 @@ static int spidev_release(struct inode *inode, struct file *filp)
 	{ .compatible = "lwn,bk4" },
 	{ .compatible = "dh,dhcom-board" },
 	{ .compatible = "menlo,m53cpld" },
+	{ .compatible = "pensando,cpld" },
 	{},
 };
 MODULE_DEVICE_TABLE(of, spidev_dt_ids);
diff --git a/drivers/uio/Kconfig b/drivers/uio/Kconfig
index 202ee81..0d30dee 100644
--- a/drivers/uio/Kconfig
+++ b/drivers/uio/Kconfig
@@ -125,6 +125,50 @@ config UIO_FSL_ELBC_GPCM_NETX5152
 	  Information about this hardware can be found at:
 	  http://www.hilscher.com/netx
 
+config UIO_PCIEMAC
+	tristate "Include PCI MAC status driver"
+	default "y"
+	select UIO_PENGIC
+	depends on ARCH_PENSANDO_CAPRI_SOC || ARCH_PENSANDO_ELBA_SOC || ARCH_PENSANDO_GIGLIO_SOC
+	help
+	  Driver that allows handling of ring2 on Pensando Capri systems. It
+	  is useful for having a userspace driver that can handle GIC 17
+	  interrupts.
+
+	  If you compile this as a module, it will be called uio_pciemac.
+
+config UIO_LINKMAC
+	tristate "Include Pensando Capri uplink MAC status driver"
+	default "y"
+	select UIO_PENGIC
+	depends on ARCH_PENSANDO_CAPRI_SOC || ARCH_PENSANDO_ELBA_SOC || ARCH_PENSANDO_GIGLIO_SOC
+	help
+	  Driver that allows monitoring of the Ethernet uplink MAC hardware so
+	  that userspace can decode ASIC status changes.
+
+	  If you compile this as a module, it will be called uio_linkmac0.
+
+config UIO_PENMSI1
+	tristate "Driver 1 for MSI"
+	default "y"
+	select UIO_PENMSI
+	depends on ARCH_PENSANDO_CAPRI_SOC || ARCH_PENSANDO_ELBA_SOC || ARCH_PENSANDO_GIGLIO_SOC
+	help
+	  Driver that allows obtaining MSI data and handling MSI interrupts
+	  in userspace.
+
+	  If you compile this as a module, it will be called uio_pengmsi1.
+
+config UIO_PENGIC
+	tristate
+	depends on ARCH_PENSANDO
+	default n
+
+config UIO_PENMSI
+	tristate
+	depends on ARCH_PENSANDO
+	default n
+
 config UIO_PRUSS
 	tristate "Texas Instruments PRUSS driver"
 	select GENERIC_ALLOCATOR
diff --git a/drivers/uio/Makefile b/drivers/uio/Makefile
index c285dd2..ae8ff40 100644
--- a/drivers/uio/Makefile
+++ b/drivers/uio/Makefile
@@ -10,4 +10,9 @@ obj-$(CONFIG_UIO_NETX)	+= uio_netx.o
 obj-$(CONFIG_UIO_PRUSS)         += uio_pruss.o
 obj-$(CONFIG_UIO_MF624)         += uio_mf624.o
 obj-$(CONFIG_UIO_FSL_ELBC_GPCM)	+= uio_fsl_elbc_gpcm.o
+obj-$(CONFIG_UIO_PENGIC)	+= uio_pengic.o
+obj-$(CONFIG_UIO_PCIEMAC)	+= uio_pciemac.o
+obj-$(CONFIG_UIO_LINKMAC)	+= uio_linkmac.o
+obj-$(CONFIG_UIO_PENMSI)	+= uio_penmsi.o
+obj-$(CONFIG_UIO_PENMSI1)	+= uio_penmsi1.o
 obj-$(CONFIG_UIO_HV_GENERIC)	+= uio_hv_generic.o
diff --git a/drivers/uio/uio_linkmac.c b/drivers/uio/uio_linkmac.c
new file mode 100644
index 00000000..440daa8
--- /dev/null
+++ b/drivers/uio/uio_linkmac.c
@@ -0,0 +1,30 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/module.h>
+
+#include "uio_pengic.h"
+
+#define DRIVER_NAME_LINKMAC	"linkmac"
+
+#ifdef CONFIG_OF
+static const struct of_device_id pengic_match[] = {
+	{ .compatible = "pensando,uio_linkmac" },
+	{ /* Mark the end of the list */ },
+};
+#endif
+
+static struct platform_driver uio_linkmac = {
+	.probe = pengic_probe_enable,
+	.remove = pengic_remove,
+	.driver = {
+		.name = DRIVER_NAME_LINKMAC,
+		.pm = &pengic_pm_ops,
+		.of_match_table = of_match_ptr(pengic_match),
+	}
+};
+
+module_platform_driver(uio_linkmac);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Support Link MAC status reporting");
+MODULE_AUTHOR("David VomLehn");
diff --git a/drivers/uio/uio_pciemac.c b/drivers/uio/uio_pciemac.c
new file mode 100644
index 00000000..b7d89c6
--- /dev/null
+++ b/drivers/uio/uio_pciemac.c
@@ -0,0 +1,30 @@
+// SPDX-License-Identifier: GPL-2.0
+
+#include <linux/module.h>
+
+#include "uio_pengic.h"
+
+#define DRIVER_NAME_PCIEMAC	"uio_pciemac0"
+
+#ifdef CONFIG_OF
+static const struct of_device_id pengic_match[] = {
+	{ .compatible = "pensando,uio_pciemac" },
+	{ /* Mark the end of the list */ },
+};
+#endif
+
+static struct platform_driver uio_pciemac = {
+	.probe = pengic_probe_enable,
+	.remove = pengic_remove,
+	.driver = {
+		.name = DRIVER_NAME_PCIEMAC,
+		.pm = &pengic_pm_ops,
+		.of_match_table = of_match_ptr(pengic_match),
+	}
+};
+
+module_platform_driver(uio_pciemac);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Support PCIe MAC status reporting");
+MODULE_AUTHOR("David VomLehn");
diff --git a/drivers/uio/uio_pengic.c b/drivers/uio/uio_pengic.c
new file mode 100644
index 00000000..352cfea
--- /dev/null
+++ b/drivers/uio/uio_pengic.c
@@ -0,0 +1,664 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020-2021, Pensando Systems Inc.
+ *
+ * UIO driver for the device using the GIC interrupts for the Pensando
+ * Capri and Elba ASIC. This includes status/error registers.
+ *
+ * To do:
+ * o	Get enable_csr from the "reg" property
+ * o	Get enable_mask from the device nodes "interrupts" property
+ *
+ */
+
+#include <linux/dma-mapping.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_irq.h>
+#include <linux/platform_data/uio_dmem_genirq.h>
+#include <linux/platform_device.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/spinlock.h>
+#include <linux/uio_driver.h>
+#include <linux/atomic.h>
+#include <linux/irqchip/irq-pensando.h>
+
+/* Probably should be defined in irq.h, but isn't */
+#define NO_IRQ		0
+
+#define MAP_ERROR	(~0)		/* Invalid address */
+
+/*
+ * If set, will print a status message from the IRQ handler. This can be
+ * very helpful when trying to determine whether the device tree has the
+ * correct parent/child structure
+ */
+#undef PRINT_HANDLER_STATUS
+
+#ifdef PRINT_HANDLER_STATUS
+#define handler_status(fmt, ...) pr_err(fmt, ##__VA_ARGS__)
+#else
+#define handler_status(fmt, ...) do { } while (false)
+#endif
+
+/*
+ * pengic_platdata - platform data for one UIO device
+ * @name:		Name of the driver
+ * @reg_type:		Type of register block we're dealing with
+ * @flags:
+ * @pdev:		Pointer to struct platform_device
+ * @n_res:		Number of entries in @res[] used
+ * @res:		Struct resource that defines the address and size of
+ *			the CSR
+ * @node:		Pointer to the open firmware device node for this
+ *			device;
+ * @enable_mask:	Mask of bits to be set to enable the interrupt(s)
+ * @enable_csr:		Virtual address of the pen_ictlr_csr for this child
+ * @uio_info:		Pointer to the associated struct uio_info
+ * @dev:		Pointer to the struct device for this device
+ * @cmd:		Information for the command file
+ * @pengic_dir:		Pointer to information about the pengic directory
+ *			in which the command file lives
+ * @irq:		Kernel interrupt number
+ * @disables_lock:	Spin lock protecting the @disables member
+ * @disable:		Number of outstanding disables. Incremented for
+ *			each disable call, decremented for each enable call
+ */
+struct pengic_platdata {
+	const char		*name;
+	enum reg_type		reg_type;
+	unsigned long		flags;
+	unsigned int		n_res;
+	struct resource		res[MAX_UIO_MAPS];
+	struct device_node	*node;
+	u32			enable_mask;
+	struct pen_ictlr_csr	*enable_csr;
+	struct uio_info		*uio_info;
+	struct device		*dev;
+	unsigned int		irq;
+};
+
+static void pengic_enable_intr_nolock(struct pengic_platdata *platdata)
+{
+	struct irq_desc *desc;
+	struct irq_data *irq_data;
+
+	desc = irq_to_desc(platdata->irq);
+	irq_data = &desc->irq_data;
+
+	switch (platdata->reg_type) {
+	case REG_TYPE_CSR:
+		pen_irq_unmask_enable_csr_one(irq_data);
+		break;
+
+	case REG_TYPE_GRP:
+		pen_irq_unmask_enable_grp_one(irq_data);
+		break;
+
+	case REG_TYPE_CSRINTR:
+		pen_irq_unmask_enable_csrintr_one(irq_data);
+		break;
+
+	default:
+		pr_err("%pOF: Unknown register type: %d\n",
+			platdata->node, platdata->reg_type);
+		break;
+	}
+
+}
+
+/*
+ * Enable the register in the bottom-most interrupt domain controller. We
+ * only call the real enable function when we have zero outstanding
+ * disables.
+ *
+ * It's ugly that this calls directly into functions for the interrupt
+ * domain controller but it's either that or duplicate code.
+ */
+static void pengic_enable_intr(struct pengic_platdata *platdata)
+{
+	pengic_enable_intr_nolock(platdata);
+}
+
+static void pengic_disable_intr_nolock(struct pengic_platdata *platdata)
+{
+	struct irq_desc *desc;
+	struct irq_data *irq_data;
+
+	desc = irq_to_desc(platdata->irq);
+	irq_data = &desc->irq_data;
+
+	/*
+	 * If this is the first disable call, actually do the disable.
+	 * Otherwise, we are already disabled and skip the call
+	 */
+	switch (platdata->reg_type) {
+	case REG_TYPE_CSR:
+		pen_irq_mask_disable_csr_one(irq_data);
+		break;
+
+	case REG_TYPE_GRP:
+		pen_irq_mask_disable_grp_one(irq_data);
+		break;
+
+	case REG_TYPE_CSRINTR:
+		pen_irq_mask_disable_csrintr_one(irq_data);
+		break;
+
+	default:
+		pr_err("Unknown register type: %d\n",
+			platdata->reg_type);
+		break;
+	}
+}
+
+static void pengic_disable_intr(struct pengic_platdata *platdata)
+{
+	pengic_disable_intr_nolock(platdata);
+}
+
+static int pengic_open(struct uio_info *uioinfo, struct inode *inode)
+{
+	struct pengic_platdata *platdata;
+	int ret;
+
+	ret = 0;
+	platdata = uioinfo->priv;
+	pm_runtime_get_sync(platdata->dev);
+
+	return ret;
+}
+
+/*
+ * pengic_release - called when the device has no more open file descriptors
+ *	and it was enough to use end-of-interrupt handling
+ */
+static int pengic_release(struct uio_info *uioinfo, struct inode *inode)
+{
+	struct pengic_platdata *platdata;
+
+	platdata = uioinfo->priv;
+	pm_runtime_put_sync(platdata->dev);
+
+	return 0;
+}
+
+/*
+ * pengic_release_enable - called when the device has no more open file
+ *	descriptors when the interrupt had to be disabled in addition to
+ *	performing end-of-interrupt processing. This ensures that the
+ *	interrupt is enabled on exit.
+ */
+static int pengic_release_enable(struct uio_info *uioinfo, struct inode *inode)
+{
+	struct pengic_platdata *platdata;
+	int rc;
+
+	platdata = uioinfo->priv;
+
+#ifdef FORCE_ENABLE_ON_RELEASE
+	/*
+	 * If the interrupt chain is disabled, enable it
+	 *
+	 * No need to lock here, there is nobody else contending for this
+	 * data structure
+	 */
+	if (platdata->disables != 0)
+		pengic_enable_intr_nolock(platdata);
+#endif
+	rc = pengic_release(uioinfo, inode);
+
+	return rc;
+}
+
+/*
+ * Read the register where bits are set when interrupts happen. Note that
+ * an undefined reg_type will cause a zero to be returned, which will
+ * cause an IRQ_NONE to be returned to the caller of the IRQ handler.
+ */
+static uint32_t pengic_read_status(enum reg_type reg_type, void *p)
+{
+	uint32_t intr_status;
+
+	switch (reg_type) {
+	case REG_TYPE_CSR:
+		intr_status = readl(&((struct pen_ictlr_csr *)p)->intreg);
+		break;
+
+	case REG_TYPE_GRP:
+		intr_status = readl(&((struct pen_ictlr_grp *)p)->intreg);
+		break;
+
+	case REG_TYPE_CSRINTR:
+		intr_status = readl(&((struct pen_ictlr_csrintr *)p)->intr);
+		break;
+
+	default:
+		intr_status = 0;	/* Always causes IRQ_NONE */
+		break;
+	}
+
+	return intr_status;
+}
+
+/*
+ * Handle an IRQ assuming the default EOI processing is sufficient to
+ * renable the interrupt.
+ */
+static irqreturn_t pengic_handler(int virq, struct uio_info *uioinfo)
+{
+	struct pengic_platdata *platdata;
+	struct irq_desc *irq_desc;
+	u32 intr_status, enable_mask;
+	irq_hw_number_t hwirq;
+	unsigned int i;
+
+	platdata = uioinfo->priv;
+	irq_desc = irq_to_desc(virq);
+	hwirq = irq_desc->irq_data.hwirq;
+	enable_mask = 1 << hwirq;
+
+	for (i = 0; i < platdata->n_res; i++) {
+		void *p;
+
+		p = uioinfo->mem[i].internal_addr + uioinfo->mem[i].offs;
+		intr_status = pengic_read_status(platdata->reg_type, p);
+		if ((intr_status & enable_mask) != 0)
+			return IRQ_HANDLED;	/* This is our interrupt */
+	}
+
+	return IRQ_NONE;
+}
+
+/*
+ * Handle an IRQ assuming the default EOI processing is insufficient to
+ * renable the interrupt. Instead, the interrupt is disabled here and enabled
+ * through the irqcontrol function invoked from userspace via write().
+ */
+static irqreturn_t pengic_handler_disable(int virq, struct uio_info *uioinfo)
+{
+	irqreturn_t rc;
+
+	rc = pengic_handler(virq, uioinfo);
+	if (rc == IRQ_HANDLED) {
+		struct pengic_platdata *platdata;
+
+		platdata = uioinfo->priv;
+		pengic_disable_intr(platdata);
+	}
+
+	return rc;
+}
+
+/* Unmap the first n elements */
+static void unmap_asic(struct uio_info *uioinfo, unsigned int n,
+		       struct device *dev)
+{
+	unsigned int i;
+
+	for (i = 0; uioinfo->mem[i].size != 0; i++) {
+		struct uio_mem *mem;
+
+		mem = &uioinfo->mem[i];
+
+		if (mem->internal_addr == NULL) {
+			dev_warn(dev,
+				"mem[%td].internal_addr is unexpectdly NULL\n",
+				mem - uioinfo->mem);
+		} else {
+			iounmap(mem->internal_addr);
+			mem->internal_addr = NULL;	/* paranoia */
+		}
+
+		if (mem->name == NULL) {
+			dev_warn(dev, "mem[%td].name is unexpectdly NULL\n",
+				mem - uioinfo->mem);
+		} else {
+			kfree(mem->name);
+			mem->name = NULL;		/* More paranoia */
+		}
+	}
+}
+
+/*
+ * Returns the number of resources on success, otherwise a negative errno
+ * value
+ */
+static int map_asic(struct uio_info *uio_info, struct device *dev,
+	struct device_node *node, struct resource *res, unsigned int n_res)
+{
+	unsigned int i;
+	int ret;
+
+	for (i = 0; i < n_res; i++) {
+		struct uio_mem *mem;
+		size_t unrounded_size;
+		size_t rounded_size;
+
+		ret = of_address_to_resource(node, i, &res[i]);
+		if (ret != 0)
+			break;
+
+		mem = &uio_info->mem[i];
+
+		/* Offset with the page in which the device registers reside */
+		mem->offs = res[i].start & ~PAGE_MASK;
+		/* Physical address, aligned on a page boundary */
+		mem->addr = res[i].start - mem->offs;
+		if (node->name != NULL)
+			mem->name = kstrdup(node->name, GFP_KERNEL);
+
+		/*
+		 * Size of an area completely containing the device registers
+		 * of interest. Must be multiple of the page size
+		 */
+		unrounded_size = mem->offs + resource_size(res);
+		rounded_size = (unrounded_size + (PAGE_SIZE - 1)) & PAGE_MASK;
+		mem->size = rounded_size;
+
+		/* Specify we have physical memory, then map it */
+		mem->memtype = UIO_MEM_PHYS;
+		mem->internal_addr = ioremap(mem->addr, mem->size);
+
+		if (mem->internal_addr == NULL)
+			break;
+	}
+
+	return i;
+}
+
+static int pengic_irqcontrol(struct uio_info *info, s32 irq_on)
+{
+	struct pengic_platdata *platdata;
+
+	platdata = info->priv;
+
+	switch (irq_on) {
+	case 0:
+		pengic_disable_intr(platdata);
+		break;
+
+	case 1:
+		pengic_enable_intr(platdata);
+		break;
+
+	default:
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+static int set_uio_info(struct uio_info *uio_info,
+	struct device *dev, struct device_node *node,
+	irqreturn_t (*pengic_handler)(int irq, struct uio_info *uioinfo))
+{
+	const char *dt_name;
+	int irq;
+	int ret;
+
+	ret = of_property_read_string(node, "name", &dt_name);
+	if (ret != 0)
+		dt_name = "pengic";
+	uio_info->name = kstrdup(dt_name, GFP_KERNEL);
+	if (uio_info->name == NULL)
+		return -ENOMEM;
+	uio_info->version = "0.0.1";
+
+	irq = irq_of_parse_and_map(node, 0);
+	if (irq == 0) {
+		dev_warn(dev, "no interrupt found for %pOF\n", node);
+		uio_info->irq = UIO_IRQ_NONE;
+		return -ENXIO;
+	}
+
+	uio_info->irq = irq;
+	uio_info->irq_flags = IRQF_SHARED;
+	uio_info->handler = pengic_handler;
+	uio_info->irqcontrol = pengic_irqcontrol;
+
+	return 0;
+}
+
+static void free_uio_info(struct uio_info *uio_info, unsigned int n_res,
+			  struct device *dev)
+{
+	if (uio_info->name != NULL) {
+		kfree(uio_info->name);
+		uio_info->name = NULL;
+	}
+
+	uio_info->handler = NULL;
+	uio_info->irqcontrol = NULL;
+	unmap_asic(uio_info, n_res, dev);
+}
+
+static void free_platdata(struct pengic_platdata *platdata)
+{
+	kfree(platdata);
+}
+
+static enum reg_type get_reg_type(struct device_node *node)
+{
+	const char *reg_type_name;
+	int rc;
+
+	rc = of_property_read_string(node, "register-type", &reg_type_name);
+	if (rc != 0)
+		return REG_TYPE_UNKNOWN;
+	if (strcmp(reg_type_name, "csr") == 0)
+		return REG_TYPE_CSR;
+	if (strcmp(reg_type_name, "group") == 0)
+		return REG_TYPE_GRP;
+	if (strcmp(reg_type_name, "csr-interrupt") == 0)
+		return REG_TYPE_CSRINTR;
+
+	pr_warn("Unknown register type: %s\n", reg_type_name);
+	return REG_TYPE_UNKNOWN;
+}
+
+static int set_platdata(struct pengic_platdata *platdata,
+	const struct uio_info *uioinfo, struct platform_device *pdev)
+{
+	struct device_node *node;
+	int ret;
+	u32 fw_param;
+
+	/* Initialize the platform data */
+
+	platdata->node = pdev->dev.of_node;
+	platdata->dev = &pdev->dev;
+	platdata->name = uioinfo->name;
+
+	platdata->irq = uioinfo->irq;
+	node = platdata->node;
+
+	platdata->reg_type = get_reg_type(platdata->node);
+
+	ret = map_asic(platdata->uio_info, platdata->dev, node,
+		platdata->res, ARRAY_SIZE(platdata->res));
+	if (ret < 0) {
+		dev_err(platdata->dev, "can't map ASIC registers\n");
+		return ret;
+	}
+
+	platdata->n_res = ret;
+
+	/*
+	 * Get the interrupt number. This must be the first of a three
+	 * element irq_fwspec. Can check "#interrupt-cells" if necessary.
+	 */
+	ret = of_property_read_u32_index(platdata->node, "interrupts", 2,
+		&fw_param);
+	if (ret != 0)
+		return ret;
+	platdata->enable_mask = 1 << fw_param;
+
+	return 0;
+}
+
+/*
+ * pengic_probe - allocate and initialize state for device
+ * @pdev:	Pointer to the platform device
+ * @handler_fn:	Pointer to the IRQ handler
+ * @release_fn:	Pointer to the release function (called when the last file
+ *		descriptor is closed)
+ */
+static int pengic_probe_common(struct platform_device *pdev,
+	irqreturn_t (*handler_fn)(int irq, struct uio_info *uioinfo),
+	int (*release_fn)(struct uio_info *uioinfo, struct inode *inode))
+{
+	struct device_node *node;
+	struct pengic_platdata *platdata;
+	struct uio_info *uio_info;
+	unsigned int i;
+	int ret;
+
+	ret = -EINVAL;
+	node = pdev->dev.of_node;
+
+	/* Allocate space for the platform-specific data */
+	platdata = kzalloc(sizeof(*platdata), GFP_KERNEL);
+	if (platdata == NULL)
+		return -ENOMEM;
+
+	uio_info = kzalloc(sizeof(*uio_info), GFP_KERNEL);
+	if (uio_info == NULL) {
+		kfree(platdata);
+		return -ENOMEM;
+	}
+
+	uio_info->priv = platdata;
+	platdata->uio_info = uio_info;
+
+	ret = set_uio_info(uio_info, &pdev->dev, node, handler_fn);
+	if (ret != 0)
+		goto free_name;
+
+	ret = set_platdata(platdata, uio_info, pdev);
+	if (ret != 0)
+		goto free_uioinfo;
+
+	platform_set_drvdata(pdev, platdata);
+	uio_info->open = pengic_open;
+	uio_info->release = release_fn;
+	uio_info->priv = platdata;
+
+	/* Map the device */
+	if (dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64)) != 0) {
+		dev_err(&pdev->dev, "no valid coherent DMA mask");
+		goto free_platdata;
+	}
+
+	pm_runtime_enable(&pdev->dev);
+
+	/* Ready to be a grown up UIO device now */
+	ret = uio_register_device(&pdev->dev, platdata->uio_info);
+	if (ret != 0) {
+		dev_err(&pdev->dev, "can't register UIO device: ret %d", ret);
+		pm_runtime_disable(&pdev->dev);
+		goto free_platdata;
+	}
+
+	/* Print mapping report */
+	for (i = 0; i < platdata->n_res; i++) {
+		dev_info(platdata->dev, "0x%llx->%p\n",
+			platdata->res[i].start,
+			uio_info->mem[i].internal_addr);
+	}
+
+	return 0;
+
+free_platdata:
+	free_platdata(platdata);
+
+free_uioinfo:
+	free_uio_info(uio_info, ARRAY_SIZE(platdata->res), platdata->dev);
+
+free_name:
+	kfree(uio_info->name);
+	uio_info->name = NULL;
+
+	dev_err(platdata->dev, "probe failed\n");
+	return ret;
+}
+
+/*
+ * pengic_probe - allocate and initialize state for device where normal EOI
+ *	processing is sufficient to process an interrupt
+ * @pdev:		Pointer to the platform device
+ */
+int pengic_probe(struct platform_device *pdev)
+{
+	return pengic_probe_common(pdev, pengic_handler, pengic_release);
+}
+EXPORT_SYMBOL(pengic_probe);
+
+/*
+ * pengic_probe_enable - allocate and initialize state for device where an
+ *	explicit call to irq_enable() is required to process an interrupt.
+ * @pdev:		Pointer to the platform device
+ */
+int pengic_probe_enable(struct platform_device *pdev)
+{
+	return pengic_probe_common(pdev, pengic_handler_disable,
+		pengic_release_enable);
+}
+EXPORT_SYMBOL(pengic_probe_enable);
+
+/*
+ * pengic_remove - free UIO-related data structures
+ *
+ * @pdev:	Pointer to the platform_device structure to remove
+ */
+int pengic_remove(struct platform_device *pdev)
+{
+	struct pengic_platdata *platdata;
+	struct uio_info *uio_info;
+	unsigned int n_res;
+
+	platdata = platform_get_drvdata(pdev);
+	uio_info = platdata->uio_info;
+	platdata->uio_info = NULL;
+	uio_info->priv = NULL;
+	n_res = platdata->n_res;
+
+	/* This should not be necessary but it's defensive programing in
+	 * case this driver gets called after it has been shutdown
+	 */
+	platform_set_drvdata(pdev, NULL);
+
+	free_platdata(platdata);
+	free_uio_info(uio_info, n_res, &pdev->dev);
+
+	pm_runtime_disable(&pdev->dev);
+
+	return 0;
+}
+EXPORT_SYMBOL(pengic_remove);
+
+/*
+ * pengic_pm_nop - Power management stub that just returns success
+ *
+ * We leave it to other drivers to handle the device power management
+ * operations, if any.
+ */
+static int pengic_pm_nop(struct device *dev)
+{
+	return 0;
+}
+
+const struct dev_pm_ops pengic_pm_ops = {
+	.runtime_suspend = pengic_pm_nop,
+	.runtime_resume = pengic_pm_nop,
+};
+EXPORT_SYMBOL(pengic_pm_ops);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Support userspace I/O for Pensando Ring interrupts");
+MODULE_AUTHOR("David VomLehn");
diff --git a/drivers/uio/uio_pengic.h b/drivers/uio/uio_pengic.h
new file mode 100644
index 00000000..6d1450b
--- /dev/null
+++ b/drivers/uio/uio_pengic.h
@@ -0,0 +1,18 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020-2021, Pensando Systems Inc.
+ */
+
+#ifndef _UIO_PENGIC_H_
+#define _UIO_PENGIC_H_
+
+#include <linux/of.h>
+#include <linux/platform_device.h>
+
+extern const struct dev_pm_ops pengic_pm_ops;
+
+int pengic_probe(struct platform_device *pdev);
+int pengic_probe_enable(struct platform_device *pdev);
+int pengic_remove(struct platform_device *pdev);
+
+#endif /* _UIO_PENGIC_H_ */
diff --git a/drivers/uio/uio_penmsi.c b/drivers/uio/uio_penmsi.c
new file mode 100644
index 00000000..84e1e07
--- /dev/null
+++ b/drivers/uio/uio_penmsi.c
@@ -0,0 +1,568 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020-2021, Pensando Systems Inc.
+ *
+ * UIO common driver for MSIX interrupts for Pensando system.
+ *
+ * As you read this, remember that it is the common portion of what will
+ * generally be many drivers. As such, functions like the probe() function have
+ * to deal with contention, which code that is one-per-driver do not. This
+ * makes things a bit more complex.
+ *
+ * The second complexity is that we have an asynchronous callback from MSIX.
+ * Since we don't now the context of that call, we pre-allocate the
+ * needed data structures from a context known to be suitable for memory
+ * allocation. When the callback is called, it simply dequeues the memory
+ * and puts it on an "in use" list. When the probe() function needs to
+ * allocate its platform data, it just uses one of the structures on the
+ * in use list.
+ */
+
+#include <linux/platform_data/uio_dmem_genirq.h>
+#include <linux/platform_device.h>
+
+#include <linux/atomic.h>
+#include <linux/dma-mapping.h>
+#include <linux/io.h>
+#include <linux/irq.h>
+#include <linux/list.h>
+#include <linux/module.h>
+#include <linux/msi.h>
+#include <linux/of_address.h>
+#include <linux/of.h>
+#include <linux/of_irq.h>
+#include <linux/pm_runtime.h>
+#include <linux/slab.h>
+#include <linux/uio_driver.h>
+#include <linux/wait.h>
+
+/* Optionally add attributes */
+#define ADD_ATTRS
+#undef ENABLE_STORE
+
+#ifdef ADD_ATTRS
+#define to_penmsi_dir(kobjp) container_of(kobjp, struct penmsi_dir, kobj)
+#endif
+
+/*
+ * devdata - information for a UIO device
+ * @pdev:		Pointer to the struct platform_device
+ * @platdata:		Pointer to the containing struct platdata
+ * @have_msi_index:	Indicates that @msi_index is valid
+ * @msi_index:		Index used to match descriptors with data
+ * @open:		Flag indicating whether this device is open
+ * @msi_msg:		MSI address and data information
+ * @list		Item in a list of allocated devdata items;
+ * @penmsi_dir:		Pointer to information about the penmsi directory
+ *			in which the command file lives
+ */
+struct devdata {
+	struct uio_info		uio_info;
+	struct platdata		*platdata;
+	bool			have_msi_msg;
+	bool			have_msi_desc;
+	u16			msi_index;
+	bool			open;
+	struct msi_msg		msi_msg;
+#ifdef ADD_ATTRS
+	struct penmsi_dir	*penmsi_dir;
+#endif
+};
+
+/*
+ * Per platform device
+ * @pdev:		Associated platform device
+ * @n_pending:		Remaining number of devdata items we are waiting for
+ * @n_irqs:		Number of IRQs being supported
+ * @n_valid:		Number of struct devdata items initialized for use
+ * @devdata:		Array of struct devdata items
+ */
+struct platdata {
+	struct platform_device	*pdev;
+	unsigned int		n_pending;
+	size_t			n_irqs;
+	unsigned int		n_valid;
+	struct devdata		devdatas[];
+};
+/*
+ * @penmsi_sem:		Protects the @init_platdata pointer and allocation of
+ *			MSI IRQs
+ * @init_platdata:	Pointer to the platdata currently being initialized.
+ *			This is only valid while @penmsi_sem is held
+ */
+static DEFINE_SEMAPHORE(penmsi_sem);
+static DECLARE_WAIT_QUEUE_HEAD(penmsi_wq_head);
+static DEFINE_SPINLOCK(penmsi_lock);
+static struct platdata *init_platdata;
+static unsigned int num_uio_devs;
+
+#ifdef ADD_ATTRS
+struct penmsi_dir {
+	struct kobject	kobj;
+	struct msi_msg	*msi_msg;
+	size_t		msi_size;
+};
+
+struct msi {
+	int			counter;
+	struct penmsi_dir	*penmsi_dir;
+};
+
+static ssize_t msi_show(struct msi_msg *msi_msg, char *buf)
+{
+	memcpy(buf, msi_msg, sizeof(*msi_msg));
+	return sizeof(*msi_msg);
+}
+
+#ifdef ENABLE_STORE
+static ssize_t msi_store(struct msi_msg *msi_msg, const char *buf,
+			 size_t size)
+{
+	if (size != sizeof(*msi_msg))
+		return -EINVAL;
+
+	memcpy(msi_msg, buf, sizeof(*msi_msg));
+	return sizeof(*msi_msg);
+}
+#else
+static ssize_t msi_store(struct msi_msg *msi_msg, const char *buf,
+			 size_t size)
+{
+	return -EOPNOTSUPP;
+}
+#endif
+
+struct msi_sysfs_entry {
+	struct attribute attr;
+	ssize_t (*show)(struct msi_msg *msg, char *buf);
+	ssize_t (*store)(struct msi_msg *msg, const char *buf, size_t sz);
+};
+
+static struct msi_sysfs_entry msi_attribute =
+	__ATTR(msi, 0600, msi_show, msi_store);
+
+static struct attribute *attrs[] = {
+	&msi_attribute.attr,
+	NULL,	/* need to NULL terminate the list of attributes */
+};
+
+static void penmsi_rel(struct kobject *kobj)
+{
+	struct penmsi_dir *penmsi_dir = to_penmsi_dir(kobj);
+
+	kfree(penmsi_dir);
+}
+
+static ssize_t penmsi_show(struct kobject *kobj, struct attribute *attr,
+			     char *buf)
+{
+	struct penmsi_dir *penmsi_dir = to_penmsi_dir(kobj);
+	struct msi_msg *msi_msg = penmsi_dir->msi_msg;
+	struct msi_sysfs_entry *entry;
+
+	entry = container_of(attr, struct msi_sysfs_entry, attr);
+
+	if (entry->show == NULL)
+		return -EOPNOTSUPP;
+	return entry->show(msi_msg, buf);
+}
+
+#ifdef ENABLE_STORE
+static ssize_t penmsi_store(struct kobject *kobj, struct attribute *attr,
+	const char *buf, size_t size)
+{
+	struct penmsi_dir *penmsi_dir = to_penmsi_dir(kobj);
+	struct msi *msi = penmsi_dir->msi;
+	struct msi_sysfs_entry *entry;
+
+	entry = container_of(attr, struct msi_sysfs_entry, attr);
+
+	if (entry->show == NULL)
+		return -EOPNOTSUPP;
+
+	return entry->store(msi, buf, size);
+}
+#else
+static ssize_t penmsi_store(struct kobject *kobj, struct attribute *attr,
+	const char *buf, size_t size)
+{
+	return -EOPNOTSUPP;
+}
+#endif
+
+static const struct sysfs_ops penmsi_sysfs_ops = {
+	.show = penmsi_show,
+	.store = penmsi_store,
+};
+
+static struct kobj_type penmsi_attr_type = {
+	.release	= penmsi_rel,
+	.sysfs_ops	= &penmsi_sysfs_ops,
+	.default_attrs	= attrs,
+};
+
+static int add_attr(struct devdata *devdata)
+{
+	struct penmsi_dir *penmsi_dir;
+	struct uio_device *uio_dev;
+	int ret;
+
+	/*
+	 * Create a kobject for the directory in which the command interface
+	 * lives
+	 */
+	uio_dev = devdata->uio_info.uio_dev;
+
+	/* Allocate storage for the command file */
+	penmsi_dir = kzalloc(sizeof(*penmsi_dir), GFP_KERNEL);
+	if (penmsi_dir == NULL)
+		return -ENOMEM;
+	devdata->penmsi_dir = penmsi_dir;
+	devdata->penmsi_dir->msi_msg = &devdata->msi_msg;
+	devdata->penmsi_dir->msi_size = sizeof(devdata->msi_msg);
+	kobject_init(&devdata->penmsi_dir->kobj, &penmsi_attr_type);
+
+	ret = kobject_add(&devdata->penmsi_dir->kobj, &uio_dev->dev.kobj,
+		"pensando");
+	if (ret != 0)
+		goto remove_penmsi_dir;
+
+	ret = kobject_uevent(&devdata->penmsi_dir->kobj, KOBJ_ADD);
+	if (ret != 0)
+		goto remove_penmsi_dir;
+
+	return 0;
+
+remove_penmsi_dir:
+	kobject_put(&devdata->penmsi_dir->kobj);
+	kfree(devdata->penmsi_dir);
+	devdata->penmsi_dir = NULL;
+
+	dev_err(&uio_dev->dev, "error creating sysfiles (%d)\n", ret);
+	return -EIO;
+}
+
+static void del_attr(struct devdata *devdata)
+{
+	kobject_put(&devdata->penmsi_dir->kobj);
+	devdata->penmsi_dir = NULL;
+}
+
+static int adorn_with_attrs(struct devdata *devdata)
+{
+	int rc;
+
+	rc = add_attr(devdata);
+	if (rc != 0) {
+		dev_err(&devdata->platdata->pdev->dev, "%s failed: %d\n",
+			__func__, rc);
+		goto remove_attrs;
+	}
+
+	return 0;
+
+remove_attrs:
+	del_attr(devdata);
+	return rc;
+
+}
+
+static void del_attrs(struct platdata *platdata)
+{
+	unsigned int i;
+
+	for (i = 0; i < platdata->n_irqs; i++)
+		del_attr(&platdata->devdatas[i]);
+}
+#else
+static inline int add_attr(struct devdata *devdata) { return 0; }
+static inline void del_attr(struct devdata *devdata) { }
+static inline void del_attrs(struct platdata *platdata) { }
+#endif
+
+static int penmsi_open(struct uio_info *uio_info, struct inode *inode)
+{
+	struct platdata *platdata;
+	struct devdata *devdata;
+	int ret;
+
+	devdata = uio_info->priv;
+	if (devdata->open)
+		return -EBUSY;
+	devdata->open = true;
+	ret = 0;
+
+	platdata = devdata->platdata;
+	pm_runtime_get_sync(&platdata->pdev->dev);
+
+	return ret;
+}
+
+static int penmsi_release(struct uio_info *uio_info, struct inode *inode)
+{
+	struct devdata *devdata;
+
+	devdata = uio_info->priv;
+	devdata->open = false;
+	pm_runtime_put_sync(&devdata->platdata->pdev->dev);
+
+	return 0;
+}
+
+
+/*
+ * The interrupt is edge triggered, so if we don't do anything and just
+ * return, nothing bad will happen. Yes, this is a bit unusual but
+ * it's useful.
+ */
+static irqreturn_t penmsi_handler(int irq, struct uio_info *uio_info)
+{
+	return IRQ_HANDLED;
+}
+
+static void decrement_pending(struct platdata *platdata)
+{
+	platdata->n_pending--;
+	if (platdata->n_pending == 0)
+		up(&penmsi_sem);
+}
+
+/*
+ * MSI callback function.
+ * stores the information it was passed, and queues it on the inuse list.
+ *
+ */
+static void penmsi_callback(struct msi_desc *desc, struct msi_msg *msg)
+{
+	struct devdata *devdata;
+	struct platdata *platdata;
+	unsigned long flags;
+
+	platdata = init_platdata;
+	devdata = &platdata->devdatas[desc->platform.msi_index];
+	devdata->msi_msg = *msg;
+
+	spin_lock_irqsave(&penmsi_lock, flags);
+	devdata->have_msi_msg = true;
+
+	if (devdata->have_msi_desc)
+		decrement_pending(platdata);
+	spin_unlock_irqrestore(&penmsi_lock, flags);
+}
+
+/*
+ * Remove the device completely
+ * @pdev:	Pointer to the struct platform_device we're using
+ */
+int penmsi_remove(struct platform_device *pdev)
+{
+	struct platdata *platdata;
+	unsigned int i;
+
+	platdata = platform_get_drvdata(pdev);
+	platform_msi_domain_free_irqs(&pdev->dev);
+	del_attrs(platdata);
+
+	// FIXME: this needs to use n_valid
+	for (i = 0; i < platdata->n_irqs; i++) {
+		struct devdata *devdata;
+		struct uio_info *uio_info;
+
+		devdata = &platdata->devdatas[i];
+		uio_info = &devdata->uio_info;
+		uio_unregister_device(uio_info);
+		kfree(uio_info->name);
+
+		/*
+		 * We're cheating with this, skip all the rest of the UIOs
+		 * so we don't free anything we shouldn't. This is going to
+		 * result in a memory leak.
+		 */
+		break;
+	}
+
+	kfree(platdata);
+
+	return 0;
+}
+EXPORT_SYMBOL(penmsi_remove);
+
+static int penmsi_probe_one(struct devdata *devdata,
+	struct platform_device *pdev, struct msi_desc *desc)
+{
+	struct uio_info *uio_info;
+	const char *dt_name;
+	char name_buf[32];
+	int rc;
+
+	uio_info = &devdata->uio_info;
+
+	rc = of_property_read_string(pdev->dev.of_node, "name", &dt_name);
+	if (rc != 0)
+		dt_name = "penmsiX";
+	snprintf(name_buf, sizeof(name_buf), "%s.%u", dt_name, num_uio_devs);
+	num_uio_devs++;
+	uio_info->name = kstrdup(name_buf, GFP_KERNEL);
+	if (uio_info->name == NULL)
+		return -ENOMEM;
+
+	/*
+	 * Only take one interrupt because UIO won't let us pass more than
+	 * that
+	 */
+	uio_info->priv = devdata;
+	uio_info->version = "0.1";
+	uio_info->open = penmsi_open;
+	uio_info->release = penmsi_release;
+	uio_info->handler = penmsi_handler;
+	uio_info->irq = desc->irq;
+	uio_info->irq_flags = IRQF_SHARED;
+
+	/* Ready to be a grown up UIO device now */
+	rc = uio_register_device(&pdev->dev, uio_info);
+	if (rc != 0) {
+		dev_err(&pdev->dev, "can't register UIO device");
+		goto free_name;
+	}
+
+	rc = adorn_with_attrs(devdata);
+	if (rc != 0)
+		goto unregister_uio;
+
+	return 0;
+
+unregister_uio:
+	uio_unregister_device(uio_info);
+
+free_name:
+	kfree(uio_info->name);
+	uio_info->name = NULL;
+
+	return rc;
+}
+
+/*
+ * Allocate a struct platdata with all of its devdata structures.
+ *
+ * Returns the a pointer to the allocated platdata on success, NULL otherwise
+ */
+static struct platdata *alloc_devdatas(unsigned int n)
+{
+	unsigned int i;
+	struct platdata *platdata;
+
+	platdata = kzalloc(offsetof(struct platdata, devdatas[n]), GFP_KERNEL);
+	if (platdata == NULL)
+		return platdata;
+
+	for (i = 0; i < n; i++)
+		platdata->devdatas[i].platdata = platdata;
+
+	platdata->n_pending = n;
+	platdata->n_irqs = n;
+
+	return platdata;
+}
+
+/*
+ * penmsi_probe - allocate and initialize state for device
+ */
+int penmsi_probe(struct platform_device *pdev)
+{
+	struct msi_desc *desc;
+	struct platdata *platdata;
+	struct devdata *devdata;
+	u32 num_interrupts;
+	int rc;
+
+	num_uio_devs = 0;
+	rc = of_property_read_u32(pdev->dev.of_node, "num-interrupts",
+		&num_interrupts);
+	if (rc != 0) {
+		dev_err(&pdev->dev, "num-interrupts property missing\n");
+		return rc;
+	}
+	if (num_interrupts == 0) {
+		dev_err(&pdev->dev, "num-interrupts property must be >0\n");
+		return -EINVAL;
+	}
+
+	platdata = alloc_devdatas(num_interrupts);
+	platform_set_drvdata(pdev, platdata);
+	platdata->n_irqs = num_interrupts;
+	platdata->pdev = pdev;
+
+	/* Due to the way MSI passes back information, we want to allocate
+	 * MSI IRQs one at a time.
+	 */
+	down(&penmsi_sem);
+	init_platdata = platdata;
+
+	/* Kick off work that should result in calling the callback */
+	rc = platform_msi_domain_alloc_irqs(&pdev->dev, num_interrupts,
+		penmsi_callback);
+	if (rc != 0) {
+		dev_err(&pdev->dev,
+			"platform_msi_domain_alloc_irqs failed: %d\n", rc);
+		goto up_sem;
+	}
+
+	for_each_msi_entry(desc, &pdev->dev) {
+		unsigned long flags;
+
+		devdata = &platdata->devdatas[desc->platform.msi_index];
+		spin_lock_irqsave(&penmsi_lock, flags);
+		devdata->have_msi_desc = true;
+		if (devdata->have_msi_msg)
+			decrement_pending(platdata);
+		spin_unlock_irqrestore(&penmsi_lock, flags);
+		rc = penmsi_probe_one(devdata, pdev, desc);
+		if (rc != 0)
+			goto free_msis;
+	}
+
+	init_platdata = NULL;		// Don't use this again
+	up(&penmsi_sem);
+
+	/* Map the device */
+	rc = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(64));
+	if (rc != 0) {
+		dev_err(&pdev->dev, "no valid coherent DMA mask");
+		goto free_msis;
+	}
+
+	pm_runtime_enable(&pdev->dev);
+
+	return 0;
+
+free_msis:
+	platform_msi_domain_free_irqs(&pdev->dev);
+
+up_sem:
+	up(&penmsi_sem);
+	kfree(platdata);
+	return rc;
+
+}
+EXPORT_SYMBOL(penmsi_probe);
+
+/*
+ * penmsi_pm_nop - Power management stub that just returns success
+ *
+ * We leave it to other drivers to handle the device power management
+ * operations, if any.
+ */
+static int penmsi_pm_nop(struct device *dev)
+{
+	return 0;
+}
+
+const struct dev_pm_ops penmsi_pm_ops = {
+	.runtime_suspend = penmsi_pm_nop,
+	.runtime_resume = penmsi_pm_nop,
+};
+EXPORT_SYMBOL(penmsi_pm_ops);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Support userspace I/O for Pensando MSIX interrupts");
+MODULE_AUTHOR("David VomLehn");
diff --git a/drivers/uio/uio_penmsi.h b/drivers/uio/uio_penmsi.h
new file mode 100644
index 00000000..6cbc4fb
--- /dev/null
+++ b/drivers/uio/uio_penmsi.h
@@ -0,0 +1,17 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2020-2021, Pensando Systems Inc.
+ */
+
+#ifndef _UIO_PENMSI_H_
+#define _UIO_PENMSI_H_
+
+#include <linux/of.h>
+#include <linux/platform_device.h>
+
+extern const struct dev_pm_ops penmsi_pm_ops;
+
+int penmsi_probe(struct platform_device *pdev);
+int penmsi_remove(struct platform_device *pdev);
+
+#endif /* _UIO_PENMSI_H_ */
diff --git a/drivers/uio/uio_penmsi1.c b/drivers/uio/uio_penmsi1.c
new file mode 100644
index 00000000..14aec07
--- /dev/null
+++ b/drivers/uio/uio_penmsi1.c
@@ -0,0 +1,32 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Copyright (c) 2020-2021, Pensando Systems Inc.
+ */
+
+#include <linux/module.h>
+#include "uio_penmsi.h"
+
+#define DRIVER_NAME_MSIX1	"uio_penmsi1"
+
+#ifdef CONFIG_OF
+static const struct of_device_id penmsi_match[] = {
+	{ .compatible = "pensando,uio_penmsi1" },
+	{ /* Mark the end of the list */ },
+};
+#endif
+
+static struct platform_driver penmsi1 = {
+	.probe = penmsi_probe,
+	.remove = penmsi_remove,
+	.driver = {
+		.name = DRIVER_NAME_MSIX1,
+		.pm = &penmsi_pm_ops,
+		.of_match_table = of_match_ptr(penmsi_match),
+	}
+};
+
+module_platform_driver(penmsi1);
+
+MODULE_LICENSE("GPL v2");
+MODULE_DESCRIPTION("Support userspace I/O for Pensando MSI interrupts");
+MODULE_AUTHOR("David VomLehn");
diff --git a/include/dt-bindings/reset/amd,pensando-elba-reset.h b/include/dt-bindings/reset/amd,pensando-elba-reset.h
new file mode 100644
index 00000000..2411ed4
--- /dev/null
+++ b/include/dt-bindings/reset/amd,pensando-elba-reset.h
@@ -0,0 +1,11 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2022 Advanced Micro Devices, Inc.
+ */
+
+#ifndef _DT_BINDINGS_RESET_AMD_PENSANDO_ELBA_RESET_H
+#define _DT_BINDINGS_RESET_AMD_PENSANDO_ELBA_RESET_H
+
+#define EMMC_HW_RESET		0
+
+#endif
diff --git a/include/linux/irqchip/irq-pensando.h b/include/linux/irqchip/irq-pensando.h
new file mode 100644
index 00000000..0716918
--- /dev/null
+++ b/include/linux/irqchip/irq-pensando.h
@@ -0,0 +1,91 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (c) 2019-2021, Pensando Systems Inc.
+ *
+ * Definitions for interrupt domain controllers for Pensando Capri and Elba chip
+ */
+
+#ifndef _LINUX_IRQCHIP_IRQ_CAPRI_H_
+#define _LINUX_IRQCHIP_IRQ_CAPRI_H_
+/* Types of possible register blocks */
+enum reg_type {
+	REG_TYPE_UNKNOWN,
+	REG_TYPE_CSR,
+	REG_TYPE_GRP,
+	REG_TYPE_CSRINTR,
+};
+
+/*
+ * Common format for interrupt block control registers for a CSR block
+ * @intreg:		Interrupt status on read, clear interrupt on write
+ * @int_test:		Test bits, write to cause corresponding interrupt
+ * @int_enable_set:	Write to set enable bits, read for current enable mask
+ * @int_enable_clear:	Write to clear enable bits
+ */
+struct pen_ictlr_csr {
+	u32	intreg;
+	u32	int_test;
+	u32	int_enable_set;
+	u32	int_enable_clear;
+};
+
+/*
+ * Common format for interrupt block control registers for a group
+ * @intreg:		Interrupt status on read, clear interrupt on write
+ * @int_enable_rw_reg:	Enable bits
+ * @int_rw_reg:		TBD
+ */
+struct pen_ictlr_grp {
+	u32	intreg;
+	u32	int_enable_rw_reg;
+	u32	int_rw_reg;
+};
+
+/*
+ * Common format for interrupt block control registers for a CSR interrupt
+ * block
+ * @intr:		Interrupt status in low order bit, i.e. bit 0. The
+ *			enable bit is bit 1.
+ */
+struct pen_ictlr_csrintr {
+	u32	intr;
+};
+
+/*
+ * Per domain information
+ * @reg_type:		Type of register block
+ * @domain:		Pointer to the associated &struct irq_domain
+ * @dn:			Pointer to the device tree device node for this
+ *			interrupt controller
+ * @irq_chip:		Pointer to the struct irq_chip for this domain (which
+ *			has just one)
+ * @num_irqs:		Number of IRQs for this chip
+ * @irq_lock:		Per-domain controller lock
+ * @irq_flag:		Flag set by spin_lock_irqsave() when used on
+ *			@irq_lock to be restored by spin_lock_irqrestore()
+ * @num_bases:		Number of virtual addresses in @map_base
+ * @map_base:		Virtual addresses of the beginning of the register
+ *			block, mapped from the reg property. Allocation
+ *			continues at the end to accommodate the values.
+ */
+struct pen_ictlr_info {
+	enum reg_type		reg_type;
+	struct irq_domain	*domain;
+	struct device_node	*dn;
+	struct irq_chip		*irq_chip;
+	unsigned int		parent_irq;
+	spinlock_t		irq_lock;
+	unsigned long		irq_flag;
+	unsigned int		num_bases;
+	void __iomem		*map_base[];
+};
+
+/* Enable/disable functions that do not recurse on their parents */
+void pen_irq_unmask_enable_csr_one(struct irq_data *irq_data);
+void pen_irq_mask_disable_csr_one(struct irq_data *irq_data);
+void pen_irq_unmask_enable_grp_one(struct irq_data *irq_data);
+void pen_irq_mask_disable_grp_one(struct irq_data *d);
+void pen_irq_unmask_enable_csrintr_one(struct irq_data *irq_data);
+void pen_irq_mask_disable_csrintr_one(struct irq_data *irq_data);
+
+#endif	/* _LINUX_IRQCHIP_IRQ_CAPRI_H_ */
diff --git a/include/linux/mfd/pensando-elbasr.h b/include/linux/mfd/pensando-elbasr.h
new file mode 100644
index 00000000..75103d0
--- /dev/null
+++ b/include/linux/mfd/pensando-elbasr.h
@@ -0,0 +1,41 @@
+/* SPDX-License-Identifier: (GPL-2.0+ OR MIT) */
+/*
+ * Copyright (c) 2022 Advanced Micro Devices, Inc.
+ *
+ * Declarations for AMD Pensando Elba System Resource Chip
+ */
+
+#ifndef __MFD_AMD_PENSANDO_ELBA_H
+#define __MFD_AMD_PENSANDO_ELBA_H
+
+#include <linux/cdev.h>
+#include <linux/regmap.h>
+
+#define ELBASR_CTRL0_REG	0x10
+#define ELBASR_MAX_REG		0xff
+#define ELBASR_NR_RESETS	1
+
+/*
+ * Pensando Elba System Resource MFD device private data structure
+ */
+struct elbasr_data {
+	dev_t devt;
+	int minor;
+	struct device *dev;
+	struct cdev *cdev;
+	struct spi_device *spi;
+	struct list_head device_entry;
+	spinlock_t spi_lock;
+
+	/* TX/RX buffers are NULL unless this device is open (users > 0) */
+	struct mutex buf_lock;
+	unsigned int users;
+	u8 *tx_buffer;
+	u8 *rx_buffer;
+	u32 speed_hz;
+
+	/* System Resource Chip CS0 register access */
+	struct regmap *elbasr_regs;
+};
+
+#endif /* __MFD_AMD_PENSANDO_ELBA_H */
-- 
1.8.3.1

